var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-BQR_2kKL.js"(exports, module) {
    function _mergeNamespaces(n, m) {
      for (var i = 0; i < m.length; i++) {
        const e = m[i];
        if (typeof e !== "string" && !Array.isArray(e)) {
          for (const k in e) {
            if (k !== "default" && !(k in n)) {
              const d = Object.getOwnPropertyDescriptor(e, k);
              if (d) {
                Object.defineProperty(n, k, d.get ? d : {
                  enumerable: true,
                  get: () => e[k]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production = {};
    /**
     * @license React
     * react-jsx-runtime.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactJsxRuntime_production;
    function requireReactJsxRuntime_production() {
      if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
      hasRequiredReactJsxRuntime_production = 1;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config2, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config2.key && (key = "" + config2.key);
        if ("key" in config2) {
          maybeKey = {};
          for (var propName in config2)
            "key" !== propName && (maybeKey[propName] = config2[propName]);
        } else maybeKey = config2;
        config2 = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config2 ? config2 : null,
          props: maybeKey
        };
      }
      reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_production.jsx = jsxProd;
      reactJsxRuntime_production.jsxs = jsxProd;
      return reactJsxRuntime_production;
    }
    var hasRequiredJsxRuntime;
    function requireJsxRuntime() {
      if (hasRequiredJsxRuntime) return jsxRuntime.exports;
      hasRequiredJsxRuntime = 1;
      {
        jsxRuntime.exports = requireReactJsxRuntime_production();
      }
      return jsxRuntime.exports;
    }
    var jsxRuntimeExports = requireJsxRuntime();
    var client = { exports: {} };
    var reactDomClient_production = {};
    var scheduler = { exports: {} };
    var scheduler_production = {};
    /**
     * @license React
     * scheduler.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredScheduler_production;
    function requireScheduler_production() {
      if (hasRequiredScheduler_production) return scheduler_production;
      hasRequiredScheduler_production = 1;
      (function(exports2) {
        function push(heap2, node) {
          var index2 = heap2.length;
          heap2.push(node);
          a: for (; 0 < index2; ) {
            var parentIndex = index2 - 1 >>> 1, parent = heap2[parentIndex];
            if (0 < compare(parent, node))
              heap2[parentIndex] = node, heap2[index2] = parent, index2 = parentIndex;
            else break a;
          }
        }
        function peek(heap2) {
          return 0 === heap2.length ? null : heap2[0];
        }
        function pop(heap2) {
          if (0 === heap2.length) return null;
          var first = heap2[0], last = heap2.pop();
          if (last !== first) {
            heap2[0] = last;
            a: for (var index2 = 0, length = heap2.length, halfLength = length >>> 1; index2 < halfLength; ) {
              var leftIndex = 2 * (index2 + 1) - 1, left = heap2[leftIndex], rightIndex = leftIndex + 1, right = heap2[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap2[index2] = right, heap2[rightIndex] = last, index2 = rightIndex) : (heap2[index2] = left, heap2[leftIndex] = last, index2 = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap2[index2] = right, heap2[rightIndex] = last, index2 = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        exports2.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports2.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports2.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
        var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        function shouldYieldToHost() {
          return needsPaint ? true : exports2.unstable_now() - startTime < frameInterval ? false : true;
        }
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports2.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports2.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        var schedulePerformWorkUntilDeadline;
        if ("function" === typeof localSetImmediate)
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        function requestHostTimeout(callback, ms2) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports2.unstable_now());
          }, ms2);
        }
        exports2.unstable_IdlePriority = 5;
        exports2.unstable_ImmediatePriority = 1;
        exports2.unstable_LowPriority = 4;
        exports2.unstable_NormalPriority = 3;
        exports2.unstable_Profiling = null;
        exports2.unstable_UserBlockingPriority = 2;
        exports2.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports2.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports2.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports2.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports2.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports2.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports2.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports2.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports2.unstable_shouldYield = shouldYieldToHost;
        exports2.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
      })(scheduler_production);
      return scheduler_production;
    }
    var hasRequiredScheduler;
    function requireScheduler() {
      if (hasRequiredScheduler) return scheduler.exports;
      hasRequiredScheduler = 1;
      {
        scheduler.exports = requireScheduler_production();
      }
      return scheduler.exports;
    }
    var react = { exports: {} };
    var react_production = {};
    /**
     * @license React
     * react.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReact_production;
    function requireReact_production() {
      if (hasRequiredReact_production) return react_production;
      hasRequiredReact_production = 1;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      }, assign = Object.assign, emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, self2, source, owner, props) {
        self2 = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== self2 ? self2 : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          void 0,
          oldElement.props
        );
      }
      function isValidElement(object2) {
        return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape2(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index2) {
        return "object" === typeof element && null !== element && null != element.key ? escape2("" + element.key) : index2.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error2) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error2);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array2,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array2, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array2.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array2,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array2,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array2,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array2 = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array2 ? "object with keys {" + Object.keys(children).join(", ") + "}" : array2) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count2 = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count2++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error2) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error2;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error2) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error2 && null !== error2 && "string" === typeof error2.message ? String(error2.message) : String(error2),
            error: error2
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error2);
          return;
        }
        console.error(error2);
      };
      function noop() {
      }
      react_production.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      react_production.Component = Component;
      react_production.Fragment = REACT_FRAGMENT_TYPE;
      react_production.Profiler = REACT_PROFILER_TYPE;
      react_production.PureComponent = PureComponent;
      react_production.StrictMode = REACT_STRICT_MODE_TYPE;
      react_production.Suspense = REACT_SUSPENSE_TYPE;
      react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      react_production.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      react_production.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      react_production.cloneElement = function(element, config2, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = void 0;
        if (null != config2)
          for (propName in void 0 !== config2.ref && (owner = void 0), void 0 !== config2.key && (key = "" + config2.key), config2)
            !hasOwnProperty.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, void 0, void 0, owner, props);
      };
      react_production.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      react_production.createElement = function(type, config2, children) {
        var propName, props = {}, key = null;
        if (null != config2)
          for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
            hasOwnProperty.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config2[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, void 0, void 0, null, props);
      };
      react_production.createRef = function() {
        return { current: null };
      };
      react_production.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      react_production.isValidElement = isValidElement;
      react_production.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      react_production.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      react_production.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error2) {
          reportGlobalError(error2);
        } finally {
          ReactSharedInternals.T = prevTransition;
        }
      };
      react_production.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      react_production.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      react_production.useActionState = function(action, initialState2, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState2, permalink);
      };
      react_production.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      react_production.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      react_production.useDebugValue = function() {
      };
      react_production.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      react_production.useEffect = function(create, createDeps, update) {
        var dispatcher = ReactSharedInternals.H;
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      react_production.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      react_production.useImperativeHandle = function(ref2, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref2, create, deps);
      };
      react_production.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      react_production.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      react_production.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      react_production.useOptimistic = function(passthrough, reducer2) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer2);
      };
      react_production.useReducer = function(reducer2, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer2, initialArg, init);
      };
      react_production.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      react_production.useState = function(initialState2) {
        return ReactSharedInternals.H.useState(initialState2);
      };
      react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      react_production.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      react_production.version = "19.1.0";
      return react_production;
    }
    var hasRequiredReact;
    function requireReact() {
      if (hasRequiredReact) return react.exports;
      hasRequiredReact = 1;
      {
        react.exports = requireReact_production();
      }
      return react.exports;
    }
    var reactDom = { exports: {} };
    var reactDom_production = {};
    /**
     * @license React
     * react-dom.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactDom_production;
    function requireReactDom_production() {
      if (hasRequiredReactDom_production) return reactDom_production;
      hasRequiredReactDom_production = 1;
      var React2 = requireReact();
      function formatProdErrorMessage(code) {
        var url2 = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url2 += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url2 += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop() {
      }
      var Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      reactDom_production.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container, null, key);
      };
      reactDom_production.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      reactDom_production.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      reactDom_production.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      reactDom_production.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      reactDom_production.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      reactDom_production.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      reactDom_production.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      reactDom_production.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      reactDom_production.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      reactDom_production.useFormState = function(action, initialState2, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState2, permalink);
      };
      reactDom_production.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      reactDom_production.version = "19.1.0";
      return reactDom_production;
    }
    var hasRequiredReactDom;
    function requireReactDom() {
      if (hasRequiredReactDom) return reactDom.exports;
      hasRequiredReactDom = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err2) {
          console.error(err2);
        }
      }
      {
        checkDCE();
        reactDom.exports = requireReactDom_production();
      }
      return reactDom.exports;
    }
    /**
     * @license React
     * react-dom-client.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactDomClient_production;
    function requireReactDomClient_production() {
      if (hasRequiredReactDomClient_production) return reactDomClient_production;
      hasRequiredReactDomClient_production = 1;
      var Scheduler = requireScheduler(), React2 = requireReact(), ReactDOM2 = requireReactDom();
      function formatProdErrorMessage(code) {
        var url2 = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url2 += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url2 += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      }, valueStack = [], index2 = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index2 || (cursor.current = valueStack[index2], valueStack[index2] = null, index2--);
      }
      function push(cursor, value) {
        index2++;
        valueStack[index2] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err2) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      var nextTransitionLane = 256, nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 4194048;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root2.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
        root2 = root2.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root2, renderLanes2) {
        return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root2, updateLane) {
        root2.pendingLanes |= updateLane;
        268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
      }
      function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root2.pendingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = 0;
        root2.pingedLanes = 0;
        root2.warmLanes = 0;
        root2.expiredLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        root2.errorRecoveryDisabledLanes &= remainingLanes;
        root2.shellSuspendCounter = 0;
        var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
          entanglements[index$5] = 0;
          expirationTimes[index$5] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$5];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
              var update = hiddenUpdatesForLane[index$5];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
        root2.pendingLanes |= spawnedLane;
        root2.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root2.entangledLanes |= spawnedLane;
        root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        for (root2 = root2.entanglements; rootEntangledLanes; ) {
          var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
          lane & entangledLanes | root2[index$6] & entangledLanes && (root2[index$6] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentSuspenseInstance(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root2) {
        var resources = root2[internalRootNodeResourcesKey];
        resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix$8 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      var prefix, suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$9) {
                      control = x$9;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$10) {
                    control = x$10;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          do
            info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        ), currentValue = "" + node[valueField];
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set2 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set2.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        node._valueTracker || (node._valueTracker = trackValueOnNode(node));
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
            return;
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = true;
              setDefaultSelected && (node[i].defaultSelected = true);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles)
            styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url2) {
        return isJavaScriptProtocol.test("" + url2) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url2;
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null, restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler) return fn(a, b);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var root = null, startText = null, fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null, activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        var JSCompiler_inline_result$jscomp$282;
        if (canUseDOM) {
          var isSupported$jscomp$inline_417 = "oninput" in document;
          if (!isSupported$jscomp$inline_417) {
            var element$jscomp$inline_418 = document.createElement("div");
            element$jscomp$inline_418.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
          }
          JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
        } else JSCompiler_inline_result$jscomp$282 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
      }
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        root2 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root2 + node.textContent.length;
            if (root2 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root2 };
            root2 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err2) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      }, prefixedEventNames = {}, style = {};
      canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode2) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode2;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode2) {
        return new FiberNode(tag, pendingProps, key, mode2);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode2, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode2), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode2, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode2 |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode2 | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode2), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode2), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode2);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode2, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode2);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode2, lanes) {
        content = createFiberImplClass(6, content, null, mode2);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromPortal(portal, mode2, lanes) {
        mode2 = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode2
        );
        mode2.lanes = lanes;
        mode2.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode2;
      }
      var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index3) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index3 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index3 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index3 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error2 = Error(formatProdErrorMessage(418, ""));
        queueHydrationError(createCapturedValueAtFiber(error2, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance);
            listenToNonDelegatedEvent("close", instance);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance);
            listenToNonDelegatedEvent("load", instance);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            track(instance);
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
        instance || throwOnHydrationMismatch(fiber);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          a: {
            fiber = fiber.nextSibling;
            for (tag = 0; fiber; ) {
              if (8 === fiber.nodeType)
                if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
                  if (0 === tag) {
                    nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                    break a;
                  }
                  tag--;
                } else
                  "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
              fiber = fiber.nextSibling;
            }
            nextHydratableInstance = null;
          }
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error2) {
        null === hydrationErrors ? hydrationErrors = [error2] : hydrationErrors.push(error2);
      }
      var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners2 = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners2.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners2.forEach(function(listener) {
            return listener();
          });
        };
      }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners2 = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners2.length; i++) (0, listeners2[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners2 = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners2.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners2.length; i++) (0, listeners2[i])(result);
          },
          function(error2) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error2;
            for (error2 = 0; error2 < listeners2.length; error2++)
              (0, listeners2[error2])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function noop$3() {
      }
      function trackUsedThenable(thenableState2, thenable, index3) {
        index3 = thenableState2[index3];
        void 0 === index3 ? thenableState2.push(thenable) : index3 !== thenable && (thenable.then(noop$3, noop$3), thenable = index3);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error2) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error2;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root2, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone2 = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone2 : newLast = newLast.next = clone2;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter$1 = 0;
        thenableState$1 = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
          thenableIndexCounter$1 = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter$1 = localIdCounter = 0;
        thenableState$1 = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index3 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        thenable = trackUsedThenable(thenableState$1, thenable, index3);
        index3 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index3.memoizedState : workInProgressHook.next) && (index3 = index3.alternate, ReactSharedInternals.H = null === index3 || null === index3.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array2) {
              return array2.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer2) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer2);
      }
      function updateReducerImpl(hook, current, reducer2) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer2;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer2(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer2(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer2 = currentEntangledActionThenable, null !== reducer2)))
            throw reducer2;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer2) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer2;
        var dispatch2 = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer2(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch2];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, 8, create, [subscribe]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
      }
      function mountStateImpl(initialState2) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState2) {
          var initialStateInitializer = initialState2;
          initialState2 = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState2;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState2
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer2) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer2 ? reducer2 : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error2) {
            onActionError(actionQueue, node, error2);
          } finally {
            ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$38) {
            onActionError(actionQueue, node, error$38);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error2) {
            return onActionError(actionQueue, node, error2);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error2) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error2, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch2 = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          createEffectInstance(),
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch2, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch2 = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch2, false];
      }
      function pushSimpleEffect(tag, inst, create, createDeps) {
        tag = { tag, create, deps: createDeps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
        return tag;
      }
      function createEffectInstance() {
        return { destroy: void 0, resource: void 0 };
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
        var hook = mountWorkInProgressHook();
        createDeps = void 0 === createDeps ? null : createDeps;
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          createEffectInstance(),
          create,
          createDeps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, createDeps) {
        mountEffectImpl(8390656, 8, create, createDeps);
      }
      function updateEffect(create, createDeps) {
        updateEffectImpl(2048, 8, create, createDeps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref2) {
        if ("function" === typeof ref2) {
          create = create();
          var refCleanup = ref2(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref2(null);
          };
        }
        if (null !== ref2 && void 0 !== ref2)
          return create = create(), ref2.current = create, function() {
            ref2.current = null;
          };
      }
      function updateImperativeHandle(ref2, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref2]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref2), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error2) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error2 },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function noop$2() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop$2 : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
        dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$41 = enqueueUpdate(provider, fiber, lane);
              null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error2) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root2, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      }, HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref2, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref2]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref2),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer2, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState2 = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState2 = initialArg;
          hook.memoizedState = hook.baseState = initialState2;
          reducer2 = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer2,
            lastRenderedState: initialState2
          };
          hook.queue = reducer2;
          reducer2 = reducer2.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer2
          );
          return [hook.memoizedState, reducer2];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState2) {
          initialState2 = mountStateImpl(initialState2);
          var queue = initialState2.queue, dispatch2 = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch2;
          return [initialState2.memoizedState, dispatch2];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "«" + identifierPrefix + "R" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "»";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "«" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "»";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
      }, HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer2) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer2);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      }, HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer2) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer2);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      }, thenableState = null, thenableIndexCounter = 0;
      function unwrapThenable(thenable) {
        var index3 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index3);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function resolveLazy(lazyType) {
        var init = lazyType._init;
        return init(lazyType._payload);
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
          if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
            var current = fiber.alternate;
            null !== current && null !== current.memoizedState && (shellBoundary = fiber);
          }
        } else reuseSuspenseHandlerOnStack();
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error2) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error2 && null !== error2 && "string" === typeof error2.message ? String(error2.message) : String(error2),
            error: error2
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error2);
          return;
        }
        console.error(error2);
      };
      function defaultOnUncaughtError(error2) {
        reportGlobalError(error2);
      }
      function defaultOnCaughtError(error2) {
        console.error(error2);
      }
      function defaultOnRecoverableError(error2) {
        reportGlobalError(error2);
      }
      function logUncaughtError(root2, errorInfo) {
        try {
          var onUncaughtError = root2.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root2, boundary, errorInfo) {
        try {
          var onCaughtError = root2.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root2, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root2, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error2 = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error2);
          };
          update.callback = function() {
            logCaughtError(root2, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root2, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root2.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root2,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref2 = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref2,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextChildren = workInProgress2.child = current.child;
              for (prevState = 0; null !== nextChildren; )
                prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
              workInProgress2.childLanes = prevState & ~nextProps;
            } else workInProgress2.childLanes = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              nextProps,
              renderLanes2
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        return null;
      }
      function markRef(current, workInProgress2) {
        var ref2 = workInProgress2.ref;
        if (null === ref2)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref2 && "object" !== typeof ref2)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref2)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
            if (isHydrating) {
              var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
              if (JSCompiler_temp$jscomp$0 = nextInstance) {
                c: {
                  JSCompiler_temp$jscomp$0 = nextInstance;
                  for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                    if (!nextInstance) {
                      nextInstance = null;
                      break c;
                    }
                    JSCompiler_temp$jscomp$0 = getNextHydratable(
                      JSCompiler_temp$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_temp$jscomp$0) {
                      nextInstance = null;
                      break c;
                    }
                  }
                  nextInstance = JSCompiler_temp$jscomp$0;
                }
                null !== nextInstance ? (workInProgress2.memoizedState = {
                  dehydrated: nextInstance,
                  treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                  retryLane: 536870912,
                  hydrationErrors: null
                }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
                  18,
                  null,
                  null,
                  0
                ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
              }
              JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
            }
            nextInstance = workInProgress2.memoizedState;
            if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
              return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
            popSuspenseHandler(workInProgress2);
          }
          nextInstance = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextInstance },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
        }
        JSCompiler_temp$jscomp$0 = current.memoizedState;
        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            ), showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes2,
              null
            ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
            JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
              throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
              nextInstance.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes2,
            cachePool: JSCompiler_temp$jscomp$0
          }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode2) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode2);
        offscreenProps.lanes = 0;
        offscreenProps.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        };
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & 2))
          nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
        else {
          if (null !== current && 0 !== (current.flags & 128))
            a: for (current = workInProgress2.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress2) break a;
              for (; null === current.sibling; ) {
                if (null === current.return || current.return === workInProgress2)
                  break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
          nextProps &= 1;
        }
        push(suspenseStackCursor, nextProps);
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode
            );
            break;
          case "backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode
            );
            break;
          case "together":
            initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 13:
            var state = workInProgress2.memoizedState;
            if (null !== state) {
              if (null !== state.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state) break;
            else return null;
          case 22:
          case 23:
            return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              current = workInProgress2.pendingProps;
              var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
              lazyComponent = init(lazyComponent._payload);
              workInProgress2.type = lazyComponent;
              if ("function" === typeof lazyComponent)
                shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                ));
              else {
                if (void 0 !== lazyComponent && null !== lazyComponent) {
                  if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  } else if (init === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
              lazyComponent,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              lazyComponent,
              init,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              lazyComponent = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              init = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              lazyComponent = nextState.cache;
              pushProvider(workInProgress2, CacheContext, lazyComponent);
              lazyComponent !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              lazyComponent = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: lazyComponent,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else if (lazyComponent !== init) {
                  init = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError(init);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    lazyComponent,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (lazyComponent === init) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(
                  current,
                  workInProgress2,
                  lazyComponent,
                  renderLanes2
                );
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(
              lazyComponent.firstChild
            )) : nextHydratableInstance = init), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if (init = lazyComponent = nextHydratableInstance)
                lazyComponent = canHydrateInstance(
                  lazyComponent,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                  lazyComponent.firstChild
                ), rootOrSingletonContext = false, init = true) : init = false;
              init || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            init = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            lazyComponent = prevState.children;
            shouldSetTextContent(init, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && (init = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = init);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              lazyComponent,
              renderLanes2
            ) : reconcileChildren(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            ), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
              current,
              workInProgress2,
              lazyComponent.children,
              renderLanes2
            ), workInProgress2.child;
          case 9:
            return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
              mode: lazyComponent.mode,
              children: lazyComponent.children
            }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
              lazyComponent,
              renderLanes2
            ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
          case 22:
            return updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, prevState = createCache(), init.pooledCache = prevState, prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes2), init = prevState), workInProgress2.memoizedState = {
              parent: lazyComponent,
              cache: init
            }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
          resource = suspenseHandlerStackCursor.current;
          if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          workInProgress2.flags |= 8192;
        }
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$113 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
        else
          for (child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 31:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            var type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            renderLanes2 = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2);
              else {
                type = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (current) {
                  case 1:
                    current = type.createElementNS(
                      "http://www.w3.org/2000/svg",
                      renderLanes2
                    );
                    break;
                  case 2:
                    current = type.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      renderLanes2
                    );
                    break;
                  default:
                    switch (renderLanes2) {
                      case "svg":
                        current = type.createElementNS(
                          "http://www.w3.org/2000/svg",
                          renderLanes2
                        );
                        break;
                      case "math":
                        current = type.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          renderLanes2
                        );
                        break;
                      case "script":
                        current = type.createElement("div");
                        current.innerHTML = "<script><\/script>";
                        current = current.removeChild(current.firstChild);
                        break;
                      case "select":
                        current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                        newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                        break;
                      default:
                        current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
                    }
                }
                current[internalInstanceKey] = workInProgress2;
                current[internalPropsKey] = newProps;
                a: for (type = workInProgress2.child; null !== type; ) {
                  if (5 === type.tag || 6 === type.tag)
                    current.appendChild(type.stateNode);
                  else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                    type.child.return = type;
                    type = type.child;
                    continue;
                  }
                  if (type === workInProgress2) break a;
                  for (; null === type.sibling; ) {
                    if (null === type.return || type.return === workInProgress2)
                      break a;
                    type = type.return;
                  }
                  type.sibling.return = type.return;
                  type = type.sibling;
                }
                workInProgress2.stateNode = current;
                a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    current = !!newProps.autoFocus;
                    break a;
                  case "img":
                    current = true;
                    break a;
                  default:
                    current = false;
                }
                current && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            workInProgress2.flags &= -16777217;
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            if (renderLanes2) {
              newProps = workInProgress2.child;
              type = null;
              null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
              var cache$127 = null;
              null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
              cache$127 !== type && (newProps.flags |= 2048);
            }
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            type = workInProgress2.memoizedState;
            if (null === type) return bubbleProperties(workInProgress2), null;
            newProps = 0 !== (workInProgress2.flags & 128);
            cache$127 = type.rendering;
            if (null === cache$127)
              if (newProps) cutOffTailIfNeeded(type, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    cache$127 = findFirstSuspended(current);
                    if (null !== cache$127) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(type, false);
                      current = cache$127.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!newProps)
                if (current = findFirstSuspended(cache$127), null !== current) {
                  if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
            }
            if (null !== type.tail)
              return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error2) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error2
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error2) {
          captureCommitPhaseError(current, nearestMountedAncestor, error2);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref2 = current.ref;
          if (null !== ref2) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref2 ? current.refCleanup = ref2(instanceToUse) : ref2.current = instanceToUse;
          }
        } catch (error2) {
          captureCommitPhaseError(current, nearestMountedAncestor, error2);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref2 = current.ref, refCleanup = current.refCleanup;
        if (null !== ref2)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error2) {
              captureCommitPhaseError(current, nearestMountedAncestor, error2);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref2)
            try {
              ref2(null);
            } catch (error$143) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$143);
            }
          else ref2.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance.focus();
              break a;
            case "img":
              props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
          }
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
      }
      var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
      function commitBeforeMutationEffects(root2, firstChild) {
        root2 = root2.containerInfo;
        eventsEnabled = _enabled;
        root2 = getActiveElementDeep(root2);
        if (hasSelectionCapabilities(root2)) {
          if ("selectionStart" in root2)
            var JSCompiler_temp = {
              start: root2.selectionStart,
              end: root2.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                    node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root2) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
            root2.return = firstChild, nextEffect = root2;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root2 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root2 & 1024) && null !== focusNode) {
                    root2 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset,
                        JSCompiler_temp.elementType === JSCompiler_temp.type
                      );
                      root2 = selection.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection.__reactInternalSnapshotBeforeUpdate = root2;
                    } catch (error2) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error2
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root2 & 1024)) {
                    if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root2);
                    else if (1 === JSCompiler_temp)
                      switch (root2.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root2);
                          break;
                        default:
                          root2.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root2 = firstChild.sibling;
              if (null !== root2) {
                root2.return = firstChild.return;
                nextEffect = root2;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$142) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$142
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null, hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err2) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error2) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error2
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error2) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error2
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root2 = childToDelete.alternate;
            null !== root2 && (root2.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13878)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root2) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root2.containerInfo);
            recursivelyTraverseMutationEffects(root2, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root2.containerInfo);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 13:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
                if (5 === root2.tag || 26 === root2.tag) {
                  if (null === current) {
                    wasHidden = current = root2;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error2) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error2);
                    }
                  }
                } else if (6 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error2) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error2);
                    }
                  }
                } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork) break a;
                for (; null === root2.sibling; ) {
                  if (null === root2.return || root2.return === finishedWork) break a;
                  current === root2 && (current = null);
                  root2 = root2.return;
                }
                current === root2 && (current = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$144 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
                var before$145 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
                break;
              case 3:
              case 4:
                var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$147,
                  parent$146
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root2, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error2) {
                  captureCommitPhaseError(current, current.return, error2);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error2) {
                  captureCommitPhaseError(current, current.return, error2);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root2,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id2,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id2 = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(fiber);
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(fiber);
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        }
      }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
      function requestUpdateLane() {
        if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        if (null !== ReactSharedInternals.T) {
          var actionScopeLane = currentEntangledLane;
          return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
        }
        return resolveUpdatePriority();
      }
      function requestDeferredLane() {
        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root2, fiber, lane) {
        if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          prepareFreshStack(root2, 0), markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root2, lane);
        if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
          root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root2);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root2 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root2,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    2,
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root2.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
            root2.cancelPendingCommit = suspendedCommitReason(
              commitRoot.bind(
                null,
                root2,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                1,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check2 = tag[i], getSnapshot = check2.getSnapshot;
              check2 = check2.value;
              try {
                if (!objectIs(getSnapshot(), check2)) return false;
              } catch (error2) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root2.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
          didAttemptEntireTree[index$4] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root2, lanes) {
        var timeoutHandle = root2.timeoutHandle;
        -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root2.cancelPendingCommit;
        null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root2;
        workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root2.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
            lanes |= root2[index$2];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root2, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        ));
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root2, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$167) {
            handleThrow(root2, thrownValue$167);
          }
        while (1);
        lanes && root2.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root2,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root2);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : 1) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$169) {
            handleThrow(root2, thrownValue$169);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState = null;
        thenableIndexCounter = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root2,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error2) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error2;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root2 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root2 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root2);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root2.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root2,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root2;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects();
            return null;
          })) : (root2.callbackNode = null, root2.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root2, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root2);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root2.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
          var remainingLanes = root2.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err2) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root2);
          remainingLanes = root2.pendingLanes;
          0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0);
        }
      }
      function releaseRootPooledCache(root2, remainingLanes) {
        0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects(wasDelayedCommit) {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects();
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err2) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
        sourceFiber = createCapturedValueAtFiber(error2, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error2) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error2);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error2
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error2, sourceFiber);
                error2 = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error2, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error2,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        if (null === pingCache) {
          pingCache = root2.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        root2.warmLanes &= ~pingedLanes;
        workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root2);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root2) {
        root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$174 = firstScheduledRoot; null !== root$174; ) {
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root$174.pendingLanes;
                if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                else {
                  var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
                  JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                }
                0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
              } else
                JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                  root$174,
                  root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
                  null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
                ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
              root$174 = root$174.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
        for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
          var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
          if (0 === nextLanes)
            root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root2 = next;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
      }
      function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
        for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
          var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root2,
          root2 === currentTime ? suspendedLanes : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        pingedLanes = root2.callbackNode;
        if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root2.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root2.callbackPriority = currentTime;
          root2.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root2.callbackPriority = 2;
        root2.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root2.callbackNode = null, root2.callbackPriority = 0, null;
        var originalCallbackNode = root2.callbackNode;
        if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root2,
          root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root2, now());
        return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
      }
      function performSyncWorkOnRoot(root2, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root2, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
        var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1530,
          "on" + capitalizedEvent$jscomp$inline_1531
        );
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ), nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error2) {
                  reportGlobalError(error2);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error2) {
                  reportGlobalError(error2);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container = targetInst$jscomp$0.stateNode.containerInfo;
              if (container === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container; ) {
                nodeTag = getClosestInstanceFromNode(container);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container = container.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = SyntheticEventCtor;
                      reactEventName = reactEventType;
                      instance = 0;
                      for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                        instance++;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                        lastHostComponent++;
                      for (; 0 < instance - lastHostComponent; )
                        inCapturePhase = getParent(inCapturePhase), instance--;
                      for (; 0 < lastHostComponent - instance; )
                        reactEventName = getParent(reactEventName), lastHostComponent--;
                      for (; instance--; ) {
                        if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                          break b;
                        inCapturePhase = getParent(inCapturePhase);
                        reactEventName = getParent(reactEventName);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners2 = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners2.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners2.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners2;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners2 = []; null !== target && target !== common; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners2.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners2.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners2.length && dispatchQueue.push({ event, listeners: listeners2 });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function noop$1() {
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$188 = props[hasSrc];
                if (null != propValue$188)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$188;
                      break;
                    case "type":
                      propValue = propValue$188;
                      break;
                    case "checked":
                      checked = propValue$188;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$188;
                      break;
                    case "value":
                      propKey = propValue$188;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$188;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$188)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$188, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            track(domElement);
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            track(domElement);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$188 in props)
                props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$188,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$205 in nextProps) {
              var propKey = nextProps[propKey$205];
              lastProp = lastProps[propKey$205];
              if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
                switch (propKey$205) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$205,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$205 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$205 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$205 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$205 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$205, propKey);
            return;
          case "option":
            for (var propKey$221 in lastProps)
              if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
                switch (propKey$221) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$221,
                      null,
                      nextProps,
                      propKey$205
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$226 in lastProps)
              propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
            for (checked in nextProps)
              if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$205)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$231 in lastProps)
                propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$231,
                  void 0,
                  nextProps,
                  propKey$205
                );
              for (defaultChecked in nextProps)
                propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$205,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$236 in lastProps)
          propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
        for (lastProp in nextProps)
          propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
      }
      var eventsEnabled = null, selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error2) {
        setTimeout(function() {
          throw error2;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node) {
              if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                node = possiblePreambleContribution;
                var ownerDocument = parentInstance.ownerDocument;
                node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
                node & 2 && releaseSingletonInstance(ownerDocument.body);
                if (node & 4)
                  for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                    var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                    ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                    ownerDocument = nextNode$jscomp$0;
                  }
              }
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              }
              depth--;
            } else
              "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
          else possiblePreambleContribution = 0;
          node = nextNode;
        } while (node);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearContainerSparingly(container) {
        var nextNode = container.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop")) break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence")) break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstanceFallback(instance) {
        return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getParentSuspenseInstance(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data2 = targetInstance.data;
            if ("$" === data2 || "$!" === data2 || "$?" === data2) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" === data2 && depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container) {
        return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$244 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$245 = styles$244.get(type);
              resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$245.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$245;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$250 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$250)
                return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$250);
              var linkInstance = instance$250;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$250, "link", instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$250, props.precedence, hoistableRoot);
              return resource.instance = instance$250;
            case "script":
              instance$250 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$250)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(instance$250))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root2) {
        for (var nodes = root2.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      var suspendedState = null;
      function noop() {
      }
      function suspendResource(hoistableRoot, resource, props) {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      function waitForCommitToBeReady() {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4);
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root2, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root2);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root2, precedences);
            for (var nodes = root2.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i = precedences.get(node) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        container = createUpdate(lane);
        container.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root2 = fiber;
                        root2.pendingLanes |= 2;
                        for (root2.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root2.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                      }
                    }
                    break;
                  case 13:
                    root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  if (13 === nearestMounted.tag) {
                    var lane = requestUpdateLane();
                    lane = getBumpedLaneForHydrationByLane(lane);
                    var root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                    null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                    markRetryLaneIfNotHydrated(nearestMounted, lane);
                  }
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (null === root2) throw Error(formatProdErrorMessage(409));
        var current = root2.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root2 = this._internalRoot;
        if (null !== root2) {
          this._internalRoot = null;
          var container = root2.containerInfo;
          updateContainerImpl(root2.current, 2, null, root2, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1785 = React2.version;
      if ("19.1.0" !== isomorphicReactPackageVersion$jscomp$inline_1785)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1785,
            "19.1.0"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2256 = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.1.0"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2257.inject(
              internals$jscomp$inline_2256
            ), injectedHook = hook$jscomp$inline_2257;
          } catch (err2) {
          }
      }
      reactDomClient_production.createRoot = function(container, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
        options2 = createFiberRoot(
          container,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          null
        );
        container[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMRoot(options2);
      };
      reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      reactDomClient_production.version = "19.1.0";
      return reactDomClient_production;
    }
    var hasRequiredClient;
    function requireClient() {
      if (hasRequiredClient) return client.exports;
      hasRequiredClient = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err2) {
          console.error(err2);
        }
      }
      {
        checkDCE();
        client.exports = requireReactDomClient_production();
      }
      return client.exports;
    }
    var clientExports = requireClient();
    const ReactDOM$2 = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
    var reactExports = requireReact();
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [reactExports]);
    var reactDomExports = requireReactDom();
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: ReactDOM
    }, [reactDomExports]);
    /**
     * @remix-run/router v1.23.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$2() {
      _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    var Action$1;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action$1 || (Action$1 = {}));
    const PopStateEventType = "popstate";
    function createHashHistory(options) {
      if (options === void 0) {
        options = {};
      }
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search = "",
          hash = ""
        } = parsePath(window2.location.hash.substr(1));
        if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
          pathname = "/" + pathname;
        }
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to) {
        let base = window2.document.querySelector("base");
        let href = "";
        if (base && base.getAttribute("href")) {
          let url2 = window2.location.href;
          let hashIndex = url2.indexOf("#");
          href = hashIndex === -1 ? url2 : url2.slice(0, hashIndex);
        }
        return href + "#" + (typeof to === "string" ? to : createPath(to));
      }
      function validateHashLocation(location, to) {
        warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
      }
      return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
          throw new Error(message);
        } catch (e) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index2) {
      return {
        usr: location.state,
        key: location.key,
        idx: index2
      };
    }
    function createLocation(current, to, state, key) {
      if (state === void 0) {
        state = null;
      }
      let location = _extends$2({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to === "string" ? parsePath(to) : to, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      });
      return location;
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search = "",
        hash = ""
      } = _ref;
      if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substr(hashIndex);
          path = path.substr(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substr(searchIndex);
          path = path.substr(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      if (options === void 0) {
        options = {};
      }
      let {
        window: window2 = document.defaultView,
        v5Compat = false
      } = options;
      let globalHistory = window2.history;
      let action = Action$1.Pop;
      let listener = null;
      let index2 = getIndex();
      if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends$2({}, globalHistory.state, {
          idx: index2
        }), "");
      }
      function getIndex() {
        let state = globalHistory.state || {
          idx: null
        };
        return state.idx;
      }
      function handlePop() {
        action = Action$1.Pop;
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index2;
        index2 = nextIndex;
        if (listener) {
          listener({
            action,
            location: history.location,
            delta
          });
        }
      }
      function push(to, state) {
        action = Action$1.Push;
        let location = createLocation(history.location, to, state);
        if (validateLocation) validateLocation(location, to);
        index2 = getIndex() + 1;
        let historyState = getHistoryState(location, index2);
        let url2 = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url2);
        } catch (error2) {
          if (error2 instanceof DOMException && error2.name === "DataCloneError") {
            throw error2;
          }
          window2.location.assign(url2);
        }
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 1
          });
        }
      }
      function replace(to, state) {
        action = Action$1.Replace;
        let location = createLocation(history.location, to, state);
        if (validateLocation) validateLocation(location, to);
        index2 = getIndex();
        let historyState = getHistoryState(location, index2);
        let url2 = history.createHref(location);
        globalHistory.replaceState(historyState, "", url2);
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 0
          });
        }
      }
      function createURL(to) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
        let href = typeof to === "string" ? to : createPath(to);
        href = href.replace(/ $/, "%20");
        invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
        return new URL(href, base);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to) {
          return createHref(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url2 = createURL(to);
          return {
            pathname: url2.pathname,
            search: url2.search,
            hash: url2.hash
          };
        },
        push,
        replace,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2["data"] = "data";
      ResultType2["deferred"] = "deferred";
      ResultType2["redirect"] = "redirect";
      ResultType2["error"] = "error";
    })(ResultType || (ResultType = {}));
    const immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    function isIndexRoute(route) {
      return route.index === true;
    }
    function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
      if (parentPath === void 0) {
        parentPath = [];
      }
      if (manifest === void 0) {
        manifest = {};
      }
      return routes.map((route, index2) => {
        let treePath = [...parentPath, String(index2)];
        let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
        invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
        invariant(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
        if (isIndexRoute(route)) {
          let indexRoute = _extends$2({}, route, mapRouteProperties2(route), {
            id: id2
          });
          manifest[id2] = indexRoute;
          return indexRoute;
        } else {
          let pathOrLayoutRoute = _extends$2({}, route, mapRouteProperties2(route), {
            id: id2,
            children: void 0
          });
          manifest[id2] = pathOrLayoutRoute;
          if (route.children) {
            pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
          }
          return pathOrLayoutRoute;
        }
      });
    }
    function matchRoutes(routes, locationArg, basename) {
      if (basename === void 0) {
        basename = "/";
      }
      return matchRoutesImpl(routes, locationArg, basename, false);
    }
    function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i) {
        let decoded = decodePath(pathname);
        matches = matchRouteBranch(branches[i], decoded, allowPartial);
      }
      return matches;
    }
    function convertRouteMatchToUiMatch(match, loaderData) {
      let {
        route,
        pathname,
        params
      } = match;
      return {
        id: route.id,
        pathname,
        params,
        data: loaderData[route.id],
        handle: route.handle
      };
    }
    function flattenRoutes(routes, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      let flattenRoute = (route, index2, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index2,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
          );
          flattenRoutes(route.children, branches, routesMeta, path);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index2) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
          flattenRoute(route, index2);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index2, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments2 = path.split("/");
      if (segments2.length === 0) return [];
      let [first, ...rest] = segments2;
      let isOptional = first.endsWith("?");
      let required2 = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required2, ""] : [required2];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(...restExploded.map((subpath) => subpath === "" ? required2 : [required2, subpath].join("/")));
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
    }
    const paramRe = /^:[\w-]+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s) => s === "*";
    function computeScore(path, index2) {
      let segments2 = path.split("/");
      let initialScore = segments2.length;
      if (segments2.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index2) {
        initialScore += indexRouteValue;
      }
      return segments2.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b) {
      let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname, allowPartial) {
      if (allowPartial === void 0) {
        allowPartial = false;
      }
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end
        }, remainingPathname);
        let route = meta.route;
        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
          match = matchPath({
            path: meta.relativePath,
            caseSensitive: meta.caseSensitive,
            end: false
          }, remainingPathname);
        }
        if (!match) {
          return null;
        }
        Object.assign(matchedParams, match.params);
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
          route
        });
        if (match.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = {
          path: pattern,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
      let match = pathname.match(matcher);
      if (!match) return null;
      let matchedPathname = match[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match.slice(1);
      let params = compiledParams.reduce((memo, _ref, index2) => {
        let {
          paramName,
          isOptional
        } = _ref;
        if (paramName === "*") {
          let splatValue = captureGroups[index2] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value = captureGroups[index2];
        if (isOptional && !value) {
          memo[paramName] = void 0;
        } else {
          memo[paramName] = (value || "").replace(/%2F/g, "/");
        }
        return memo;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end === void 0) {
        end = true;
      }
      warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
        params.push({
          paramName,
          isOptional: isOptional != null
        });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      });
      if (path.endsWith("*")) {
        params.push({
          paramName: "*"
        });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function decodePath(value) {
      try {
        return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
      } catch (error2) {
        warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error2 + ")."));
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/") return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments2 = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments2.length > 1) segments2.pop();
        } else if (segment !== ".") {
          segments2.push(segment);
        }
      });
      return segments2.length > 1 ? segments2.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
    }
    function getResolveToMatches(matches, v7_relativeSplatPath) {
      let pathMatches = getPathContributingMatches(matches);
      if (v7_relativeSplatPath) {
        return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
      }
      return pathMatches.map((match) => match.pathnameBase);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      if (isPathRelative === void 0) {
        isPathRelative = false;
      }
      let to;
      if (typeof toArg === "string") {
        to = parsePath(toArg);
      } else {
        to = _extends$2({}, toArg);
        invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
        invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
        invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
      }
      let isEmptyPath = toArg === "" || to.pathname === "";
      let toPathname = isEmptyPath ? "/" : to.pathname;
      let from;
      if (toPathname == null) {
        from = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    class ErrorResponseImpl {
      constructor(status, statusText, data2, internal) {
        if (internal === void 0) {
          internal = false;
        }
        this.status = status;
        this.statusText = statusText || "";
        this.internal = internal;
        if (data2 instanceof Error) {
          this.data = data2.toString();
          this.error = data2;
        } else {
          this.data = data2;
        }
      }
    }
    function isRouteErrorResponse(error2) {
      return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"];
    const validMutationMethods = new Set(validMutationMethodsArr);
    const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
    const validRequestMethods = new Set(validRequestMethodsArr);
    const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    const redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
    const IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    const IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    const IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    };
    const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const defaultMapRouteProperties = (route) => ({
      hasErrorBoundary: Boolean(route.hasErrorBoundary)
    });
    const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
    function createRouter(init) {
      const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
      const isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
      const isServer = !isBrowser;
      invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
      let mapRouteProperties2;
      if (init.mapRouteProperties) {
        mapRouteProperties2 = init.mapRouteProperties;
      } else if (init.detectErrorBoundary) {
        let detectErrorBoundary = init.detectErrorBoundary;
        mapRouteProperties2 = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else {
        mapRouteProperties2 = defaultMapRouteProperties;
      }
      let manifest = {};
      let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);
      let inFlightDataRoutes;
      let basename = init.basename || "/";
      let dataStrategyImpl = init.dataStrategy || defaultDataStrategy;
      let patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation;
      let future = _extends$2({
        v7_fetcherPersist: false,
        v7_normalizeFormMethod: false,
        v7_partialHydration: false,
        v7_prependBasename: false,
        v7_relativeSplatPath: false,
        v7_skipActionErrorRevalidation: false
      }, init.future);
      let unlistenHistory = null;
      let subscribers = /* @__PURE__ */ new Set();
      let savedScrollPositions = null;
      let getScrollRestorationKey = null;
      let getScrollPosition = null;
      let initialScrollRestored = init.hydrationData != null;
      let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
      let initialMatchesIsFOW = false;
      let initialErrors = null;
      if (initialMatches == null && !patchRoutesOnNavigationImpl) {
        let error2 = getInternalRouterError(404, {
          pathname: init.history.location.pathname
        });
        let {
          matches,
          route
        } = getShortCircuitMatches(dataRoutes);
        initialMatches = matches;
        initialErrors = {
          [route.id]: error2
        };
      }
      if (initialMatches && !init.hydrationData) {
        let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);
        if (fogOfWar.active) {
          initialMatches = null;
        }
      }
      let initialized;
      if (!initialMatches) {
        initialized = false;
        initialMatches = [];
        if (future.v7_partialHydration) {
          let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);
          if (fogOfWar.active && fogOfWar.matches) {
            initialMatchesIsFOW = true;
            initialMatches = fogOfWar.matches;
          }
        }
      } else if (initialMatches.some((m) => m.route.lazy)) {
        initialized = false;
      } else if (!initialMatches.some((m) => m.route.loader)) {
        initialized = true;
      } else if (future.v7_partialHydration) {
        let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
        let errors = init.hydrationData ? init.hydrationData.errors : null;
        if (errors) {
          let idx = initialMatches.findIndex((m) => errors[m.route.id] !== void 0);
          initialized = initialMatches.slice(0, idx + 1).every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
        } else {
          initialized = initialMatches.every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
        }
      } else {
        initialized = init.hydrationData != null;
      }
      let router;
      let state = {
        historyAction: init.history.action,
        location: init.history.location,
        matches: initialMatches,
        initialized,
        navigation: IDLE_NAVIGATION,
        // Don't restore on initial updateState() if we were SSR'd
        restoreScrollPosition: init.hydrationData != null ? false : null,
        preventScrollReset: false,
        revalidation: "idle",
        loaderData: init.hydrationData && init.hydrationData.loaderData || {},
        actionData: init.hydrationData && init.hydrationData.actionData || null,
        errors: init.hydrationData && init.hydrationData.errors || initialErrors,
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      };
      let pendingAction = Action$1.Pop;
      let pendingPreventScrollReset = false;
      let pendingNavigationController;
      let pendingViewTransitionEnabled = false;
      let appliedViewTransitions = /* @__PURE__ */ new Map();
      let removePageHideEventListener = null;
      let isUninterruptedRevalidation = false;
      let isRevalidationRequired = false;
      let cancelledDeferredRoutes = [];
      let cancelledFetcherLoads = /* @__PURE__ */ new Set();
      let fetchControllers = /* @__PURE__ */ new Map();
      let incrementingLoadId = 0;
      let pendingNavigationLoadId = -1;
      let fetchReloadIds = /* @__PURE__ */ new Map();
      let fetchRedirectIds = /* @__PURE__ */ new Set();
      let fetchLoadMatches = /* @__PURE__ */ new Map();
      let activeFetchers = /* @__PURE__ */ new Map();
      let deletedFetchers = /* @__PURE__ */ new Set();
      let activeDeferreds = /* @__PURE__ */ new Map();
      let blockerFunctions = /* @__PURE__ */ new Map();
      let unblockBlockerHistoryUpdate = void 0;
      function initialize2() {
        unlistenHistory = init.history.listen((_ref) => {
          let {
            action: historyAction,
            location,
            delta
          } = _ref;
          if (unblockBlockerHistoryUpdate) {
            unblockBlockerHistoryUpdate();
            unblockBlockerHistoryUpdate = void 0;
            return;
          }
          warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location,
            historyAction
          });
          if (blockerKey && delta != null) {
            let nextHistoryUpdatePromise = new Promise((resolve) => {
              unblockBlockerHistoryUpdate = resolve;
            });
            init.history.go(delta * -1);
            updateBlocker(blockerKey, {
              state: "blocked",
              location,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location
                });
                nextHistoryUpdatePromise.then(() => init.history.go(delta));
              },
              reset() {
                let blockers = new Map(state.blockers);
                blockers.set(blockerKey, IDLE_BLOCKER);
                updateState({
                  blockers
                });
              }
            });
            return;
          }
          return startNavigation(historyAction, location);
        });
        if (isBrowser) {
          restoreAppliedTransitions(routerWindow, appliedViewTransitions);
          let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
          routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
          removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
        }
        if (!state.initialized) {
          startNavigation(Action$1.Pop, state.location, {
            initialHydration: true
          });
        }
        return router;
      }
      function dispose() {
        if (unlistenHistory) {
          unlistenHistory();
        }
        if (removePageHideEventListener) {
          removePageHideEventListener();
        }
        subscribers.clear();
        pendingNavigationController && pendingNavigationController.abort();
        state.fetchers.forEach((_, key) => deleteFetcher(key));
        state.blockers.forEach((_, key) => deleteBlocker(key));
      }
      function subscribe(fn) {
        subscribers.add(fn);
        return () => subscribers.delete(fn);
      }
      function updateState(newState, opts) {
        if (opts === void 0) {
          opts = {};
        }
        state = _extends$2({}, state, newState);
        let completedFetchers = [];
        let deletedFetchersKeys = [];
        if (future.v7_fetcherPersist) {
          state.fetchers.forEach((fetcher, key) => {
            if (fetcher.state === "idle") {
              if (deletedFetchers.has(key)) {
                deletedFetchersKeys.push(key);
              } else {
                completedFetchers.push(key);
              }
            }
          });
        }
        deletedFetchers.forEach((key) => {
          if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
            deletedFetchersKeys.push(key);
          }
        });
        [...subscribers].forEach((subscriber) => subscriber(state, {
          deletedFetchers: deletedFetchersKeys,
          viewTransitionOpts: opts.viewTransitionOpts,
          flushSync: opts.flushSync === true
        }));
        if (future.v7_fetcherPersist) {
          completedFetchers.forEach((key) => state.fetchers.delete(key));
          deletedFetchersKeys.forEach((key) => deleteFetcher(key));
        } else {
          deletedFetchersKeys.forEach((key) => deletedFetchers.delete(key));
        }
      }
      function completeNavigation(location, newState, _temp) {
        var _location$state, _location$state2;
        let {
          flushSync
        } = _temp === void 0 ? {} : _temp;
        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
        let actionData;
        if (newState.actionData) {
          if (Object.keys(newState.actionData).length > 0) {
            actionData = newState.actionData;
          } else {
            actionData = null;
          }
        } else if (isActionReload) {
          actionData = state.actionData;
        } else {
          actionData = null;
        }
        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
        let blockers = state.blockers;
        if (blockers.size > 0) {
          blockers = new Map(blockers);
          blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
        }
        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
        if (inFlightDataRoutes) {
          dataRoutes = inFlightDataRoutes;
          inFlightDataRoutes = void 0;
        }
        if (isUninterruptedRevalidation) ;
        else if (pendingAction === Action$1.Pop) ;
        else if (pendingAction === Action$1.Push) {
          init.history.push(location, location.state);
        } else if (pendingAction === Action$1.Replace) {
          init.history.replace(location, location.state);
        }
        let viewTransitionOpts;
        if (pendingAction === Action$1.Pop) {
          let priorPaths = appliedViewTransitions.get(state.location.pathname);
          if (priorPaths && priorPaths.has(location.pathname)) {
            viewTransitionOpts = {
              currentLocation: state.location,
              nextLocation: location
            };
          } else if (appliedViewTransitions.has(location.pathname)) {
            viewTransitionOpts = {
              currentLocation: location,
              nextLocation: state.location
            };
          }
        } else if (pendingViewTransitionEnabled) {
          let toPaths = appliedViewTransitions.get(state.location.pathname);
          if (toPaths) {
            toPaths.add(location.pathname);
          } else {
            toPaths = /* @__PURE__ */ new Set([location.pathname]);
            appliedViewTransitions.set(state.location.pathname, toPaths);
          }
          viewTransitionOpts = {
            currentLocation: state.location,
            nextLocation: location
          };
        }
        updateState(_extends$2({}, newState, {
          actionData,
          loaderData,
          historyAction: pendingAction,
          location,
          initialized: true,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
          preventScrollReset,
          blockers
        }), {
          viewTransitionOpts,
          flushSync: flushSync === true
        });
        pendingAction = Action$1.Pop;
        pendingPreventScrollReset = false;
        pendingViewTransitionEnabled = false;
        isUninterruptedRevalidation = false;
        isRevalidationRequired = false;
        cancelledDeferredRoutes = [];
      }
      async function navigate(to, opts) {
        if (typeof to === "number") {
          init.history.go(to);
          return;
        }
        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
        let {
          path,
          submission,
          error: error2
        } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
        let currentLocation = state.location;
        let nextLocation = createLocation(state.location, path, opts && opts.state);
        nextLocation = _extends$2({}, nextLocation, init.history.encodeLocation(nextLocation));
        let userReplace = opts && opts.replace != null ? opts.replace : void 0;
        let historyAction = Action$1.Push;
        if (userReplace === true) {
          historyAction = Action$1.Replace;
        } else if (userReplace === false) ;
        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
          historyAction = Action$1.Replace;
        }
        let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
        let flushSync = (opts && opts.flushSync) === true;
        let blockerKey = shouldBlockNavigation({
          currentLocation,
          nextLocation,
          historyAction
        });
        if (blockerKey) {
          updateBlocker(blockerKey, {
            state: "blocked",
            location: nextLocation,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: nextLocation
              });
              navigate(to, opts);
            },
            reset() {
              let blockers = new Map(state.blockers);
              blockers.set(blockerKey, IDLE_BLOCKER);
              updateState({
                blockers
              });
            }
          });
          return;
        }
        return await startNavigation(historyAction, nextLocation, {
          submission,
          // Send through the formData serialization error if we have one so we can
          // render at the right error boundary after we match routes
          pendingError: error2,
          preventScrollReset,
          replace: opts && opts.replace,
          enableViewTransition: opts && opts.viewTransition,
          flushSync
        });
      }
      function revalidate() {
        interruptActiveLoads();
        updateState({
          revalidation: "loading"
        });
        if (state.navigation.state === "submitting") {
          return;
        }
        if (state.navigation.state === "idle") {
          startNavigation(state.historyAction, state.location, {
            startUninterruptedRevalidation: true
          });
          return;
        }
        startNavigation(pendingAction || state.historyAction, state.navigation.location, {
          overrideNavigation: state.navigation,
          // Proxy through any rending view transition
          enableViewTransition: pendingViewTransitionEnabled === true
        });
      }
      async function startNavigation(historyAction, location, opts) {
        pendingNavigationController && pendingNavigationController.abort();
        pendingNavigationController = null;
        pendingAction = historyAction;
        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
        saveScrollPosition(state.location, state.matches);
        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let loadingNavigation = opts && opts.overrideNavigation;
        let matches = opts != null && opts.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
          // `matchRoutes()` has already been called if we're in here via `router.initialize()`
          state.matches
        ) : matchRoutes(routesToUse, location, basename);
        let flushSync = (opts && opts.flushSync) === true;
        if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
          completeNavigation(location, {
            matches
          }, {
            flushSync
          });
          return;
        }
        let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);
        if (fogOfWar.active && fogOfWar.matches) {
          matches = fogOfWar.matches;
        }
        if (!matches) {
          let {
            error: error2,
            notFoundMatches,
            route
          } = handleNavigational404(location.pathname);
          completeNavigation(location, {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error2
            }
          }, {
            flushSync
          });
          return;
        }
        pendingNavigationController = new AbortController();
        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
        let pendingActionResult;
        if (opts && opts.pendingError) {
          pendingActionResult = [findNearestBoundary(matches).route.id, {
            type: ResultType.error,
            error: opts.pendingError
          }];
        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
          let actionResult = await handleAction(request, location, opts.submission, matches, fogOfWar.active, {
            replace: opts.replace,
            flushSync
          });
          if (actionResult.shortCircuited) {
            return;
          }
          if (actionResult.pendingActionResult) {
            let [routeId, result] = actionResult.pendingActionResult;
            if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
              pendingNavigationController = null;
              completeNavigation(location, {
                matches: actionResult.matches,
                loaderData: {},
                errors: {
                  [routeId]: result.error
                }
              });
              return;
            }
          }
          matches = actionResult.matches || matches;
          pendingActionResult = actionResult.pendingActionResult;
          loadingNavigation = getLoadingNavigation(location, opts.submission);
          flushSync = false;
          fogOfWar.active = false;
          request = createClientSideRequest(init.history, request.url, request.signal);
        }
        let {
          shortCircuited,
          matches: updatedMatches,
          loaderData,
          errors
        } = await handleLoaders(request, location, matches, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);
        if (shortCircuited) {
          return;
        }
        pendingNavigationController = null;
        completeNavigation(location, _extends$2({
          matches: updatedMatches || matches
        }, getActionDataForCommit(pendingActionResult), {
          loaderData,
          errors
        }));
      }
      async function handleAction(request, location, submission, matches, isFogOfWar, opts) {
        if (opts === void 0) {
          opts = {};
        }
        interruptActiveLoads();
        let navigation = getSubmittingNavigation(location, submission);
        updateState({
          navigation
        }, {
          flushSync: opts.flushSync === true
        });
        if (isFogOfWar) {
          let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);
          if (discoverResult.type === "aborted") {
            return {
              shortCircuited: true
            };
          } else if (discoverResult.type === "error") {
            let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
            return {
              matches: discoverResult.partialMatches,
              pendingActionResult: [boundaryId, {
                type: ResultType.error,
                error: discoverResult.error
              }]
            };
          } else if (!discoverResult.matches) {
            let {
              notFoundMatches,
              error: error2,
              route
            } = handleNavigational404(location.pathname);
            return {
              matches: notFoundMatches,
              pendingActionResult: [route.id, {
                type: ResultType.error,
                error: error2
              }]
            };
          } else {
            matches = discoverResult.matches;
          }
        }
        let result;
        let actionMatch = getTargetMatch(matches, location);
        if (!actionMatch.route.action && !actionMatch.route.lazy) {
          result = {
            type: ResultType.error,
            error: getInternalRouterError(405, {
              method: request.method,
              pathname: location.pathname,
              routeId: actionMatch.route.id
            })
          };
        } else {
          let results = await callDataStrategy("action", state, request, [actionMatch], matches, null);
          result = results[actionMatch.route.id];
          if (request.signal.aborted) {
            return {
              shortCircuited: true
            };
          }
        }
        if (isRedirectResult(result)) {
          let replace;
          if (opts && opts.replace != null) {
            replace = opts.replace;
          } else {
            let location2 = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request.url), basename);
            replace = location2 === state.location.pathname + state.location.search;
          }
          await startRedirectNavigation(request, result, true, {
            submission,
            replace
          });
          return {
            shortCircuited: true
          };
        }
        if (isDeferredResult(result)) {
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
          if ((opts && opts.replace) !== true) {
            pendingAction = Action$1.Push;
          }
          return {
            matches,
            pendingActionResult: [boundaryMatch.route.id, result]
          };
        }
        return {
          matches,
          pendingActionResult: [actionMatch.route.id, result]
        };
      }
      async function handleLoaders(request, location, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionResult) {
        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
        let shouldUpdateNavigationState = !isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration);
        if (isFogOfWar) {
          if (shouldUpdateNavigationState) {
            let actionData = getUpdatedActionData(pendingActionResult);
            updateState(_extends$2({
              navigation: loadingNavigation
            }, actionData !== void 0 ? {
              actionData
            } : {}), {
              flushSync
            });
          }
          let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);
          if (discoverResult.type === "aborted") {
            return {
              shortCircuited: true
            };
          } else if (discoverResult.type === "error") {
            let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
            return {
              matches: discoverResult.partialMatches,
              loaderData: {},
              errors: {
                [boundaryId]: discoverResult.error
              }
            };
          } else if (!discoverResult.matches) {
            let {
              error: error2,
              notFoundMatches,
              route
            } = handleNavigational404(location.pathname);
            return {
              matches: notFoundMatches,
              loaderData: {},
              errors: {
                [route.id]: error2
              }
            };
          } else {
            matches = discoverResult.matches;
          }
        }
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);
        cancelActiveDeferreds((routeId) => !(matches && matches.some((m) => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId));
        pendingNavigationLoadId = ++incrementingLoadId;
        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
          let updatedFetchers2 = markFetchRedirectsDone();
          completeNavigation(location, _extends$2({
            matches,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
              [pendingActionResult[0]]: pendingActionResult[1].error
            } : null
          }, getActionDataForCommit(pendingActionResult), updatedFetchers2 ? {
            fetchers: new Map(state.fetchers)
          } : {}), {
            flushSync
          });
          return {
            shortCircuited: true
          };
        }
        if (shouldUpdateNavigationState) {
          let updates = {};
          if (!isFogOfWar) {
            updates.navigation = loadingNavigation;
            let actionData = getUpdatedActionData(pendingActionResult);
            if (actionData !== void 0) {
              updates.actionData = actionData;
            }
          }
          if (revalidatingFetchers.length > 0) {
            updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
          }
          updateState(updates, {
            flushSync
          });
        }
        revalidatingFetchers.forEach((rf) => {
          abortFetcher(rf.key);
          if (rf.controller) {
            fetchControllers.set(rf.key, rf.controller);
          }
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
        if (pendingNavigationController) {
          pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        }
        let {
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, request);
        if (request.signal.aborted) {
          return {
            shortCircuited: true
          };
        }
        if (pendingNavigationController) {
          pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
        }
        revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
        let redirect = findRedirect(loaderResults);
        if (redirect) {
          await startRedirectNavigation(request, redirect.result, true, {
            replace
          });
          return {
            shortCircuited: true
          };
        }
        redirect = findRedirect(fetcherResults);
        if (redirect) {
          fetchRedirectIds.add(redirect.key);
          await startRedirectNavigation(request, redirect.result, true, {
            replace
          });
          return {
            shortCircuited: true
          };
        }
        let {
          loaderData,
          errors
        } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);
        activeDeferreds.forEach((deferredData, routeId) => {
          deferredData.subscribe((aborted2) => {
            if (aborted2 || deferredData.done) {
              activeDeferreds.delete(routeId);
            }
          });
        });
        if (future.v7_partialHydration && initialHydration && state.errors) {
          errors = _extends$2({}, state.errors, errors);
        }
        let updatedFetchers = markFetchRedirectsDone();
        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
        return _extends$2({
          matches,
          loaderData,
          errors
        }, shouldUpdateFetchers ? {
          fetchers: new Map(state.fetchers)
        } : {});
      }
      function getUpdatedActionData(pendingActionResult) {
        if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
          return {
            [pendingActionResult[0]]: pendingActionResult[1].data
          };
        } else if (state.actionData) {
          if (Object.keys(state.actionData).length === 0) {
            return null;
          } else {
            return state.actionData;
          }
        }
      }
      function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
        revalidatingFetchers.forEach((rf) => {
          let fetcher = state.fetchers.get(rf.key);
          let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
          state.fetchers.set(rf.key, revalidatingFetcher);
        });
        return new Map(state.fetchers);
      }
      function fetch2(key, routeId, href, opts) {
        if (isServer) {
          throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        }
        abortFetcher(key);
        let flushSync = (opts && opts.flushSync) === true;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
        let matches = matchRoutes(routesToUse, normalizedPath, basename);
        let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
        if (fogOfWar.active && fogOfWar.matches) {
          matches = fogOfWar.matches;
        }
        if (!matches) {
          setFetcherError(key, routeId, getInternalRouterError(404, {
            pathname: normalizedPath
          }), {
            flushSync
          });
          return;
        }
        let {
          path,
          submission,
          error: error2
        } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
        if (error2) {
          setFetcherError(key, routeId, error2, {
            flushSync
          });
          return;
        }
        let match = getTargetMatch(matches, path);
        let preventScrollReset = (opts && opts.preventScrollReset) === true;
        if (submission && isMutationMethod(submission.formMethod)) {
          handleFetcherAction(key, routeId, path, match, matches, fogOfWar.active, flushSync, preventScrollReset, submission);
          return;
        }
        fetchLoadMatches.set(key, {
          routeId,
          path
        });
        handleFetcherLoader(key, routeId, path, match, matches, fogOfWar.active, flushSync, preventScrollReset, submission);
      }
      async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {
        interruptActiveLoads();
        fetchLoadMatches.delete(key);
        function detectAndHandle405Error(m) {
          if (!m.route.action && !m.route.lazy) {
            let error2 = getInternalRouterError(405, {
              method: submission.formMethod,
              pathname: path,
              routeId
            });
            setFetcherError(key, routeId, error2, {
              flushSync
            });
            return true;
          }
          return false;
        }
        if (!isFogOfWar && detectAndHandle405Error(match)) {
          return;
        }
        let existingFetcher = state.fetchers.get(key);
        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
          flushSync
        });
        let abortController = new AbortController();
        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
        if (isFogOfWar) {
          let discoverResult = await discoverRoutes(requestMatches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);
          if (discoverResult.type === "aborted") {
            return;
          } else if (discoverResult.type === "error") {
            setFetcherError(key, routeId, discoverResult.error, {
              flushSync
            });
            return;
          } else if (!discoverResult.matches) {
            setFetcherError(key, routeId, getInternalRouterError(404, {
              pathname: path
            }), {
              flushSync
            });
            return;
          } else {
            requestMatches = discoverResult.matches;
            match = getTargetMatch(requestMatches, path);
            if (detectAndHandle405Error(match)) {
              return;
            }
          }
        }
        fetchControllers.set(key, abortController);
        let originatingLoadId = incrementingLoadId;
        let actionResults = await callDataStrategy("action", state, fetchRequest, [match], requestMatches, key);
        let actionResult = actionResults[match.route.id];
        if (fetchRequest.signal.aborted) {
          if (fetchControllers.get(key) === abortController) {
            fetchControllers.delete(key);
          }
          return;
        }
        if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
          if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          }
        } else {
          if (isRedirectResult(actionResult)) {
            fetchControllers.delete(key);
            if (pendingNavigationLoadId > originatingLoadId) {
              updateFetcherState(key, getDoneFetcher(void 0));
              return;
            } else {
              fetchRedirectIds.add(key);
              updateFetcherState(key, getLoadingFetcher(submission));
              return startRedirectNavigation(fetchRequest, actionResult, false, {
                fetcherSubmission: submission,
                preventScrollReset
              });
            }
          }
          if (isErrorResult(actionResult)) {
            setFetcherError(key, routeId, actionResult.error);
            return;
          }
        }
        if (isDeferredResult(actionResult)) {
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        }
        let nextLocation = state.navigation.location || state.location;
        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
        invariant(matches, "Didn't find any matches after fetcher action");
        let loadId = ++incrementingLoadId;
        fetchReloadIds.set(key, loadId);
        let loadFetcher = getLoadingFetcher(submission, actionResult.data);
        state.fetchers.set(key, loadFetcher);
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);
        revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
          let staleKey = rf.key;
          let existingFetcher2 = state.fetchers.get(staleKey);
          let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
          state.fetchers.set(staleKey, revalidatingFetcher);
          abortFetcher(staleKey);
          if (rf.controller) {
            fetchControllers.set(staleKey, rf.controller);
          }
        });
        updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
        abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
        if (abortController.signal.aborted) {
          return;
        }
        abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
        fetchReloadIds.delete(key);
        fetchControllers.delete(key);
        revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
        let redirect = findRedirect(loaderResults);
        if (redirect) {
          return startRedirectNavigation(revalidationRequest, redirect.result, false, {
            preventScrollReset
          });
        }
        redirect = findRedirect(fetcherResults);
        if (redirect) {
          fetchRedirectIds.add(redirect.key);
          return startRedirectNavigation(revalidationRequest, redirect.result, false, {
            preventScrollReset
          });
        }
        let {
          loaderData,
          errors
        } = processLoaderData(state, matches, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
        if (state.fetchers.has(key)) {
          let doneFetcher = getDoneFetcher(actionResult.data);
          state.fetchers.set(key, doneFetcher);
        }
        abortStaleFetchLoads(loadId);
        if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
          invariant(pendingAction, "Expected pending action");
          pendingNavigationController && pendingNavigationController.abort();
          completeNavigation(state.navigation.location, {
            matches,
            loaderData,
            errors,
            fetchers: new Map(state.fetchers)
          });
        } else {
          updateState({
            errors,
            loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
            fetchers: new Map(state.fetchers)
          });
          isRevalidationRequired = false;
        }
      }
      async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, preventScrollReset, submission) {
        let existingFetcher = state.fetchers.get(key);
        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
          flushSync
        });
        let abortController = new AbortController();
        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
        if (isFogOfWar) {
          let discoverResult = await discoverRoutes(matches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);
          if (discoverResult.type === "aborted") {
            return;
          } else if (discoverResult.type === "error") {
            setFetcherError(key, routeId, discoverResult.error, {
              flushSync
            });
            return;
          } else if (!discoverResult.matches) {
            setFetcherError(key, routeId, getInternalRouterError(404, {
              pathname: path
            }), {
              flushSync
            });
            return;
          } else {
            matches = discoverResult.matches;
            match = getTargetMatch(matches, path);
          }
        }
        fetchControllers.set(key, abortController);
        let originatingLoadId = incrementingLoadId;
        let results = await callDataStrategy("loader", state, fetchRequest, [match], matches, key);
        let result = results[match.route.id];
        if (isDeferredResult(result)) {
          result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
        }
        if (fetchControllers.get(key) === abortController) {
          fetchControllers.delete(key);
        }
        if (fetchRequest.signal.aborted) {
          return;
        }
        if (deletedFetchers.has(key)) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        }
        if (isRedirectResult(result)) {
          if (pendingNavigationLoadId > originatingLoadId) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          } else {
            fetchRedirectIds.add(key);
            await startRedirectNavigation(fetchRequest, result, false, {
              preventScrollReset
            });
            return;
          }
        }
        if (isErrorResult(result)) {
          setFetcherError(key, routeId, result.error);
          return;
        }
        invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
        updateFetcherState(key, getDoneFetcher(result.data));
      }
      async function startRedirectNavigation(request, redirect, isNavigation, _temp2) {
        let {
          submission,
          fetcherSubmission,
          preventScrollReset,
          replace
        } = _temp2 === void 0 ? {} : _temp2;
        if (redirect.response.headers.has("X-Remix-Revalidate")) {
          isRevalidationRequired = true;
        }
        let location = redirect.response.headers.get("Location");
        invariant(location, "Expected a Location header on the redirect Response");
        location = normalizeRedirectLocation(location, new URL(request.url), basename);
        let redirectLocation = createLocation(state.location, location, {
          _isRedirect: true
        });
        if (isBrowser) {
          let isDocumentReload = false;
          if (redirect.response.headers.has("X-Remix-Reload-Document")) {
            isDocumentReload = true;
          } else if (ABSOLUTE_URL_REGEX.test(location)) {
            const url2 = init.history.createURL(location);
            isDocumentReload = // Hard reload if it's an absolute URL to a new origin
            url2.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
            stripBasename(url2.pathname, basename) == null;
          }
          if (isDocumentReload) {
            if (replace) {
              routerWindow.location.replace(location);
            } else {
              routerWindow.location.assign(location);
            }
            return;
          }
        }
        pendingNavigationController = null;
        let redirectHistoryAction = replace === true || redirect.response.headers.has("X-Remix-Replace") ? Action$1.Replace : Action$1.Push;
        let {
          formMethod,
          formAction,
          formEncType
        } = state.navigation;
        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
          submission = getSubmissionFromNavigation(state.navigation);
        }
        let activeSubmission = submission || fetcherSubmission;
        if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
          await startNavigation(redirectHistoryAction, redirectLocation, {
            submission: _extends$2({}, activeSubmission, {
              formAction: location
            }),
            // Preserve these flags across redirects
            preventScrollReset: preventScrollReset || pendingPreventScrollReset,
            enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
          });
        } else {
          let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
          await startNavigation(redirectHistoryAction, redirectLocation, {
            overrideNavigation,
            // Send fetcher submissions through for shouldRevalidate
            fetcherSubmission,
            // Preserve these flags across redirects
            preventScrollReset: preventScrollReset || pendingPreventScrollReset,
            enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
          });
        }
      }
      async function callDataStrategy(type, state2, request, matchesToLoad, matches, fetcherKey) {
        let results;
        let dataResults = {};
        try {
          results = await callDataStrategyImpl(dataStrategyImpl, type, state2, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2);
        } catch (e) {
          matchesToLoad.forEach((m) => {
            dataResults[m.route.id] = {
              type: ResultType.error,
              error: e
            };
          });
          return dataResults;
        }
        for (let [routeId, result] of Object.entries(results)) {
          if (isRedirectDataStrategyResultResult(result)) {
            let response = result.result;
            dataResults[routeId] = {
              type: ResultType.redirect,
              response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, future.v7_relativeSplatPath)
            };
          } else {
            dataResults[routeId] = await convertDataStrategyResultToDataResult(result);
          }
        }
        return dataResults;
      }
      async function callLoadersAndMaybeResolveData(state2, matches, matchesToLoad, fetchersToLoad, request) {
        let currentMatches = state2.matches;
        let loaderResultsPromise = callDataStrategy("loader", state2, request, matchesToLoad, matches, null);
        let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async (f) => {
          if (f.matches && f.match && f.controller) {
            let results = await callDataStrategy("loader", state2, createClientSideRequest(init.history, f.path, f.controller.signal), [f.match], f.matches, f.key);
            let result = results[f.match.route.id];
            return {
              [f.key]: result
            };
          } else {
            return Promise.resolve({
              [f.key]: {
                type: ResultType.error,
                error: getInternalRouterError(404, {
                  pathname: f.path
                })
              }
            });
          }
        }));
        let loaderResults = await loaderResultsPromise;
        let fetcherResults = (await fetcherResultsPromise).reduce((acc, r2) => Object.assign(acc, r2), {});
        await Promise.all([resolveNavigationDeferredResults(matches, loaderResults, request.signal, currentMatches, state2.loaderData), resolveFetcherDeferredResults(matches, fetcherResults, fetchersToLoad)]);
        return {
          loaderResults,
          fetcherResults
        };
      }
      function interruptActiveLoads() {
        isRevalidationRequired = true;
        cancelledDeferredRoutes.push(...cancelActiveDeferreds());
        fetchLoadMatches.forEach((_, key) => {
          if (fetchControllers.has(key)) {
            cancelledFetcherLoads.add(key);
          }
          abortFetcher(key);
        });
      }
      function updateFetcherState(key, fetcher, opts) {
        if (opts === void 0) {
          opts = {};
        }
        state.fetchers.set(key, fetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        }, {
          flushSync: (opts && opts.flushSync) === true
        });
      }
      function setFetcherError(key, routeId, error2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        let boundaryMatch = findNearestBoundary(state.matches, routeId);
        deleteFetcher(key);
        updateState({
          errors: {
            [boundaryMatch.route.id]: error2
          },
          fetchers: new Map(state.fetchers)
        }, {
          flushSync: (opts && opts.flushSync) === true
        });
      }
      function getFetcher(key) {
        activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
        if (deletedFetchers.has(key)) {
          deletedFetchers.delete(key);
        }
        return state.fetchers.get(key) || IDLE_FETCHER;
      }
      function deleteFetcher(key) {
        let fetcher = state.fetchers.get(key);
        if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
          abortFetcher(key);
        }
        fetchLoadMatches.delete(key);
        fetchReloadIds.delete(key);
        fetchRedirectIds.delete(key);
        if (future.v7_fetcherPersist) {
          deletedFetchers.delete(key);
        }
        cancelledFetcherLoads.delete(key);
        state.fetchers.delete(key);
      }
      function deleteFetcherAndUpdateState(key) {
        let count2 = (activeFetchers.get(key) || 0) - 1;
        if (count2 <= 0) {
          activeFetchers.delete(key);
          deletedFetchers.add(key);
          if (!future.v7_fetcherPersist) {
            deleteFetcher(key);
          }
        } else {
          activeFetchers.set(key, count2);
        }
        updateState({
          fetchers: new Map(state.fetchers)
        });
      }
      function abortFetcher(key) {
        let controller = fetchControllers.get(key);
        if (controller) {
          controller.abort();
          fetchControllers.delete(key);
        }
      }
      function markFetchersDone(keys) {
        for (let key of keys) {
          let fetcher = getFetcher(key);
          let doneFetcher = getDoneFetcher(fetcher.data);
          state.fetchers.set(key, doneFetcher);
        }
      }
      function markFetchRedirectsDone() {
        let doneKeys = [];
        let updatedFetchers = false;
        for (let key of fetchRedirectIds) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, "Expected fetcher: " + key);
          if (fetcher.state === "loading") {
            fetchRedirectIds.delete(key);
            doneKeys.push(key);
            updatedFetchers = true;
          }
        }
        markFetchersDone(doneKeys);
        return updatedFetchers;
      }
      function abortStaleFetchLoads(landedId) {
        let yeetedKeys = [];
        for (let [key, id2] of fetchReloadIds) {
          if (id2 < landedId) {
            let fetcher = state.fetchers.get(key);
            invariant(fetcher, "Expected fetcher: " + key);
            if (fetcher.state === "loading") {
              abortFetcher(key);
              fetchReloadIds.delete(key);
              yeetedKeys.push(key);
            }
          }
        }
        markFetchersDone(yeetedKeys);
        return yeetedKeys.length > 0;
      }
      function getBlocker(key, fn) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        if (blockerFunctions.get(key) !== fn) {
          blockerFunctions.set(key, fn);
        }
        return blocker;
      }
      function deleteBlocker(key) {
        state.blockers.delete(key);
        blockerFunctions.delete(key);
      }
      function updateBlocker(key, newBlocker) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
        let blockers = new Map(state.blockers);
        blockers.set(key, newBlocker);
        updateState({
          blockers
        });
      }
      function shouldBlockNavigation(_ref2) {
        let {
          currentLocation,
          nextLocation,
          historyAction
        } = _ref2;
        if (blockerFunctions.size === 0) {
          return;
        }
        if (blockerFunctions.size > 1) {
          warning(false, "A router only supports one blocker at a time");
        }
        let entries = Array.from(blockerFunctions.entries());
        let [blockerKey, blockerFunction] = entries[entries.length - 1];
        let blocker = state.blockers.get(blockerKey);
        if (blocker && blocker.state === "proceeding") {
          return;
        }
        if (blockerFunction({
          currentLocation,
          nextLocation,
          historyAction
        })) {
          return blockerKey;
        }
      }
      function handleNavigational404(pathname) {
        let error2 = getInternalRouterError(404, {
          pathname
        });
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let {
          matches,
          route
        } = getShortCircuitMatches(routesToUse);
        cancelActiveDeferreds();
        return {
          notFoundMatches: matches,
          route,
          error: error2
        };
      }
      function cancelActiveDeferreds(predicate) {
        let cancelledRouteIds = [];
        activeDeferreds.forEach((dfd, routeId) => {
          if (!predicate || predicate(routeId)) {
            dfd.cancel();
            cancelledRouteIds.push(routeId);
            activeDeferreds.delete(routeId);
          }
        });
        return cancelledRouteIds;
      }
      function enableScrollRestoration(positions, getPosition, getKey) {
        savedScrollPositions = positions;
        getScrollPosition = getPosition;
        getScrollRestorationKey = getKey || null;
        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
          initialScrollRestored = true;
          let y = getSavedScrollPosition(state.location, state.matches);
          if (y != null) {
            updateState({
              restoreScrollPosition: y
            });
          }
        }
        return () => {
          savedScrollPositions = null;
          getScrollPosition = null;
          getScrollRestorationKey = null;
        };
      }
      function getScrollKey(location, matches) {
        if (getScrollRestorationKey) {
          let key = getScrollRestorationKey(location, matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData)));
          return key || location.key;
        }
        return location.key;
      }
      function saveScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollPosition) {
          let key = getScrollKey(location, matches);
          savedScrollPositions[key] = getScrollPosition();
        }
      }
      function getSavedScrollPosition(location, matches) {
        if (savedScrollPositions) {
          let key = getScrollKey(location, matches);
          let y = savedScrollPositions[key];
          if (typeof y === "number") {
            return y;
          }
        }
        return null;
      }
      function checkFogOfWar(matches, routesToUse, pathname) {
        if (patchRoutesOnNavigationImpl) {
          if (!matches) {
            let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
            return {
              active: true,
              matches: fogMatches || []
            };
          } else {
            if (Object.keys(matches[0].params).length > 0) {
              let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
              return {
                active: true,
                matches: partialMatches
              };
            }
          }
        }
        return {
          active: false,
          matches: null
        };
      }
      async function discoverRoutes(matches, pathname, signal, fetcherKey) {
        if (!patchRoutesOnNavigationImpl) {
          return {
            type: "success",
            matches
          };
        }
        let partialMatches = matches;
        while (true) {
          let isNonHMR = inFlightDataRoutes == null;
          let routesToUse = inFlightDataRoutes || dataRoutes;
          let localManifest = manifest;
          try {
            await patchRoutesOnNavigationImpl({
              signal,
              path: pathname,
              matches: partialMatches,
              fetcherKey,
              patch: (routeId, children) => {
                if (signal.aborted) return;
                patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);
              }
            });
          } catch (e) {
            return {
              type: "error",
              error: e,
              partialMatches
            };
          } finally {
            if (isNonHMR && !signal.aborted) {
              dataRoutes = [...dataRoutes];
            }
          }
          if (signal.aborted) {
            return {
              type: "aborted"
            };
          }
          let newMatches = matchRoutes(routesToUse, pathname, basename);
          if (newMatches) {
            return {
              type: "success",
              matches: newMatches
            };
          }
          let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
          if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i) => m.route.id === newPartialMatches[i].route.id)) {
            return {
              type: "success",
              matches: null
            };
          }
          partialMatches = newPartialMatches;
        }
      }
      function _internalSetRoutes(newRoutes) {
        manifest = {};
        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
      }
      function patchRoutes(routeId, children) {
        let isNonHMR = inFlightDataRoutes == null;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);
        if (isNonHMR) {
          dataRoutes = [...dataRoutes];
          updateState({});
        }
      }
      router = {
        get basename() {
          return basename;
        },
        get future() {
          return future;
        },
        get state() {
          return state;
        },
        get routes() {
          return dataRoutes;
        },
        get window() {
          return routerWindow;
        },
        initialize: initialize2,
        subscribe,
        enableScrollRestoration,
        navigate,
        fetch: fetch2,
        revalidate,
        // Passthrough to history-aware createHref used by useHref so we get proper
        // hash-aware URLs in DOM paths
        createHref: (to) => init.history.createHref(to),
        encodeLocation: (to) => init.history.encodeLocation(to),
        getFetcher,
        deleteFetcher: deleteFetcherAndUpdateState,
        dispose,
        getBlocker,
        deleteBlocker,
        patchRoutes,
        _internalFetchControllers: fetchControllers,
        _internalActiveDeferreds: activeDeferreds,
        // TODO: Remove setRoutes, it's temporary to avoid dealing with
        // updating the tree while validating the update algorithm.
        _internalSetRoutes
      };
      return router;
    }
    function isSubmissionNavigation(opts) {
      return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
    }
    function normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
      let contextualMatches;
      let activeRouteMatch;
      if (fromRouteId) {
        contextualMatches = [];
        for (let match of matches) {
          contextualMatches.push(match);
          if (match.route.id === fromRouteId) {
            activeRouteMatch = match;
            break;
          }
        }
      } else {
        contextualMatches = matches;
        activeRouteMatch = matches[matches.length - 1];
      }
      let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
      if (to == null) {
        path.search = location.search;
        path.hash = location.hash;
      }
      if ((to == null || to === "" || to === ".") && activeRouteMatch) {
        let nakedIndex = hasNakedIndexQuery(path.search);
        if (activeRouteMatch.route.index && !nakedIndex) {
          path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
        } else if (!activeRouteMatch.route.index && nakedIndex) {
          let params = new URLSearchParams(path.search);
          let indexValues = params.getAll("index");
          params.delete("index");
          indexValues.filter((v) => v).forEach((v) => params.append("index", v));
          let qs = params.toString();
          path.search = qs ? "?" + qs : "";
        }
      }
      if (prependBasename && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      return createPath(path);
    }
    function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
      if (!opts || !isSubmissionNavigation(opts)) {
        return {
          path
        };
      }
      if (opts.formMethod && !isValidMethod(opts.formMethod)) {
        return {
          path,
          error: getInternalRouterError(405, {
            method: opts.formMethod
          })
        };
      }
      let getInvalidBodyError = () => ({
        path,
        error: getInternalRouterError(400, {
          type: "invalid-body"
        })
      });
      let rawFormMethod = opts.formMethod || "get";
      let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
      let formAction = stripHashFromPath(path);
      if (opts.body !== void 0) {
        if (opts.formEncType === "text/plain") {
          if (!isMutationMethod(formMethod)) {
            return getInvalidBodyError();
          }
          let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
            // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
            Array.from(opts.body.entries()).reduce((acc, _ref3) => {
              let [name, value] = _ref3;
              return "" + acc + name + "=" + value + "\n";
            }, "")
          ) : String(opts.body);
          return {
            path,
            submission: {
              formMethod,
              formAction,
              formEncType: opts.formEncType,
              formData: void 0,
              json: void 0,
              text
            }
          };
        } else if (opts.formEncType === "application/json") {
          if (!isMutationMethod(formMethod)) {
            return getInvalidBodyError();
          }
          try {
            let json2 = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
            return {
              path,
              submission: {
                formMethod,
                formAction,
                formEncType: opts.formEncType,
                formData: void 0,
                json: json2,
                text: void 0
              }
            };
          } catch (e) {
            return getInvalidBodyError();
          }
        }
      }
      invariant(typeof FormData === "function", "FormData is not available in this environment");
      let searchParams;
      let formData;
      if (opts.formData) {
        searchParams = convertFormDataToSearchParams(opts.formData);
        formData = opts.formData;
      } else if (opts.body instanceof FormData) {
        searchParams = convertFormDataToSearchParams(opts.body);
        formData = opts.body;
      } else if (opts.body instanceof URLSearchParams) {
        searchParams = opts.body;
        formData = convertSearchParamsToFormData(searchParams);
      } else if (opts.body == null) {
        searchParams = new URLSearchParams();
        formData = new FormData();
      } else {
        try {
          searchParams = new URLSearchParams(opts.body);
          formData = convertSearchParamsToFormData(searchParams);
        } catch (e) {
          return getInvalidBodyError();
        }
      }
      let submission = {
        formMethod,
        formAction,
        formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
        formData,
        json: void 0,
        text: void 0
      };
      if (isMutationMethod(submission.formMethod)) {
        return {
          path,
          submission
        };
      }
      let parsedPath = parsePath(path);
      if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
        searchParams.append("index", "");
      }
      parsedPath.search = "?" + searchParams;
      return {
        path: createPath(parsedPath),
        submission
      };
    }
    function getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary) {
      if (includeBoundary === void 0) {
        includeBoundary = false;
      }
      let index2 = matches.findIndex((m) => m.route.id === boundaryId);
      if (index2 >= 0) {
        return matches.slice(0, includeBoundary ? index2 + 1 : index2);
      }
      return matches;
    }
    function getMatchesToLoad(history, state, matches, submission, location, initialHydration, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
      let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
      let currentUrl = history.createURL(state.location);
      let nextUrl = history.createURL(location);
      let boundaryMatches = matches;
      if (initialHydration && state.errors) {
        boundaryMatches = getLoaderMatchesUntilBoundary(matches, Object.keys(state.errors)[0], true);
      } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
        boundaryMatches = getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]);
      }
      let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
      let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;
      let navigationMatches = boundaryMatches.filter((match, index2) => {
        let {
          route
        } = match;
        if (route.lazy) {
          return true;
        }
        if (route.loader == null) {
          return false;
        }
        if (initialHydration) {
          return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
        }
        if (isNewLoader(state.loaderData, state.matches[index2], match) || cancelledDeferredRoutes.some((id2) => id2 === match.route.id)) {
          return true;
        }
        let currentRouteMatch = state.matches[index2];
        let nextRouteMatch = match;
        return shouldRevalidateLoader(match, _extends$2({
          currentUrl,
          currentParams: currentRouteMatch.params,
          nextUrl,
          nextParams: nextRouteMatch.params
        }, submission, {
          actionResult,
          actionStatus,
          defaultShouldRevalidate: shouldSkipRevalidation ? false : (
            // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
            isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
          )
        }));
      });
      let revalidatingFetchers = [];
      fetchLoadMatches.forEach((f, key) => {
        if (initialHydration || !matches.some((m) => m.route.id === f.routeId) || deletedFetchers.has(key)) {
          return;
        }
        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
        if (!fetcherMatches) {
          revalidatingFetchers.push({
            key,
            routeId: f.routeId,
            path: f.path,
            matches: null,
            match: null,
            controller: null
          });
          return;
        }
        let fetcher = state.fetchers.get(key);
        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
        let shouldRevalidate = false;
        if (fetchRedirectIds.has(key)) {
          shouldRevalidate = false;
        } else if (cancelledFetcherLoads.has(key)) {
          cancelledFetcherLoads.delete(key);
          shouldRevalidate = true;
        } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
          shouldRevalidate = isRevalidationRequired;
        } else {
          shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends$2({
            currentUrl,
            currentParams: state.matches[state.matches.length - 1].params,
            nextUrl,
            nextParams: matches[matches.length - 1].params
          }, submission, {
            actionResult,
            actionStatus,
            defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
          }));
        }
        if (shouldRevalidate) {
          revalidatingFetchers.push({
            key,
            routeId: f.routeId,
            path: f.path,
            matches: fetcherMatches,
            match: fetcherMatch,
            controller: new AbortController()
          });
        }
      });
      return [navigationMatches, revalidatingFetchers];
    }
    function shouldLoadRouteOnHydration(route, loaderData, errors) {
      if (route.lazy) {
        return true;
      }
      if (!route.loader) {
        return false;
      }
      let hasData = loaderData != null && loaderData[route.id] !== void 0;
      let hasError = errors != null && errors[route.id] !== void 0;
      if (!hasData && hasError) {
        return false;
      }
      if (typeof route.loader === "function" && route.loader.hydrate === true) {
        return true;
      }
      return !hasData && !hasError;
    }
    function isNewLoader(currentLoaderData, currentMatch, match) {
      let isNew = (
        // [a] -> [a, b]
        !currentMatch || // [a, b] -> [a, c]
        match.route.id !== currentMatch.route.id
      );
      let isMissingData = currentLoaderData[match.route.id] === void 0;
      return isNew || isMissingData;
    }
    function isNewRouteInstance(currentMatch, match) {
      let currentPath = currentMatch.route.path;
      return (
        // param change for this match, /users/123 -> /users/456
        currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
      );
    }
    function shouldRevalidateLoader(loaderMatch, arg) {
      if (loaderMatch.route.shouldRevalidate) {
        let routeChoice = loaderMatch.route.shouldRevalidate(arg);
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return arg.defaultShouldRevalidate;
    }
    function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
      var _childrenToPatch;
      let childrenToPatch;
      if (routeId) {
        let route = manifest[routeId];
        invariant(route, "No route found to patch children into: routeId = " + routeId);
        if (!route.children) {
          route.children = [];
        }
        childrenToPatch = route.children;
      } else {
        childrenToPatch = routesToUse;
      }
      let uniqueChildren = children.filter((newRoute) => !childrenToPatch.some((existingRoute) => isSameRoute(newRoute, existingRoute)));
      let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [routeId || "_", "patch", String(((_childrenToPatch = childrenToPatch) == null ? void 0 : _childrenToPatch.length) || "0")], manifest);
      childrenToPatch.push(...newRoutes);
    }
    function isSameRoute(newRoute, existingRoute) {
      if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
        return true;
      }
      if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
        return false;
      }
      if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
        return true;
      }
      return newRoute.children.every((aChild, i) => {
        var _existingRoute$childr;
        return (_existingRoute$childr = existingRoute.children) == null ? void 0 : _existingRoute$childr.some((bChild) => isSameRoute(aChild, bChild));
      });
    }
    async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
      if (!route.lazy) {
        return;
      }
      let lazyRoute = await route.lazy();
      if (!route.lazy) {
        return;
      }
      let routeToUpdate = manifest[route.id];
      invariant(routeToUpdate, "No route found in manifest");
      let routeUpdates = {};
      for (let lazyRouteProperty in lazyRoute) {
        let staticRouteValue = routeToUpdate[lazyRouteProperty];
        let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        lazyRouteProperty !== "hasErrorBoundary";
        warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
          routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
        }
      }
      Object.assign(routeToUpdate, routeUpdates);
      Object.assign(routeToUpdate, _extends$2({}, mapRouteProperties2(routeToUpdate), {
        lazy: void 0
      }));
    }
    async function defaultDataStrategy(_ref4) {
      let {
        matches
      } = _ref4;
      let matchesToLoad = matches.filter((m) => m.shouldLoad);
      let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));
      return results.reduce((acc, result, i) => Object.assign(acc, {
        [matchesToLoad[i].route.id]: result
      }), {});
    }
    async function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2, requestContext) {
      let loadRouteDefinitionsPromises = matches.map((m) => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties2, manifest) : void 0);
      let dsMatches = matches.map((match, i) => {
        let loadRoutePromise = loadRouteDefinitionsPromises[i];
        let shouldLoad = matchesToLoad.some((m) => m.route.id === match.route.id);
        let resolve = async (handlerOverride) => {
          if (handlerOverride && request.method === "GET" && (match.route.lazy || match.route.loader)) {
            shouldLoad = true;
          }
          return shouldLoad ? callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, requestContext) : Promise.resolve({
            type: ResultType.data,
            result: void 0
          });
        };
        return _extends$2({}, match, {
          shouldLoad,
          resolve
        });
      });
      let results = await dataStrategyImpl({
        matches: dsMatches,
        request,
        params: matches[0].params,
        fetcherKey,
        context: requestContext
      });
      try {
        await Promise.all(loadRouteDefinitionsPromises);
      } catch (e) {
      }
      return results;
    }
    async function callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, staticContext) {
      let result;
      let onReject;
      let runHandler = (handler) => {
        let reject;
        let abortPromise = new Promise((_, r2) => reject = r2);
        onReject = () => reject();
        request.signal.addEventListener("abort", onReject);
        let actualHandler = (ctx) => {
          if (typeof handler !== "function") {
            return Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + type + '" [routeId: ' + match.route.id + "]")));
          }
          return handler({
            request,
            params: match.params,
            context: staticContext
          }, ...ctx !== void 0 ? [ctx] : []);
        };
        let handlerPromise = (async () => {
          try {
            let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
            return {
              type: "data",
              result: val
            };
          } catch (e) {
            return {
              type: "error",
              result: e
            };
          }
        })();
        return Promise.race([handlerPromise, abortPromise]);
      };
      try {
        let handler = match.route[type];
        if (loadRoutePromise) {
          if (handler) {
            let handlerError;
            let [value] = await Promise.all([
              // If the handler throws, don't let it immediately bubble out,
              // since we need to let the lazy() execution finish so we know if this
              // route has a boundary that can handle the error
              runHandler(handler).catch((e) => {
                handlerError = e;
              }),
              loadRoutePromise
            ]);
            if (handlerError !== void 0) {
              throw handlerError;
            }
            result = value;
          } else {
            await loadRoutePromise;
            handler = match.route[type];
            if (handler) {
              result = await runHandler(handler);
            } else if (type === "action") {
              let url2 = new URL(request.url);
              let pathname = url2.pathname + url2.search;
              throw getInternalRouterError(405, {
                method: request.method,
                pathname,
                routeId: match.route.id
              });
            } else {
              return {
                type: ResultType.data,
                result: void 0
              };
            }
          }
        } else if (!handler) {
          let url2 = new URL(request.url);
          let pathname = url2.pathname + url2.search;
          throw getInternalRouterError(404, {
            pathname
          });
        } else {
          result = await runHandler(handler);
        }
        invariant(result.result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
      } catch (e) {
        return {
          type: ResultType.error,
          result: e
        };
      } finally {
        if (onReject) {
          request.signal.removeEventListener("abort", onReject);
        }
      }
      return result;
    }
    async function convertDataStrategyResultToDataResult(dataStrategyResult) {
      let {
        result,
        type
      } = dataStrategyResult;
      if (isResponse(result)) {
        let data2;
        try {
          let contentType = result.headers.get("Content-Type");
          if (contentType && /\bapplication\/json\b/.test(contentType)) {
            if (result.body == null) {
              data2 = null;
            } else {
              data2 = await result.json();
            }
          } else {
            data2 = await result.text();
          }
        } catch (e) {
          return {
            type: ResultType.error,
            error: e
          };
        }
        if (type === ResultType.error) {
          return {
            type: ResultType.error,
            error: new ErrorResponseImpl(result.status, result.statusText, data2),
            statusCode: result.status,
            headers: result.headers
          };
        }
        return {
          type: ResultType.data,
          data: data2,
          statusCode: result.status,
          headers: result.headers
        };
      }
      if (type === ResultType.error) {
        if (isDataWithResponseInit(result)) {
          var _result$init3, _result$init4;
          if (result.data instanceof Error) {
            var _result$init, _result$init2;
            return {
              type: ResultType.error,
              error: result.data,
              statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
              headers: (_result$init2 = result.init) != null && _result$init2.headers ? new Headers(result.init.headers) : void 0
            };
          }
          return {
            type: ResultType.error,
            error: new ErrorResponseImpl(((_result$init3 = result.init) == null ? void 0 : _result$init3.status) || 500, void 0, result.data),
            statusCode: isRouteErrorResponse(result) ? result.status : void 0,
            headers: (_result$init4 = result.init) != null && _result$init4.headers ? new Headers(result.init.headers) : void 0
          };
        }
        return {
          type: ResultType.error,
          error: result,
          statusCode: isRouteErrorResponse(result) ? result.status : void 0
        };
      }
      if (isDeferredData(result)) {
        var _result$init5, _result$init6;
        return {
          type: ResultType.deferred,
          deferredData: result,
          statusCode: (_result$init5 = result.init) == null ? void 0 : _result$init5.status,
          headers: ((_result$init6 = result.init) == null ? void 0 : _result$init6.headers) && new Headers(result.init.headers)
        };
      }
      if (isDataWithResponseInit(result)) {
        var _result$init7, _result$init8;
        return {
          type: ResultType.data,
          data: result.data,
          statusCode: (_result$init7 = result.init) == null ? void 0 : _result$init7.status,
          headers: (_result$init8 = result.init) != null && _result$init8.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: ResultType.data,
        data: result
      };
    }
    function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {
      let location = response.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
      if (!ABSOLUTE_URL_REGEX.test(location)) {
        let trimmedMatches = matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1);
        location = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location, v7_relativeSplatPath);
        response.headers.set("Location", location);
      }
      return response;
    }
    function normalizeRedirectLocation(location, currentUrl, basename) {
      if (ABSOLUTE_URL_REGEX.test(location)) {
        let normalizedLocation = location;
        let url2 = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
        let isSameBasename = stripBasename(url2.pathname, basename) != null;
        if (url2.origin === currentUrl.origin && isSameBasename) {
          return url2.pathname + url2.search + url2.hash;
        }
      }
      return location;
    }
    function createClientSideRequest(history, location, signal, submission) {
      let url2 = history.createURL(stripHashFromPath(location)).toString();
      let init = {
        signal
      };
      if (submission && isMutationMethod(submission.formMethod)) {
        let {
          formMethod,
          formEncType
        } = submission;
        init.method = formMethod.toUpperCase();
        if (formEncType === "application/json") {
          init.headers = new Headers({
            "Content-Type": formEncType
          });
          init.body = JSON.stringify(submission.json);
        } else if (formEncType === "text/plain") {
          init.body = submission.text;
        } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
          init.body = convertFormDataToSearchParams(submission.formData);
        } else {
          init.body = submission.formData;
        }
      }
      return new Request(url2, init);
    }
    function convertFormDataToSearchParams(formData) {
      let searchParams = new URLSearchParams();
      for (let [key, value] of formData.entries()) {
        searchParams.append(key, typeof value === "string" ? value : value.name);
      }
      return searchParams;
    }
    function convertSearchParamsToFormData(searchParams) {
      let formData = new FormData();
      for (let [key, value] of searchParams.entries()) {
        formData.append(key, value);
      }
      return formData;
    }
    function processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
      let loaderData = {};
      let errors = null;
      let statusCode;
      let foundError = false;
      let loaderHeaders = {};
      let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
      matches.forEach((match) => {
        if (!(match.route.id in results)) {
          return;
        }
        let id2 = match.route.id;
        let result = results[id2];
        invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
        if (isErrorResult(result)) {
          let error2 = result.error;
          if (pendingError !== void 0) {
            error2 = pendingError;
            pendingError = void 0;
          }
          errors = errors || {};
          {
            let boundaryMatch = findNearestBoundary(matches, id2);
            if (errors[boundaryMatch.route.id] == null) {
              errors[boundaryMatch.route.id] = error2;
            }
          }
          loaderData[id2] = void 0;
          if (!foundError) {
            foundError = true;
            statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
          }
          if (result.headers) {
            loaderHeaders[id2] = result.headers;
          }
        } else {
          if (isDeferredResult(result)) {
            activeDeferreds.set(id2, result.deferredData);
            loaderData[id2] = result.deferredData.data;
            if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
              statusCode = result.statusCode;
            }
            if (result.headers) {
              loaderHeaders[id2] = result.headers;
            }
          } else {
            loaderData[id2] = result.data;
            if (result.statusCode && result.statusCode !== 200 && !foundError) {
              statusCode = result.statusCode;
            }
            if (result.headers) {
              loaderHeaders[id2] = result.headers;
            }
          }
        }
      });
      if (pendingError !== void 0 && pendingActionResult) {
        errors = {
          [pendingActionResult[0]]: pendingError
        };
        loaderData[pendingActionResult[0]] = void 0;
      }
      return {
        loaderData,
        errors,
        statusCode: statusCode || 200,
        loaderHeaders
      };
    }
    function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
      let {
        loaderData,
        errors
      } = processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds);
      revalidatingFetchers.forEach((rf) => {
        let {
          key,
          match,
          controller
        } = rf;
        let result = fetcherResults[key];
        invariant(result, "Did not find corresponding fetcher result");
        if (controller && controller.signal.aborted) {
          return;
        } else if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
          if (!(errors && errors[boundaryMatch.route.id])) {
            errors = _extends$2({}, errors, {
              [boundaryMatch.route.id]: result.error
            });
          }
          state.fetchers.delete(key);
        } else if (isRedirectResult(result)) {
          invariant(false, "Unhandled fetcher revalidation redirect");
        } else if (isDeferredResult(result)) {
          invariant(false, "Unhandled fetcher deferred data");
        } else {
          let doneFetcher = getDoneFetcher(result.data);
          state.fetchers.set(key, doneFetcher);
        }
      });
      return {
        loaderData,
        errors
      };
    }
    function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
      let mergedLoaderData = _extends$2({}, newLoaderData);
      for (let match of matches) {
        let id2 = match.route.id;
        if (newLoaderData.hasOwnProperty(id2)) {
          if (newLoaderData[id2] !== void 0) {
            mergedLoaderData[id2] = newLoaderData[id2];
          }
        } else if (loaderData[id2] !== void 0 && match.route.loader) {
          mergedLoaderData[id2] = loaderData[id2];
        }
        if (errors && errors.hasOwnProperty(id2)) {
          break;
        }
      }
      return mergedLoaderData;
    }
    function getActionDataForCommit(pendingActionResult) {
      if (!pendingActionResult) {
        return {};
      }
      return isErrorResult(pendingActionResult[1]) ? {
        // Clear out prior actionData on errors
        actionData: {}
      } : {
        actionData: {
          [pendingActionResult[0]]: pendingActionResult[1].data
        }
      };
    }
    function findNearestBoundary(matches, routeId) {
      let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];
      return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];
    }
    function getShortCircuitMatches(routes) {
      let route = routes.length === 1 ? routes[0] : routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
        id: "__shim-error-route__"
      };
      return {
        matches: [{
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }],
        route
      };
    }
    function getInternalRouterError(status, _temp5) {
      let {
        pathname,
        routeId,
        method,
        type,
        message
      } = _temp5 === void 0 ? {} : _temp5;
      let statusText = "Unknown Server Error";
      let errorMessage = "Unknown @remix-run/router error";
      if (status === 400) {
        statusText = "Bad Request";
        if (method && pathname && routeId) {
          errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
        } else if (type === "defer-action") {
          errorMessage = "defer() is not supported in actions";
        } else if (type === "invalid-body") {
          errorMessage = "Unable to encode submission body";
        }
      } else if (status === 403) {
        statusText = "Forbidden";
        errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
      } else if (status === 404) {
        statusText = "Not Found";
        errorMessage = 'No route matches URL "' + pathname + '"';
      } else if (status === 405) {
        statusText = "Method Not Allowed";
        if (method && pathname && routeId) {
          errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
        } else if (method) {
          errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
        }
      }
      return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
    }
    function findRedirect(results) {
      let entries = Object.entries(results);
      for (let i = entries.length - 1; i >= 0; i--) {
        let [key, result] = entries[i];
        if (isRedirectResult(result)) {
          return {
            key,
            result
          };
        }
      }
    }
    function stripHashFromPath(path) {
      let parsedPath = typeof path === "string" ? parsePath(path) : path;
      return createPath(_extends$2({}, parsedPath, {
        hash: ""
      }));
    }
    function isHashChangeOnly(a, b) {
      if (a.pathname !== b.pathname || a.search !== b.search) {
        return false;
      }
      if (a.hash === "") {
        return b.hash !== "";
      } else if (a.hash === b.hash) {
        return true;
      } else if (b.hash !== "") {
        return true;
      }
      return false;
    }
    function isRedirectDataStrategyResultResult(result) {
      return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
    }
    function isDeferredResult(result) {
      return result.type === ResultType.deferred;
    }
    function isErrorResult(result) {
      return result.type === ResultType.error;
    }
    function isRedirectResult(result) {
      return (result && result.type) === ResultType.redirect;
    }
    function isDataWithResponseInit(value) {
      return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
    }
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
    }
    function isValidMethod(method) {
      return validRequestMethods.has(method.toLowerCase());
    }
    function isMutationMethod(method) {
      return validMutationMethods.has(method.toLowerCase());
    }
    async function resolveNavigationDeferredResults(matches, results, signal, currentMatches, currentLoaderData) {
      let entries = Object.entries(results);
      for (let index2 = 0; index2 < entries.length; index2++) {
        let [routeId, result] = entries[index2];
        let match = matches.find((m) => (m == null ? void 0 : m.route.id) === routeId);
        if (!match) {
          continue;
        }
        let currentMatch = currentMatches.find((m) => m.route.id === match.route.id);
        let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
        if (isDeferredResult(result) && isRevalidatingLoader) {
          await resolveDeferredData(result, signal, false).then((result2) => {
            if (result2) {
              results[routeId] = result2;
            }
          });
        }
      }
    }
    async function resolveFetcherDeferredResults(matches, results, revalidatingFetchers) {
      for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
        let {
          key,
          routeId,
          controller
        } = revalidatingFetchers[index2];
        let result = results[key];
        let match = matches.find((m) => (m == null ? void 0 : m.route.id) === routeId);
        if (!match) {
          continue;
        }
        if (isDeferredResult(result)) {
          invariant(controller, "Expected an AbortController for revalidating fetcher deferred result");
          await resolveDeferredData(result, controller.signal, true).then((result2) => {
            if (result2) {
              results[key] = result2;
            }
          });
        }
      }
    }
    async function resolveDeferredData(result, signal, unwrap) {
      if (unwrap === void 0) {
        unwrap = false;
      }
      let aborted2 = await result.deferredData.resolveData(signal);
      if (aborted2) {
        return;
      }
      if (unwrap) {
        try {
          return {
            type: ResultType.data,
            data: result.deferredData.unwrappedData
          };
        } catch (e) {
          return {
            type: ResultType.error,
            error: e
          };
        }
      }
      return {
        type: ResultType.data,
        data: result.deferredData.data
      };
    }
    function hasNakedIndexQuery(search) {
      return new URLSearchParams(search).getAll("index").some((v) => v === "");
    }
    function getTargetMatch(matches, location) {
      let search = typeof location === "string" ? parsePath(location).search : location.search;
      if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
        return matches[matches.length - 1];
      }
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches[pathMatches.length - 1];
    }
    function getSubmissionFromNavigation(navigation) {
      let {
        formMethod,
        formAction,
        formEncType,
        text,
        formData,
        json: json2
      } = navigation;
      if (!formMethod || !formAction || !formEncType) {
        return;
      }
      if (text != null) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData: void 0,
          json: void 0,
          text
        };
      } else if (formData != null) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData,
          json: void 0,
          text: void 0
        };
      } else if (json2 !== void 0) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData: void 0,
          json: json2,
          text: void 0
        };
      }
    }
    function getLoadingNavigation(location, submission) {
      if (submission) {
        let navigation = {
          state: "loading",
          location,
          formMethod: submission.formMethod,
          formAction: submission.formAction,
          formEncType: submission.formEncType,
          formData: submission.formData,
          json: submission.json,
          text: submission.text
        };
        return navigation;
      } else {
        let navigation = {
          state: "loading",
          location,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          json: void 0,
          text: void 0
        };
        return navigation;
      }
    }
    function getSubmittingNavigation(location, submission) {
      let navigation = {
        state: "submitting",
        location,
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text
      };
      return navigation;
    }
    function getLoadingFetcher(submission, data2) {
      if (submission) {
        let fetcher = {
          state: "loading",
          formMethod: submission.formMethod,
          formAction: submission.formAction,
          formEncType: submission.formEncType,
          formData: submission.formData,
          json: submission.json,
          text: submission.text,
          data: data2
        };
        return fetcher;
      } else {
        let fetcher = {
          state: "loading",
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          json: void 0,
          text: void 0,
          data: data2
        };
        return fetcher;
      }
    }
    function getSubmittingFetcher(submission, existingFetcher) {
      let fetcher = {
        state: "submitting",
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text,
        data: existingFetcher ? existingFetcher.data : void 0
      };
      return fetcher;
    }
    function getDoneFetcher(data2) {
      let fetcher = {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: data2
      };
      return fetcher;
    }
    function restoreAppliedTransitions(_window, transitions) {
      try {
        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
        if (sessionPositions) {
          let json2 = JSON.parse(sessionPositions);
          for (let [k, v] of Object.entries(json2 || {})) {
            if (v && Array.isArray(v)) {
              transitions.set(k, new Set(v || []));
            }
          }
        }
      } catch (e) {
      }
    }
    function persistAppliedTransitions(_window, transitions) {
      if (transitions.size > 0) {
        let json2 = {};
        for (let [k, v] of transitions) {
          json2[k] = [...v];
        }
        try {
          _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json2));
        } catch (error2) {
          warning(false, "Failed to save applied view transitions in sessionStorage (" + error2 + ").");
        }
      }
    }
    /**
     * React Router v6.30.1
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
    const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
    const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
    const RouteContext = /* @__PURE__ */ reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant(false) : void 0;
      return reactExports.useContext(LocationContext).location;
    }
    function useIsomorphicLayoutEffect(cb) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb);
      }
    }
    function useNavigate() {
      let {
        isDataRoute
      } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      !useInRouterContext() ? invariant(false) : void 0;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let {
        basename,
        future,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current) return;
        if (typeof to === "number") {
          navigator2.go(to);
          return;
        }
        let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
        if (dataRouterContext == null && basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
      }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
      return navigate;
    }
    function useParams() {
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let routeMatch = matches[matches.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, future) {
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: parentMatches
      } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location;
      {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = pathname;
      if (parentPathnameBase !== "/") {
        let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
        let segments2 = pathname.replace(/^\//, "").split("/");
        remainingPathname = "/" + segments2.slice(parentSegments.length).join("/");
      }
      let matches = matchRoutes(routes, {
        pathname: remainingPathname
      });
      let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
        ])
      })), parentMatches, dataRouterState, future);
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error2 = useRouteError();
      let message = isRouteErrorResponse(error2) ? error2.status + " " + error2.statusText : error2 instanceof Error ? error2.message : JSON.stringify(error2);
      let stack = error2 instanceof Error ? error2.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = {
        padding: "0.5rem",
        backgroundColor: lightgrey
      };
      let devInfo = null;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
        style: {
          fontStyle: "italic"
        }
      }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
        style: preStyles
      }, stack) : null, devInfo);
    }
    const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error2) {
        return {
          error: error2
        };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error2, errorInfo) {
        console.error("React Router caught the following error during render", error2, errorInfo);
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    }
    function RenderedRoute(_ref) {
      let {
        routeContext,
        match,
        children
      } = _ref;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
        value: routeContext
      }, children);
    }
    function _renderMatches(matches, parentMatches, dataRouterState, future) {
      var _dataRouterState;
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (dataRouterState === void 0) {
        dataRouterState = null;
      }
      if (future === void 0) {
        future = null;
      }
      if (matches == null) {
        var _future;
        if (!dataRouterState) {
          return null;
        }
        if (dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex((m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0);
        !(errorIndex >= 0) ? invariant(false) : void 0;
        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState && future && future.v7_partialHydration) {
        for (let i = 0; i < renderedMatches.length; i++) {
          let match = renderedMatches[i];
          if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
            fallbackIndex = i;
          }
          if (match.route.id) {
            let {
              loaderData,
              errors: errors2
            } = dataRouterState;
            let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors2 || errors2[match.route.id] === void 0);
            if (match.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      return renderedMatches.reduceRight((outlet, match, index2) => {
        let error2;
        let shouldRenderHydrateFallback = false;
        let errorElement = null;
        let hydrateFallbackElement = null;
        if (dataRouterState) {
          error2 = errors && match.route.id ? errors[match.route.id] : void 0;
          errorElement = match.route.errorElement || defaultErrorElement;
          if (renderFallback) {
            if (fallbackIndex < 0 && index2 === 0) {
              warningOnce("route-fallback");
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = null;
            } else if (fallbackIndex === index2) {
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = match.route.hydrateFallbackElement || null;
            }
          }
        }
        let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
        let getChildren = () => {
          let children;
          if (error2) {
            children = errorElement;
          } else if (shouldRenderHydrateFallback) {
            children = hydrateFallbackElement;
          } else if (match.route.Component) {
            children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
          } else if (match.route.element) {
            children = match.route.element;
          } else {
            children = outlet;
          }
          return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
            match,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          });
        };
        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error: error2,
          children: getChildren(),
          routeContext: {
            outlet: null,
            matches: matches2,
            isDataRoute: true
          }
        }) : getChildren();
      }, null);
    }
    var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
      DataRouterHook2["UseBlocker"] = "useBlocker";
      DataRouterHook2["UseRevalidator"] = "useRevalidator";
      DataRouterHook2["UseNavigateStable"] = "useNavigate";
      return DataRouterHook2;
    }(DataRouterHook$1 || {});
    var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
      DataRouterStateHook2["UseBlocker"] = "useBlocker";
      DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
      DataRouterStateHook2["UseActionData"] = "useActionData";
      DataRouterStateHook2["UseRouteError"] = "useRouteError";
      DataRouterStateHook2["UseNavigation"] = "useNavigation";
      DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
      DataRouterStateHook2["UseMatches"] = "useMatches";
      DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
      DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
      DataRouterStateHook2["UseRouteId"] = "useRouteId";
      return DataRouterStateHook2;
    }(DataRouterStateHook$1 || {});
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      !ctx ? invariant(false) : void 0;
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      !state ? invariant(false) : void 0;
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      !route ? invariant(false) : void 0;
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext();
      let thisRoute = route.matches[route.matches.length - 1];
      !thisRoute.route.id ? invariant(false) : void 0;
      return thisRoute.route.id;
    }
    function useRouteError() {
      var _state$errors;
      let error2 = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
      let routeId = useCurrentRouteId();
      if (error2 !== void 0) {
        return error2;
      }
      return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
    }
    function useNavigateStable() {
      let {
        router
      } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
      let id2 = useCurrentRouteId();
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current) return;
        if (typeof to === "number") {
          router.navigate(to);
        } else {
          router.navigate(to, _extends$1({
            fromRouteId: id2
          }, options));
        }
      }, [router, id2]);
      return navigate;
    }
    const alreadyWarned$1 = {};
    function warningOnce(key, cond, message) {
      if (!alreadyWarned$1[key]) {
        alreadyWarned$1[key] = true;
      }
    }
    function logV6DeprecationWarnings(renderFuture, routerFuture) {
      if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) ;
      if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && (!routerFuture || routerFuture.v7_relativeSplatPath === void 0)) ;
      if (routerFuture) {
        if (routerFuture.v7_fetcherPersist === void 0) ;
        if (routerFuture.v7_normalizeFormMethod === void 0) ;
        if (routerFuture.v7_partialHydration === void 0) ;
        if (routerFuture.v7_skipActionErrorRevalidation === void 0) ;
      }
    }
    function Router(_ref5) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action$1.Pop,
        navigator: navigator2,
        static: staticProp = false,
        future
      } = _ref5;
      !!useInRouterContext() ? invariant(false) : void 0;
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(() => ({
        basename,
        navigator: navigator2,
        static: staticProp,
        future: _extends$1({
          v7_relativeSplatPath: false
        }, future)
      }), [basename, future, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash, state, key, navigationType]);
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
        value: navigationContext
      }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        children,
        value: locationContext
      }));
    }
    new Promise(() => {
    });
    function mapRouteProperties(route) {
      let updates = {
        // Note: this check also occurs in createRoutesFromChildren so update
        // there if you change this -- please and thank you!
        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
      };
      if (route.Component) {
        Object.assign(updates, {
          element: /* @__PURE__ */ reactExports.createElement(route.Component),
          Component: void 0
        });
      }
      if (route.HydrateFallback) {
        Object.assign(updates, {
          hydrateFallbackElement: /* @__PURE__ */ reactExports.createElement(route.HydrateFallback),
          HydrateFallback: void 0
        });
      }
      if (route.ErrorBoundary) {
        Object.assign(updates, {
          errorElement: /* @__PURE__ */ reactExports.createElement(route.ErrorBoundary),
          ErrorBoundary: void 0
        });
      }
      return updates;
    }
    /**
     * React Router DOM v6.30.1
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    const REACT_ROUTER_VERSION = "6";
    try {
      window.__reactRouterVersion = REACT_ROUTER_VERSION;
    } catch (e) {
    }
    function createHashRouter(routes, opts) {
      return createRouter({
        basename: void 0,
        future: _extends({}, void 0, {
          v7_prependBasename: true
        }),
        history: createHashHistory({
          window: void 0
        }),
        hydrationData: parseHydrationData(),
        routes,
        mapRouteProperties,
        dataStrategy: void 0,
        patchRoutesOnNavigation: void 0,
        window: void 0
      }).initialize();
    }
    function parseHydrationData() {
      var _window;
      let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
      if (state && state.errors) {
        state = _extends({}, state, {
          errors: deserializeErrors(state.errors)
        });
      }
      return state;
    }
    function deserializeErrors(errors) {
      if (!errors) return null;
      let entries = Object.entries(errors);
      let serialized = {};
      for (let [key, val] of entries) {
        if (val && val.__type === "RouteErrorResponse") {
          serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
        } else if (val && val.__type === "Error") {
          if (val.__subType) {
            let ErrorConstructor = window[val.__subType];
            if (typeof ErrorConstructor === "function") {
              try {
                let error2 = new ErrorConstructor(val.message);
                error2.stack = "";
                serialized[key] = error2;
              } catch (e) {
              }
            }
          }
          if (serialized[key] == null) {
            let error2 = new Error(val.message);
            error2.stack = "";
            serialized[key] = error2;
          }
        } else {
          serialized[key] = val;
        }
      }
      return serialized;
    }
    const ViewTransitionContext = /* @__PURE__ */ reactExports.createContext({
      isTransitioning: false
    });
    const FetchersContext = /* @__PURE__ */ reactExports.createContext(/* @__PURE__ */ new Map());
    const START_TRANSITION = "startTransition";
    const startTransitionImpl = React$1[START_TRANSITION];
    const FLUSH_SYNC = "flushSync";
    const flushSyncImpl = ReactDOM$1[FLUSH_SYNC];
    function startTransitionSafe(cb) {
      if (startTransitionImpl) {
        startTransitionImpl(cb);
      } else {
        cb();
      }
    }
    function flushSyncSafe(cb) {
      if (flushSyncImpl) {
        flushSyncImpl(cb);
      } else {
        cb();
      }
    }
    class Deferred {
      constructor() {
        this.status = "pending";
        this.promise = new Promise((resolve, reject) => {
          this.resolve = (value) => {
            if (this.status === "pending") {
              this.status = "resolved";
              resolve(value);
            }
          };
          this.reject = (reason) => {
            if (this.status === "pending") {
              this.status = "rejected";
              reject(reason);
            }
          };
        });
      }
    }
    function RouterProvider(_ref) {
      let {
        fallbackElement,
        router,
        future
      } = _ref;
      let [state, setStateImpl] = reactExports.useState(router.state);
      let [pendingState, setPendingState] = reactExports.useState();
      let [vtContext, setVtContext] = reactExports.useState({
        isTransitioning: false
      });
      let [renderDfd, setRenderDfd] = reactExports.useState();
      let [transition, setTransition] = reactExports.useState();
      let [interruption, setInterruption] = reactExports.useState();
      let fetcherData = reactExports.useRef(/* @__PURE__ */ new Map());
      let {
        v7_startTransition
      } = future || {};
      let optInStartTransition = reactExports.useCallback((cb) => {
        if (v7_startTransition) {
          startTransitionSafe(cb);
        } else {
          cb();
        }
      }, [v7_startTransition]);
      let setState = reactExports.useCallback((newState, _ref2) => {
        let {
          deletedFetchers,
          flushSync,
          viewTransitionOpts
        } = _ref2;
        newState.fetchers.forEach((fetcher, key) => {
          if (fetcher.data !== void 0) {
            fetcherData.current.set(key, fetcher.data);
          }
        });
        deletedFetchers.forEach((key) => fetcherData.current.delete(key));
        let isViewTransitionUnavailable = router.window == null || router.window.document == null || typeof router.window.document.startViewTransition !== "function";
        if (!viewTransitionOpts || isViewTransitionUnavailable) {
          if (flushSync) {
            flushSyncSafe(() => setStateImpl(newState));
          } else {
            optInStartTransition(() => setStateImpl(newState));
          }
          return;
        }
        if (flushSync) {
          flushSyncSafe(() => {
            if (transition) {
              renderDfd && renderDfd.resolve();
              transition.skipTransition();
            }
            setVtContext({
              isTransitioning: true,
              flushSync: true,
              currentLocation: viewTransitionOpts.currentLocation,
              nextLocation: viewTransitionOpts.nextLocation
            });
          });
          let t = router.window.document.startViewTransition(() => {
            flushSyncSafe(() => setStateImpl(newState));
          });
          t.finished.finally(() => {
            flushSyncSafe(() => {
              setRenderDfd(void 0);
              setTransition(void 0);
              setPendingState(void 0);
              setVtContext({
                isTransitioning: false
              });
            });
          });
          flushSyncSafe(() => setTransition(t));
          return;
        }
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
          setInterruption({
            state: newState,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        } else {
          setPendingState(newState);
          setVtContext({
            isTransitioning: true,
            flushSync: false,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        }
      }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);
      reactExports.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
      reactExports.useEffect(() => {
        if (vtContext.isTransitioning && !vtContext.flushSync) {
          setRenderDfd(new Deferred());
        }
      }, [vtContext]);
      reactExports.useEffect(() => {
        if (renderDfd && pendingState && router.window) {
          let newState = pendingState;
          let renderPromise = renderDfd.promise;
          let transition2 = router.window.document.startViewTransition(async () => {
            optInStartTransition(() => setStateImpl(newState));
            await renderPromise;
          });
          transition2.finished.finally(() => {
            setRenderDfd(void 0);
            setTransition(void 0);
            setPendingState(void 0);
            setVtContext({
              isTransitioning: false
            });
          });
          setTransition(transition2);
        }
      }, [optInStartTransition, pendingState, renderDfd, router.window]);
      reactExports.useEffect(() => {
        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
          renderDfd.resolve();
        }
      }, [renderDfd, transition, state.location, pendingState]);
      reactExports.useEffect(() => {
        if (!vtContext.isTransitioning && interruption) {
          setPendingState(interruption.state);
          setVtContext({
            isTransitioning: true,
            flushSync: false,
            currentLocation: interruption.currentLocation,
            nextLocation: interruption.nextLocation
          });
          setInterruption(void 0);
        }
      }, [vtContext.isTransitioning, interruption]);
      reactExports.useEffect(() => {
      }, []);
      let navigator2 = reactExports.useMemo(() => {
        return {
          createHref: router.createHref,
          encodeLocation: router.encodeLocation,
          go: (n) => router.navigate(n),
          push: (to, state2, opts) => router.navigate(to, {
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          }),
          replace: (to, state2, opts) => router.navigate(to, {
            replace: true,
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          })
        };
      }, [router]);
      let basename = router.basename || "/";
      let dataRouterContext = reactExports.useMemo(() => ({
        router,
        navigator: navigator2,
        static: false,
        basename
      }), [router, navigator2, basename]);
      let routerFuture = reactExports.useMemo(() => ({
        v7_relativeSplatPath: router.future.v7_relativeSplatPath
      }), [router.future.v7_relativeSplatPath]);
      reactExports.useEffect(() => logV6DeprecationWarnings(future, router.future), [future, router.future]);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
        value: dataRouterContext
      }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
        value: state
      }, /* @__PURE__ */ reactExports.createElement(FetchersContext.Provider, {
        value: fetcherData.current
      }, /* @__PURE__ */ reactExports.createElement(ViewTransitionContext.Provider, {
        value: vtContext
      }, /* @__PURE__ */ reactExports.createElement(Router, {
        basename,
        location: state.location,
        navigationType: state.historyAction,
        navigator: navigator2,
        future: routerFuture
      }, state.initialized || router.future.v7_partialHydration ? /* @__PURE__ */ reactExports.createElement(MemoizedDataRoutes, {
        routes: router.routes,
        future: router.future,
        state
      }) : fallbackElement))))), null);
    }
    const MemoizedDataRoutes = /* @__PURE__ */ reactExports.memo(DataRoutes);
    function DataRoutes(_ref3) {
      let {
        routes,
        future,
        state
      } = _ref3;
      return useRoutesImpl(routes, void 0, state, future);
    }
    var DataRouterHook;
    (function(DataRouterHook2) {
      DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
      DataRouterHook2["UseSubmit"] = "useSubmit";
      DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
      DataRouterHook2["UseFetcher"] = "useFetcher";
      DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
    })(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(DataRouterStateHook2) {
      DataRouterStateHook2["UseFetcher"] = "useFetcher";
      DataRouterStateHook2["UseFetchers"] = "useFetchers";
      DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
    })(DataRouterStateHook || (DataRouterStateHook = {}));
    function $constructor(name, initializer2, params) {
      function init(inst, def) {
        var _a;
        Object.defineProperty(inst, "_zod", {
          value: inst._zod ?? {},
          enumerable: false
        });
        (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
        inst._zod.traits.add(name);
        initializer2(inst, def);
        for (const k in _.prototype) {
          Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
        }
        inst._zod.constr = _;
        inst._zod.def = def;
      }
      const Parent = (params == null ? void 0 : params.Parent) ?? Object;
      class Definition extends Parent {
      }
      Object.defineProperty(Definition, "name", { value: name });
      function _(def) {
        var _a;
        const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
        init(inst, def);
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        for (const fn of inst._zod.deferred) {
          fn();
        }
        return inst;
      }
      Object.defineProperty(_, "init", { value: init });
      Object.defineProperty(_, Symbol.hasInstance, {
        value: (inst) => {
          var _a, _b;
          if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
            return true;
          return (_b = (_a = inst == null ? void 0 : inst._zod) == null ? void 0 : _a.traits) == null ? void 0 : _b.has(name);
        }
      });
      Object.defineProperty(_, "name", { value: name });
      return _;
    }
    const $brand = Symbol("zod_brand");
    class $ZodAsyncError extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    }
    const globalConfig = {};
    function config(newConfig) {
      if (newConfig)
        Object.assign(globalConfig, newConfig);
      return globalConfig;
    }
    function assertEqual(val) {
      return val;
    }
    function assertNotEqual(val) {
      return val;
    }
    function assertIs(_arg) {
    }
    function assertNever(_x) {
      throw new Error();
    }
    function assert(_) {
    }
    function getValidEnumValues(obj) {
      const validKeys = Object.keys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return Object.values(filtered);
    }
    function joinValues(array2, separator = "|") {
      return array2.map((val) => stringifyPrimitive(val)).join(separator);
    }
    function jsonStringifyReplacer(_, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    function cached(getter) {
      return {
        get value() {
          {
            const value = getter();
            Object.defineProperty(this, "value", { value });
            return value;
          }
        }
      };
    }
    function nullish$1(input) {
      return input === null || input === void 0;
    }
    function cleanRegex(source) {
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      return source.slice(start, end);
    }
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / 10 ** decCount;
    }
    function defineLazy(object2, key, getter) {
      Object.defineProperty(object2, key, {
        get() {
          {
            const value = getter();
            object2[key] = value;
            return value;
          }
        },
        set(v) {
          Object.defineProperty(object2, key, {
            value: v
            // configurable: true,
          });
        },
        configurable: true
      });
    }
    function assignProp(target, prop, value) {
      Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    function getElementAtPath(obj, path) {
      if (!path)
        return obj;
      return path.reduce((acc, key) => acc == null ? void 0 : acc[key], obj);
    }
    function promiseAllObject(promisesObj) {
      const keys = Object.keys(promisesObj);
      const promises = keys.map((key) => promisesObj[key]);
      return Promise.all(promises).then((results) => {
        const resolvedObj = {};
        for (let i = 0; i < keys.length; i++) {
          resolvedObj[keys[i]] = results[i];
        }
        return resolvedObj;
      });
    }
    function randomString(length = 10) {
      const chars = "abcdefghijklmnopqrstuvwxyz";
      let str = "";
      for (let i = 0; i < length; i++) {
        str += chars[Math.floor(Math.random() * chars.length)];
      }
      return str;
    }
    function esc(str) {
      return JSON.stringify(str);
    }
    function isObject(data2) {
      return typeof data2 === "object" && data2 !== null;
    }
    const allowsEval = cached(() => {
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    function isPlainObject(data2) {
      return typeof data2 === "object" && data2 !== null && Object.getPrototypeOf(data2) === Object.prototype;
    }
    function numKeys(data2) {
      let keyCount = 0;
      for (const key in data2) {
        if (Object.prototype.hasOwnProperty.call(data2, key)) {
          keyCount++;
        }
      }
      return keyCount;
    }
    const getParsedType = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data2) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data2 instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data2 instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data2 instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data2 instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    const primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    function escapeRegex(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function clone(inst, def, params) {
      const cl = new inst._zod.constr(def ?? inst._zod.def);
      if (!def || (params == null ? void 0 : params.parent))
        cl._zod.parent = inst;
      return cl;
    }
    function normalizeParams(_params) {
      const params = _params;
      if (!params)
        return {};
      if (typeof params === "string")
        return { error: () => params };
      if ((params == null ? void 0 : params.message) !== void 0) {
        if ((params == null ? void 0 : params.error) !== void 0)
          throw new Error("Cannot specify both `message` and `error` params");
        params.error = params.message;
      }
      delete params.message;
      if (typeof params.error === "string")
        return { ...params, error: () => params.error };
      return params;
    }
    function createTransparentProxy(getter) {
      let target;
      return new Proxy({}, {
        get(_, prop, receiver) {
          target ?? (target = getter());
          return Reflect.get(target, prop, receiver);
        },
        set(_, prop, value, receiver) {
          target ?? (target = getter());
          return Reflect.set(target, prop, value, receiver);
        },
        has(_, prop) {
          target ?? (target = getter());
          return Reflect.has(target, prop);
        },
        deleteProperty(_, prop) {
          target ?? (target = getter());
          return Reflect.deleteProperty(target, prop);
        },
        ownKeys(_) {
          target ?? (target = getter());
          return Reflect.ownKeys(target);
        },
        getOwnPropertyDescriptor(_, prop) {
          target ?? (target = getter());
          return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        defineProperty(_, prop, descriptor) {
          target ?? (target = getter());
          return Reflect.defineProperty(target, prop, descriptor);
        }
      });
    }
    function stringifyPrimitive(value) {
      if (typeof value === "bigint")
        return value.toString() + "n";
      if (typeof value === "string")
        return `"${value}"`;
      return `${value}`;
    }
    function optionalKeys(shape) {
      return Object.keys(shape).filter((k) => {
        return shape[k]._zod.optin === "optional";
      });
    }
    const NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    const BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    function pick(schema, mask) {
      const newShape = {};
      const currDef = schema._zod.def;
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      return clone(schema, {
        ...schema._zod.def,
        shape: newShape,
        checks: []
      });
    }
    function omit(schema, mask) {
      const newShape = { ...schema._zod.def.shape };
      const currDef = schema._zod.def;
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      return clone(schema, {
        ...schema._zod.def,
        shape: newShape,
        checks: []
      });
    }
    function extend(schema, shape) {
      const def = {
        ...schema._zod.def,
        get shape() {
          const _shape = { ...schema._zod.def.shape, ...shape };
          assignProp(this, "shape", _shape);
          return _shape;
        },
        checks: []
        // delete existing checks
      };
      return clone(schema, def);
    }
    function merge(a, b) {
      return clone(a, {
        ...a._zod.def,
        get shape() {
          const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
          assignProp(this, "shape", _shape);
          return _shape;
        },
        catchall: b._zod.def.catchall,
        checks: []
        // delete existing checks
      });
    }
    function partial(Class2, schema, mask) {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      return clone(schema, {
        ...schema._zod.def,
        shape,
        checks: []
      });
    }
    function required(Class2, schema, mask) {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      return clone(schema, {
        ...schema._zod.def,
        shape,
        // optional: [],
        checks: []
      });
    }
    function aborted(x, startIndex = 0) {
      for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i].continue !== true)
          return true;
      }
      return false;
    }
    function prefixIssues(path, issues) {
      return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
      });
    }
    function unwrapMessage(message) {
      return typeof message === "string" ? message : message == null ? void 0 : message.message;
    }
    function finalizeIssue(iss, ctx, config2) {
      var _a, _b, _c, _d, _e, _f;
      const full = { ...iss, path: iss.path ?? [] };
      if (!iss.message) {
        const message = unwrapMessage((_c = (_b = (_a = iss.inst) == null ? void 0 : _a._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config2.customError) == null ? void 0 : _e.call(config2, iss)) ?? unwrapMessage((_f = config2.localeError) == null ? void 0 : _f.call(config2, iss)) ?? "Invalid input";
        full.message = message;
      }
      delete full.inst;
      delete full.continue;
      if (!(ctx == null ? void 0 : ctx.reportInput)) {
        delete full.input;
      }
      return full;
    }
    function getSizableOrigin(input) {
      if (input instanceof Set)
        return "set";
      if (input instanceof Map)
        return "map";
      if (input instanceof File)
        return "file";
      return "unknown";
    }
    function getLengthableOrigin(input) {
      if (Array.isArray(input))
        return "array";
      if (typeof input === "string")
        return "string";
      return "unknown";
    }
    function issue(...args) {
      const [iss, input, inst] = args;
      if (typeof iss === "string") {
        return {
          message: iss,
          code: "custom",
          input,
          inst
        };
      }
      return { ...iss };
    }
    function cleanEnum(obj) {
      return Object.entries(obj).filter(([k, _]) => {
        return Number.isNaN(Number.parseInt(k, 10));
      }).map((el) => el[1]);
    }
    class Class {
      constructor(..._args) {
      }
    }
    const util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      BIGINT_FORMAT_RANGES,
      Class,
      NUMBER_FORMAT_RANGES,
      aborted,
      allowsEval,
      assert,
      assertEqual,
      assertIs,
      assertNever,
      assertNotEqual,
      assignProp,
      cached,
      cleanEnum,
      cleanRegex,
      clone,
      createTransparentProxy,
      defineLazy,
      esc,
      escapeRegex,
      extend,
      finalizeIssue,
      floatSafeRemainder,
      getElementAtPath,
      getLengthableOrigin,
      getParsedType,
      getSizableOrigin,
      getValidEnumValues,
      isObject,
      isPlainObject,
      issue,
      joinValues,
      jsonStringifyReplacer,
      merge,
      normalizeParams,
      nullish: nullish$1,
      numKeys,
      omit,
      optionalKeys,
      partial,
      pick,
      prefixIssues,
      primitiveTypes,
      promiseAllObject,
      propertyKeyTypes,
      randomString,
      required,
      stringifyPrimitive,
      unwrapMessage
    }, Symbol.toStringTag, { value: "Module" }));
    const initializer$1 = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      Object.defineProperty(inst, "message", {
        get() {
          return JSON.stringify(def, jsonStringifyReplacer, 2);
        },
        enumerable: true
        // configurable: false,
      });
    };
    const $ZodError = $constructor("$ZodError", initializer$1);
    const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
    function flattenError(error2, mapper = (issue2) => issue2.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of error2.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    function formatError(error2, _mapper) {
      const mapper = _mapper || function(issue2) {
        return issue2.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error3) => {
        for (const issue2 of error3.issues) {
          if (issue2.code === "invalid_union") {
            issue2.errors.map((issues) => processError({ issues }));
          } else if (issue2.code === "invalid_key") {
            processError({ issues: issue2.issues });
          } else if (issue2.code === "invalid_element") {
            processError({ issues: issue2.issues });
          } else if (issue2.path.length === 0) {
            fieldErrors._errors.push(mapper(issue2));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue2.path.length) {
              const el = issue2.path[i];
              const terminal = i === issue2.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue2));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(error2);
      return fieldErrors;
    }
    function treeifyError(error2, _mapper) {
      const mapper = _mapper || function(issue2) {
        return issue2.message;
      };
      const result = { errors: [] };
      const processError = (error3, path = []) => {
        var _a, _b;
        for (const issue2 of error3.issues) {
          if (issue2.code === "invalid_union") {
            issue2.errors.map((issues) => processError({ issues }, issue2.path));
          } else if (issue2.code === "invalid_key") {
            processError({ issues: issue2.issues }, issue2.path);
          } else if (issue2.code === "invalid_element") {
            processError({ issues: issue2.issues }, issue2.path);
          } else {
            const fullpath = [...path, ...issue2.path];
            if (fullpath.length === 0) {
              result.errors.push(mapper(issue2));
              continue;
            }
            let curr = result;
            let i = 0;
            while (i < fullpath.length) {
              const el = fullpath[i];
              const terminal = i === fullpath.length - 1;
              if (typeof el === "string") {
                curr.properties ?? (curr.properties = {});
                (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
                curr = curr.properties[el];
              } else {
                curr.items ?? (curr.items = []);
                (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
                curr = curr.items[el];
              }
              if (terminal) {
                curr.errors.push(mapper(issue2));
              }
              i++;
            }
          }
        }
      };
      processError(error2);
      return result;
    }
    function toDotPath(path) {
      const segs = [];
      for (const seg of path) {
        if (typeof seg === "number")
          segs.push(`[${seg}]`);
        else if (typeof seg === "symbol")
          segs.push(`[${JSON.stringify(String(seg))}]`);
        else if (/[^\w$]/.test(seg))
          segs.push(`[${JSON.stringify(seg)}]`);
        else {
          if (segs.length)
            segs.push(".");
          segs.push(seg);
        }
      }
      return segs.join("");
    }
    function prettifyError(error2) {
      var _a;
      const lines = [];
      const issues = [...error2.issues].sort((a, b) => a.path.length - b.path.length);
      for (const issue2 of issues) {
        lines.push(`✖ ${issue2.message}`);
        if ((_a = issue2.path) == null ? void 0 : _a.length)
          lines.push(`  → at ${toDotPath(issue2.path)}`);
      }
      return lines.join("\n");
    }
    const _parse = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        Error.captureStackTrace(e, _params == null ? void 0 : _params.callee);
        throw e;
      }
      return result.value;
    };
    const parse$1 = /* @__PURE__ */ _parse($ZodRealError);
    const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        Error.captureStackTrace(e, params == null ? void 0 : params.callee);
        throw e;
      }
      return result.value;
    };
    const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
    const _safeParse = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
    const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
    const cuid$1 = /^[cC][^\s-]{8,}$/;
    const cuid2$1 = /^[0-9a-z]+$/;
    const ulid$1 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    const xid$1 = /^[0-9a-vA-V]{20}$/;
    const ksuid$1 = /^[A-Za-z0-9]{27}$/;
    const nanoid$1 = /^[a-zA-Z0-9_-]{21}$/;
    const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    const extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    const guid$1 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    const uuid$1 = (version2) => {
      if (!version2)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    const uuid4 = uuid$1(4);
    const uuid6 = uuid$1(6);
    const uuid7 = uuid$1(7);
    const email$1 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    const html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    const rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    const unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    const browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    function emoji$1() {
      return new RegExp(_emoji$1, "u");
    }
    const ipv4$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    const ipv6$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
    const cidrv4$1 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    const cidrv6$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    const ip = new RegExp(`(${ipv4$1.source})|(${ipv6$1.source})`);
    const base64$1 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    const base64url$1 = /^[A-Za-z0-9_-]*$/;
    const hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
    const e164$1 = /^\+(?:[0-9]){6,14}[0-9]$/;
    const dateSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    const date$3 = new RegExp(`^${dateSource}$`);
    function timeSource(args) {
      let regex2 = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
      if (args.precision) {
        regex2 = `${regex2}\\.\\d{${args.precision}}`;
      } else if (args.precision == null) {
        regex2 = `${regex2}(\\.\\d+)?`;
      }
      return regex2;
    }
    function time$1(args) {
      return new RegExp(`^${timeSource(args)}$`);
    }
    function datetime$1(args) {
      let regex2 = `${dateSource}T${timeSource(args)}`;
      const opts = [];
      opts.push(args.local ? `Z?` : `Z`);
      if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
      regex2 = `${regex2}(${opts.join("|")})`;
      return new RegExp(`^${regex2}$`);
    }
    const string$2 = (params) => {
      const regex2 = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex2}$`);
    };
    const bigint$2 = /^\d+n?$/;
    const integer = /^\d+$/;
    const number$2 = /^-?\d+(?:\.\d+)?/i;
    const boolean$2 = /true|false/i;
    const _null$2 = /null/i;
    const _undefined$2 = /undefined/i;
    const lowercase = /^[^A-Z]*$/;
    const uppercase = /^[^a-z]*$/;
    const regexes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      _emoji: _emoji$1,
      base64: base64$1,
      base64url: base64url$1,
      bigint: bigint$2,
      boolean: boolean$2,
      browserEmail,
      cidrv4: cidrv4$1,
      cidrv6: cidrv6$1,
      cuid: cuid$1,
      cuid2: cuid2$1,
      date: date$3,
      datetime: datetime$1,
      duration: duration$1,
      e164: e164$1,
      email: email$1,
      emoji: emoji$1,
      extendedDuration,
      guid: guid$1,
      hostname,
      html5Email,
      integer,
      ip,
      ipv4: ipv4$1,
      ipv6: ipv6$1,
      ksuid: ksuid$1,
      lowercase,
      nanoid: nanoid$1,
      null: _null$2,
      number: number$2,
      rfc5322Email,
      string: string$2,
      time: time$1,
      ulid: ulid$1,
      undefined: _undefined$2,
      unicodeEmail,
      uppercase,
      uuid: uuid$1,
      uuid4,
      uuid6,
      uuid7,
      xid: xid$1
    }, Symbol.toStringTag, { value: "Module" }));
    const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
      var _a;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a = inst._zod).onattach ?? (_a.onattach = []);
    });
    const numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a;
        (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt = (_a = def.format) == null ? void 0 : _a.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    const $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    const $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.when = (payload) => {
        const val = payload.value;
        return !nullish$1(val) && val.size !== void 0;
      };
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.when = (payload) => {
        const val = payload.value;
        return !nullish$1(val) && val.size !== void 0;
      };
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.when = (payload) => {
        const val = payload.value;
        return !nullish$1(val) && val.size !== void 0;
      };
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.when = (payload) => {
        const val = payload.value;
        return !nullish$1(val) && val.length !== void 0;
      };
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.when = (payload) => {
        const val = payload.value;
        return !nullish$1(val) && val.length !== void 0;
      };
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.when = (payload) => {
        const val = payload.value;
        return !nullish$1(val) && val.length !== void 0;
      };
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.format = def.format;
        if (def.pattern)
          inst2._zod.bag.pattern = def.pattern;
      });
      (_a = inst._zod).check ?? (_a.check = (payload) => {
        if (!def.pattern)
          throw new Error("Not implemented.");
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    });
    const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(escapeRegex(def.includes));
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.pattern = pattern;
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.pattern = pattern;
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    function handleCheckPropertyResult(result, payload, property) {
      if (result.issues.length) {
        payload.issues.push(...prefixIssues(property, result.issues));
      }
    }
    const $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    const $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          path: ["type"],
          inst
        });
      };
    });
    const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
    class Doc {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this == null ? void 0 : this.args;
        const content = (this == null ? void 0 : this.content) ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    }
    const version$1 = {
      major: 4,
      minor: 0,
      patch: 0
    };
    const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
      var _a2;
      var _a;
      inst ?? (inst = {});
      inst._zod.id = def.type + "_" + randomString(10);
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version$1;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        (_a2 = inst._zod.deferred) == null ? void 0 : _a2.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks2, ctx) => {
          let isAborted = aborted(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.when) {
              const shouldRun = ch._zod.when(payload);
              if (!shouldRun)
                continue;
            } else {
              if (isAborted) {
                continue;
              }
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
              throw new $ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted)
                  isAborted = aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        inst._zod.run = (payload, ctx) => {
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      inst["~standard"] = {
        validate: (value) => {
          var _a3;
          try {
            const r2 = safeParse$1(inst, value);
            return r2.success ? { value: r2.data } : { issues: (_a3 = r2.error) == null ? void 0 : _a3.issues };
          } catch (_) {
            return safeParseAsync$1(inst, value).then((r2) => {
              var _a4;
              return r2.success ? { value: r2.data } : { issues: (_a4 = r2.error) == null ? void 0 : _a4.issues };
            });
          }
        },
        vendor: "zod",
        version: 1
      };
    });
    const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
      var _a;
      $ZodType.init(inst, def);
      inst._zod.pattern = ((_a = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a.pattern) ?? string$2(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
    });
    const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid$1(v));
      } else
        def.pattern ?? (def.pattern = uuid$1());
      $ZodStringFormat.init(inst, def);
    });
    const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const url2 = new URL(payload.value);
          hostname.lastIndex = 0;
          if (!hostname.test(url2.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: hostname.source,
              input: payload.value,
              inst
            });
          }
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url2.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: def.hostname.source,
                input: payload.value,
                inst
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst
              });
            }
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst
          });
        }
      };
    });
    const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji$1());
      $ZodStringFormat.init(inst, def);
    });
    const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime$1(def));
      $ZodStringFormat.init(inst, def);
    });
    const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date$3);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time$1(def));
      $ZodStringFormat.init(inst, def);
    });
    const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.format = `ipv4`;
      });
    });
    const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.format = `ipv6`;
      });
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst
          });
        }
      };
    });
    const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4$1);
      $ZodStringFormat.init(inst, def);
    });
    const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const [address, prefix] = payload.value.split("/");
        try {
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst
          });
        }
      };
    });
    function isValidBase64(data2) {
      if (data2 === "")
        return true;
      if (data2.length % 4 !== 0)
        return false;
      try {
        atob(data2);
        return true;
      } catch {
        return false;
      }
    }
    const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base64$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst
        });
      };
    });
    function isValidBase64URL(data2) {
      if (!base64url$1.test(data2))
        return false;
      const base642 = data2.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
      const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
      return isValidBase64(padded);
    }
    const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64url";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst
        });
      };
    });
    const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164$1);
      $ZodStringFormat.init(inst, def);
    });
    function isValidJWT(token, algorithm = null) {
      try {
        const tokensParts = token.split(".");
        if (tokensParts.length !== 3)
          return false;
        const [header] = tokensParts;
        const parsedHeader = JSON.parse(atob(header));
        if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
          return false;
        if (!parsedHeader.alg)
          return false;
        if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
          return false;
        return true;
      } catch {
        return false;
      }
    }
    const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst
        });
      };
    });
    const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number$2;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def);
    });
    const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean$2;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint$2;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        const { value: input } = payload;
        if (typeof input === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def);
    });
    const $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const { value: input } = payload;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined$2;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.parse = (payload, _ctx) => {
        const { value: input } = payload;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null$2;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const { value: input } = payload;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    const $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const { value: input } = payload;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    function handleArrayResult(result, final, index2) {
      if (result.issues.length) {
        final.issues.push(...prefixIssues(index2, result.issues));
      }
      final.value[index2] = result.value;
    }
    const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    function handleObjectResult(result, final, key) {
      if (result.issues.length) {
        final.issues.push(...prefixIssues(key, result.issues));
      }
      final.value[key] = result.value;
    }
    function handleOptionalObjectResult(result, final, key, input) {
      if (result.issues.length) {
        if (input[key] === void 0) {
          if (key in input) {
            final.value[key] = void 0;
          } else {
            final.value[key] = result.value;
          }
        } else {
          final.issues.push(...prefixIssues(key, result.issues));
        }
      } else if (result.value === void 0) {
        if (key in input)
          final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    }
    const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
      $ZodType.init(inst, def);
      const _normalized = cached(() => {
        const keys = Object.keys(def.shape);
        const okeys = optionalKeys(def.shape);
        return {
          shape: def.shape,
          keys,
          keySet: new Set(keys),
          numKeys: keys.length,
          optionalKeys: new Set(okeys)
        };
      });
      defineLazy(inst._zod, "disc", () => {
        const shape = def.shape;
        const discMap = /* @__PURE__ */ new Map();
        let hasDisc = false;
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values || field.disc) {
            hasDisc = true;
            const o = {
              values: new Set(field.values ?? []),
              maps: field.disc ? [field.disc] : []
            };
            discMap.set(key, o);
          }
        }
        if (!hasDisc) {
          return void 0;
        }
        return discMap;
      });
      const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const { keys, optionalKeys: optionalKeys2 } = _normalized.value;
        const parseStr = (key) => {
          const k = esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        for (const key of keys) {
          ids[key] = randomString(15);
        }
        doc.write(`const newResult = {}`);
        for (const key of keys) {
          if (optionalKeys2.has(key)) {
            const id2 = ids[key];
            doc.write(`const ${id2} = ${parseStr(key)};`);
            const k = esc(key);
            doc.write(`
        if (${id2}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id2}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id2}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id2}.value;
        }
        `);
          } else {
            const id2 = ids[key];
            doc.write(`const ${id2} = ${parseStr(key)};`);
            doc.write(`
          if (${id2}.issues.length) payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
            doc.write(`newResult[${esc(key)}] = ${id2}.value`);
          }
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject$1 = isObject;
      const jit = !globalConfig.jitless;
      const allowsEval$1 = allowsEval;
      const fastEnabled = jit && allowsEval$1.value;
      const { catchall } = def;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject$1(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
        } else {
          payload.value = {};
          const shape = value.shape;
          for (const key of value.keys) {
            const el = shape[key];
            const r2 = el._zod.run({ value: input[key], issues: [] }, ctx);
            const isOptional = el._zod.optin === "optional";
            if (r2 instanceof Promise) {
              proms.push(r2.then((r3) => isOptional ? handleOptionalObjectResult(r3, payload, key, input) : handleObjectResult(r3, payload, key)));
            } else {
              if (isOptional) {
                handleOptionalObjectResult(r2, payload, key, input);
              } else {
                handleObjectResult(r2, payload, key);
              }
            }
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        const unrecognized = [];
        const keySet = value.keySet;
        const _catchall = catchall._zod;
        const t = _catchall.def.type;
        for (const key of Object.keys(input)) {
          if (keySet.has(key))
            continue;
          if (t === "never") {
            unrecognized.push(key);
            continue;
          }
          const r2 = _catchall.run({ value: input[key], issues: [] }, ctx);
          if (r2 instanceof Promise) {
            proms.push(r2.then((r3) => handleObjectResult(r3, payload, key)));
          } else {
            handleObjectResult(r2, payload, key);
          }
        }
        if (unrecognized.length) {
          payload.issues.push({
            code: "unrecognized_keys",
            keys: unrecognized,
            input,
            inst
          });
        }
        if (!proms.length)
          return payload;
        return Promise.all(proms).then(() => {
          return payload;
        });
      };
    });
    function handleUnionResults(results, final, inst, ctx) {
      for (const result of results) {
        if (result.issues.length === 0) {
          final.value = result.value;
          return final;
        }
      }
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      });
      return final;
    }
    const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    function matchDiscriminatorAtKey(input, key, disc) {
      let matched = true;
      const data2 = input == null ? void 0 : input[key];
      if (disc.values.size && !disc.values.has(data2)) {
        matched = false;
      }
      if (disc.maps.length > 0) {
        for (const m of disc.maps) {
          if (!matchDiscriminators(data2, m)) {
            matched = false;
          }
        }
      }
      return matched;
    }
    function matchDiscriminators(input, discs) {
      let matched = true;
      for (const [key, value] of discs) {
        if (!matchDiscriminatorAtKey(input, key, value)) {
          matched = false;
        }
      }
      return matched;
    }
    const $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "disc", () => {
        const _disc = /* @__PURE__ */ new Map();
        for (const el of def.options) {
          const subdisc = el._zod.disc;
          if (!subdisc)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(el)}"`);
          for (const [key, o] of subdisc) {
            if (!_disc.has(key))
              _disc.set(key, {
                values: /* @__PURE__ */ new Set(),
                maps: []
              });
            const _o = _disc.get(key);
            for (const v of o.values) {
              _o.values.add(v);
            }
            for (const m of o.maps)
              _o.maps.push(m);
          }
        }
        return _disc;
      });
      const _discmap = cached(() => {
        var _a;
        const map2 = /* @__PURE__ */ new Map();
        for (const o of def.options) {
          const discEl = (_a = o._zod.disc) == null ? void 0 : _a.get(def.discriminator);
          if (!discEl)
            throw new Error("Invalid discriminated union option");
          map2.set(o, discEl);
        }
        return map2;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const filtered = [];
        const discmap = _discmap.value;
        for (const option of def.options) {
          const subdisc = discmap.get(option);
          if (matchDiscriminatorAtKey(input, def.discriminator, subdisc)) {
            filtered.push(option);
          }
        }
        if (filtered.length === 1)
          return filtered[0]._zod.run(payload, ctx);
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const { value: input } = payload;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    function mergeValues(a, b) {
      if (a === b) {
        return { valid: true, data: a };
      }
      if (a instanceof Date && b instanceof Date && +a === +b) {
        return { valid: true, data: a };
      }
      if (isPlainObject(a) && isPlainObject(b)) {
        const bKeys = Object.keys(b);
        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return {
              valid: false,
              mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
            };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
          return { valid: false, mergeErrorPath: [] };
        }
        const newArray = [];
        for (let index2 = 0; index2 < a.length; index2++) {
          const itemA = a[index2];
          const itemB = b[index2];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return {
              valid: false,
              mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
            };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      }
      return { valid: false, mergeErrorPath: [] };
    }
    function handleIntersectionResults(result, left, right) {
      if (left.issues.length) {
        result.issues.push(...left.issues);
      }
      if (right.issues.length) {
        result.issues.push(...right.issues);
      }
      if (aborted(result))
        return result;
      const merged = mergeValues(left.value, right.value);
      if (!merged.valid) {
        throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
      }
      result.value = merged.data;
      return result;
    }
    const $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              input,
              inst,
              origin: "array",
              ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleTupleResult(result, final, index2) {
      if (result.issues.length) {
        final.issues.push(...prefixIssues(index2, result.issues));
      }
      final.value[index2] = result.value;
    }
    const $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
          const values = def.keyType._zod.values;
          payload.value = {};
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!values.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (keyResult.issues.length) {
              payload.issues.push({
                origin: "record",
                code: "invalid_key",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                input: key,
                path: [key],
                inst
              });
              payload.value[keyResult.value] = keyResult.value;
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    const $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
      if (keyResult.issues.length) {
        if (propertyKeyTypes.has(typeof key)) {
          final.issues.push(...prefixIssues(key, keyResult.issues));
        } else {
          final.issues.push({
            origin: "map",
            code: "invalid_key",
            input,
            inst,
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
          });
        }
      }
      if (valueResult.issues.length) {
        if (propertyKeyTypes.has(typeof key)) {
          final.issues.push(...prefixIssues(key, valueResult.issues));
        } else {
          final.issues.push({
            origin: "map",
            code: "invalid_element",
            input,
            inst,
            key,
            issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
          });
        }
      }
      final.value.set(keyResult.value, valueResult.value);
    }
    const $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleSetResult(result, final) {
      if (result.issues.length) {
        final.issues.push(...result.issues);
      }
      final.value.add(result.value);
    }
    const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const numericValues = Object.values(def.entries).filter((v) => typeof v === "number");
      const values = Object.entries(def.entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
      inst._zod.values = new Set(values);
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.values = new Set(def.values);
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const _out = def.transform(payload.value, payload);
        if (_ctx.async) {
          const output2 = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output2.then((output3) => {
            payload.value = output3;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    function handleDefaultResult(payload, def) {
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
      }
      return payload;
    }
    const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    function handleNonOptionalResult(payload, inst) {
      if (!payload.issues.length && payload.value === void 0) {
        payload.issues.push({
          code: "invalid_type",
          expected: "nonoptional",
          input: payload.value,
          inst
        });
      }
      return payload;
    }
    const $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    const $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def, ctx));
        }
        return handlePipeResult(left, def, ctx);
      };
    });
    function handlePipeResult(left, def, ctx) {
      if (aborted(left)) {
        return left;
      }
      return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
    }
    const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "disc", () => def.innerType._zod.disc);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    function handleReadonlyResult(payload) {
      payload.value = Object.freeze(payload.value);
      return payload;
    }
    const $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (part instanceof $ZodType) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes.has(typeof part)) {
          regexParts.push(escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "template_literal",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    const $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    const $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
      defineLazy(inst._zod, "disc", () => inst._zod.innerType._zod.disc);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r2 = def.fn(input);
        if (r2 instanceof Promise) {
          return r2.then((r3) => handleRefineResult(r3, payload, input, inst));
        }
        handleRefineResult(r2, payload, input, inst);
        return;
      };
    });
    function handleRefineResult(result, payload, input, inst) {
      if (!result) {
        const _iss = {
          code: "custom",
          input,
          inst,
          // incorporates params.error into issue reporting
          path: [...inst._zod.def.path ?? []],
          // incorporates params.error into issue reporting
          continue: !inst._zod.def.abort
          // params: inst._zod.def.params,
        };
        if (inst._zod.def.params)
          _iss.params = inst._zod.def.params;
        payload.issues.push(issue(_iss));
      }
    }
    const Sizable$x = {
      string: { unit: "حرف", verb: "أن يحوي" },
      file: { unit: "بايت", verb: "أن يحوي" },
      array: { unit: "عنصر", verb: "أن يحوي" },
      set: { unit: "عنصر", verb: "أن يحوي" }
    };
    function getSizing$x(origin) {
      return Sizable$x[origin] ?? null;
    }
    const parsedType$x = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$x = {
      regex: "مدخل",
      email: "بريد إلكتروني",
      url: "رابط",
      emoji: "إيموجي",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "تاريخ ووقت بمعيار ISO",
      date: "تاريخ بمعيار ISO",
      time: "وقت بمعيار ISO",
      duration: "مدة بمعيار ISO",
      ipv4: "عنوان IPv4",
      ipv6: "عنوان IPv6",
      cidrv4: "مدى عناوين بصيغة IPv4",
      cidrv6: "مدى عناوين بصيغة IPv6",
      base64: "نَص بترميز base64-encoded",
      base64url: "نَص بترميز base64url-encoded",
      json_string: "نَص على هيئة JSON",
      e164: "رقم هاتف بمعيار E.164",
      jwt: "JWT",
      template_literal: "مدخل"
    };
    const error$x = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `مدخلات غير مقبولة: يفترض إدخال ${issue2.expected}، ولكن تم إدخال ${parsedType$x(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `مدخلات غير مقبولة: يفترض إدخال ${stringifyPrimitive(issue2.values[0])}`;
          return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$x(issue2.origin);
          if (sizing)
            return ` أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"}`;
          return `أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$x(issue2.origin);
          if (sizing) {
            return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `نَص غير مقبول: يجب أن يبدأ بـ "${issue2.prefix}"`;
          if (_issue.format === "ends_with")
            return `نَص غير مقبول: يجب أن ينتهي بـ "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `نَص غير مقبول: يجب أن يتضمَّن "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;
          return `${Nouns$x[_issue.format] ?? issue2.format} غير مقبول`;
        }
        case "not_multiple_of":
          return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue2.divisor}`;
        case "unrecognized_keys":
          return `معرف${issue2.keys.length > 1 ? "ات" : ""} غريب${issue2.keys.length > 1 ? "ة" : ""}: ${joinValues(issue2.keys, "، ")}`;
        case "invalid_key":
          return `معرف غير مقبول في ${issue2.origin}`;
        case "invalid_union":
          return "مدخل غير مقبول";
        case "invalid_element":
          return `مدخل غير مقبول في ${issue2.origin}`;
        default:
          return "مدخل غير مقبول";
      }
    };
    function ar() {
      return {
        localeError: error$x
      };
    }
    const Sizable$w = {
      string: { unit: "simvol", verb: "olmalıdır" },
      file: { unit: "bayt", verb: "olmalıdır" },
      array: { unit: "element", verb: "olmalıdır" },
      set: { unit: "element", verb: "olmalıdır" }
    };
    function getSizing$w(origin) {
      return Sizable$w[origin] ?? null;
    }
    const parsedType$w = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$w = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input"
    };
    const error$w = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Yanlış dəyər: gözlənilən ${issue2.expected}, daxil olan ${parsedType$w(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Yanlış dəyər: gözlənilən ${stringifyPrimitive(issue2.values[0])}`;
          return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$w(issue2.origin);
          if (sizing)
            return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
          return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$w(issue2.origin);
          if (sizing)
            return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Yanlış mətn: "${_issue.prefix}" ilə başlamalıdır`;
          if (_issue.format === "ends_with")
            return `Yanlış mətn: "${_issue.suffix}" ilə bitməlidir`;
          if (_issue.format === "includes")
            return `Yanlış mətn: "${_issue.includes}" daxil olmalıdır`;
          if (_issue.format === "regex")
            return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;
          return `Yanlış ${Nouns$w[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Yanlış ədəd: ${issue2.divisor} ilə bölünə bilən olmalıdır`;
        case "unrecognized_keys":
          return `Tanınmayan açar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} daxilində yanlış açar`;
        case "invalid_union":
          return "Yanlış dəyər";
        case "invalid_element":
          return `${issue2.origin} daxilində yanlış dəyər`;
        default:
          return `Yanlış dəyər`;
      }
    };
    function az() {
      return {
        localeError: error$w
      };
    }
    function getBelarusianPlural(count2, one, few, many) {
      const absCount = Math.abs(count2);
      const lastDigit = absCount % 10;
      const lastTwoDigits = absCount % 100;
      if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
        return many;
      }
      if (lastDigit === 1) {
        return one;
      }
      if (lastDigit >= 2 && lastDigit <= 4) {
        return few;
      }
      return many;
    }
    const Sizable$v = {
      string: {
        unit: {
          one: "сімвал",
          few: "сімвалы",
          many: "сімвалаў"
        },
        verb: "мець"
      },
      array: {
        unit: {
          one: "элемент",
          few: "элементы",
          many: "элементаў"
        },
        verb: "мець"
      },
      set: {
        unit: {
          one: "элемент",
          few: "элементы",
          many: "элементаў"
        },
        verb: "мець"
      },
      file: {
        unit: {
          one: "байт",
          few: "байты",
          many: "байтаў"
        },
        verb: "мець"
      }
    };
    function getSizing$v(origin) {
      return Sizable$v[origin] ?? null;
    }
    const parsedType$v = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "лік";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "масіў";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$v = {
      regex: "увод",
      email: "email адрас",
      url: "URL",
      emoji: "эмодзі",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO дата і час",
      date: "ISO дата",
      time: "ISO час",
      duration: "ISO працягласць",
      ipv4: "IPv4 адрас",
      ipv6: "IPv6 адрас",
      cidrv4: "IPv4 дыяпазон",
      cidrv6: "IPv6 дыяпазон",
      base64: "радок у фармаце base64",
      base64url: "радок у фармаце base64url",
      json_string: "JSON радок",
      e164: "нумар E.164",
      jwt: "JWT",
      template_literal: "увод"
    };
    const error$v = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Няправільны ўвод: чакаўся ${issue2.expected}, атрымана ${parsedType$v(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Няправільны ўвод: чакалася ${stringifyPrimitive(issue2.values[0])}`;
          return `Няправільны варыянт: чакаўся адзін з ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$v(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна быць ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$v(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `Занадта малы: чакалася, што ${issue2.origin} павінна ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `Занадта малы: чакалася, што ${issue2.origin} павінна быць ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Няправільны радок: павінен пачынацца з "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Няправільны радок: павінен заканчвацца на "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Няправільны радок: павінен змяшчаць "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;
          return `Няправільны ${Nouns$v[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Няправільны лік: павінен быць кратным ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Нераспазнаны ${issue2.keys.length > 1 ? "ключы" : "ключ"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Няправільны ключ у ${issue2.origin}`;
        case "invalid_union":
          return "Няправільны ўвод";
        case "invalid_element":
          return `Няправільнае значэнне ў ${issue2.origin}`;
        default:
          return `Няправільны ўвод`;
      }
    };
    function be() {
      return {
        localeError: error$v
      };
    }
    const Sizable$u = {
      string: { unit: "caràcters", verb: "contenir" },
      file: { unit: "bytes", verb: "contenir" },
      array: { unit: "elements", verb: "contenir" },
      set: { unit: "elements", verb: "contenir" }
    };
    function getSizing$u(origin) {
      return Sizable$u[origin] ?? null;
    }
    const parsedType$u = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$u = {
      regex: "entrada",
      email: "adreça electrònica",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "durada ISO",
      ipv4: "adreça IPv4",
      ipv6: "adreça IPv6",
      cidrv4: "rang IPv4",
      cidrv6: "rang IPv6",
      base64: "cadena codificada en base64",
      base64url: "cadena codificada en base64url",
      json_string: "cadena JSON",
      e164: "número E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const error$u = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Tipus invàlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType$u(issue2.input)}`;
        // return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Valor invàlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
          return `Opció invàlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "com a màxim" : "menys de";
          const sizing = getSizing$u(issue2.origin);
          if (sizing)
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingués ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "com a mínim" : "més de";
          const sizing = getSizing$u(issue2.origin);
          if (sizing) {
            return `Massa petit: s'esperava que ${issue2.origin} contingués ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Format invàlid: ha de començar amb "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Format invàlid: ha d'acabar amb "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Format invàlid: ha d'incloure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;
          return `Format invàlid per a ${Nouns$u[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Número invàlid: ha de ser múltiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Clau invàlida a ${issue2.origin}`;
        case "invalid_union":
          return "Entrada invàlida";
        // Could also be "Tipus d'unió invàlid" but "Entrada invàlida" is more general
        case "invalid_element":
          return `Element invàlid a ${issue2.origin}`;
        default:
          return `Entrada invàlida`;
      }
    };
    function ca() {
      return {
        localeError: error$u
      };
    }
    const Sizable$t = {
      string: { unit: "znaků", verb: "mít" },
      file: { unit: "bajtů", verb: "mít" },
      array: { unit: "prvků", verb: "mít" },
      set: { unit: "prvků", verb: "mít" }
    };
    function getSizing$t(origin) {
      return Sizable$t[origin] ?? null;
    }
    const parsedType$t = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "číslo";
        }
        case "string": {
          return "řetězec";
        }
        case "boolean": {
          return "boolean";
        }
        case "bigint": {
          return "bigint";
        }
        case "function": {
          return "funkce";
        }
        case "symbol": {
          return "symbol";
        }
        case "undefined": {
          return "undefined";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "pole";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$t = {
      regex: "regulární výraz",
      email: "e-mailová adresa",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "datum a čas ve formátu ISO",
      date: "datum ve formátu ISO",
      time: "čas ve formátu ISO",
      duration: "doba trvání ISO",
      ipv4: "IPv4 adresa",
      ipv6: "IPv6 adresa",
      cidrv4: "rozsah IPv4",
      cidrv6: "rozsah IPv6",
      base64: "řetězec zakódovaný ve formátu base64",
      base64url: "řetězec zakódovaný ve formátu base64url",
      json_string: "řetězec ve formátu JSON",
      e164: "číslo E.164",
      jwt: "JWT",
      template_literal: "vstup"
    };
    const error$t = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Neplatný vstup: očekáváno ${issue2.expected}, obdrženo ${parsedType$t(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Neplatný vstup: očekáváno ${stringifyPrimitive(issue2.values[0])}`;
          return `Neplatná možnost: očekávána jedna z hodnot ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$t(issue2.origin);
          if (sizing) {
            return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvků"}`;
          }
          return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$t(issue2.origin);
          if (sizing) {
            return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvků"}`;
          }
          return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Neplatný řetězec: musí začínat na "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Neplatný řetězec: musí končit na "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Neplatný řetězec: musí obsahovat "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;
          return `Neplatný formát ${Nouns$t[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Neplatné číslo: musí být násobkem ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Neznámé klíče: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Neplatný klíč v ${issue2.origin}`;
        case "invalid_union":
          return "Neplatný vstup";
        case "invalid_element":
          return `Neplatná hodnota v ${issue2.origin}`;
        default:
          return `Neplatný vstup`;
      }
    };
    function cs() {
      return {
        localeError: error$t
      };
    }
    const Sizable$s = {
      string: { unit: "Zeichen", verb: "zu haben" },
      file: { unit: "Bytes", verb: "zu haben" },
      array: { unit: "Elemente", verb: "zu haben" },
      set: { unit: "Elemente", verb: "zu haben" }
    };
    function getSizing$s(origin) {
      return Sizable$s[origin] ?? null;
    }
    const parsedType$s = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "Zahl";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "Array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$s = {
      regex: "Eingabe",
      email: "E-Mail-Adresse",
      url: "URL",
      emoji: "Emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-Datum und -Uhrzeit",
      date: "ISO-Datum",
      time: "ISO-Uhrzeit",
      duration: "ISO-Dauer",
      ipv4: "IPv4-Adresse",
      ipv6: "IPv6-Adresse",
      cidrv4: "IPv4-Bereich",
      cidrv6: "IPv6-Bereich",
      base64: "Base64-codierter String",
      base64url: "Base64-URL-codierter String",
      json_string: "JSON-String",
      e164: "E.164-Nummer",
      jwt: "JWT",
      template_literal: "Eingabe"
    };
    const error$s = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Ungültige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType$s(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ungültige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
          return `Ungültige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$s(issue2.origin);
          if (sizing)
            return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
          return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$s(issue2.origin);
          if (sizing) {
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
          }
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ungültiger String: muss mit "${_issue.prefix}" beginnen`;
          if (_issue.format === "ends_with")
            return `Ungültiger String: muss mit "${_issue.suffix}" enden`;
          if (_issue.format === "includes")
            return `Ungültiger String: muss "${_issue.includes}" enthalten`;
          if (_issue.format === "regex")
            return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;
          return `Ungültig: ${Nouns$s[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ungültige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ungültiger Schlüssel in ${issue2.origin}`;
        case "invalid_union":
          return "Ungültige Eingabe";
        case "invalid_element":
          return `Ungültiger Wert in ${issue2.origin}`;
        default:
          return `Ungültige Eingabe`;
      }
    };
    function de() {
      return {
        localeError: error$s
      };
    }
    const Sizable$r = {
      string: { unit: "characters", verb: "to have" },
      file: { unit: "bytes", verb: "to have" },
      array: { unit: "items", verb: "to have" },
      set: { unit: "items", verb: "to have" }
    };
    function getSizing$r(origin) {
      return Sizable$r[origin] ?? null;
    }
    const parsedType$r = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$r = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input"
    };
    const error$r = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Invalid input: expected ${issue2.expected}, received ${parsedType$r(issue2.input)}`;
        // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
          return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$r(issue2.origin);
          if (sizing)
            return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$r(issue2.origin);
          if (sizing) {
            return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Invalid string: must start with "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Invalid string: must end with "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Invalid string: must include "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Invalid string: must match pattern ${_issue.pattern}`;
          return `Invalid ${Nouns$r[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Invalid number: must be a multiple of ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Invalid key in ${issue2.origin}`;
        case "invalid_union":
          return "Invalid input";
        case "invalid_element":
          return `Invalid value in ${issue2.origin}`;
        default:
          return `Invalid input`;
      }
    };
    function en() {
      return {
        localeError: error$r
      };
    }
    const Sizable$q = {
      string: { unit: "caracteres", verb: "tener" },
      file: { unit: "bytes", verb: "tener" },
      array: { unit: "elementos", verb: "tener" },
      set: { unit: "elementos", verb: "tener" }
    };
    function getSizing$q(origin) {
      return Sizable$q[origin] ?? null;
    }
    const parsedType$q = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "número";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "arreglo";
          }
          if (data2 === null) {
            return "nulo";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$q = {
      regex: "entrada",
      email: "dirección de correo electrónico",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "fecha y hora ISO",
      date: "fecha ISO",
      time: "hora ISO",
      duration: "duración ISO",
      ipv4: "dirección IPv4",
      ipv6: "dirección IPv6",
      cidrv4: "rango IPv4",
      cidrv6: "rango IPv6",
      base64: "cadena codificada en base64",
      base64url: "URL codificada en base64",
      json_string: "cadena JSON",
      e164: "número E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const error$q = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Entrada inválida: se esperaba ${issue2.expected}, recibido ${parsedType$q(issue2.input)}`;
        // return `Entrada inválida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrada inválida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
          return `Opción inválida: se esperaba una de ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$q(issue2.origin);
          if (sizing)
            return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$q(issue2.origin);
          if (sizing) {
            return `Demasiado pequeño: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Demasiado pequeño: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Cadena inválida: debe comenzar con "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Cadena inválida: debe terminar en "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cadena inválida: debe incluir "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;
          return `Inválido ${Nouns$q[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Número inválido: debe ser múltiplo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Llave inválida en ${issue2.origin}`;
        case "invalid_union":
          return "Entrada inválida";
        case "invalid_element":
          return `Valor inválido en ${issue2.origin}`;
        default:
          return `Entrada inválida`;
      }
    };
    function es() {
      return {
        localeError: error$q
      };
    }
    const Sizable$p = {
      string: { unit: "کاراکتر", verb: "داشته باشد" },
      file: { unit: "بایت", verb: "داشته باشد" },
      array: { unit: "آیتم", verb: "داشته باشد" },
      set: { unit: "آیتم", verb: "داشته باشد" }
    };
    function getSizing$p(origin) {
      return Sizable$p[origin] ?? null;
    }
    const parsedType$p = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "عدد";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "آرایه";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$p = {
      regex: "ورودی",
      email: "آدرس ایمیل",
      url: "URL",
      emoji: "ایموجی",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "تاریخ و زمان ایزو",
      date: "تاریخ ایزو",
      time: "زمان ایزو",
      duration: "مدت زمان ایزو",
      ipv4: "IPv4 آدرس",
      ipv6: "IPv6 آدرس",
      cidrv4: "IPv4 دامنه",
      cidrv6: "IPv6 دامنه",
      base64: "base64-encoded رشته",
      base64url: "base64url-encoded رشته",
      json_string: "JSON رشته",
      e164: "E.164 عدد",
      jwt: "JWT",
      template_literal: "ورودی"
    };
    const error$p = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `ورودی نامعتبر: می‌بایست ${issue2.expected} می‌بود، ${parsedType$p(issue2.input)} دریافت شد`;
        case "invalid_value":
          if (issue2.values.length === 1) {
            return `ورودی نامعتبر: می‌بایست ${stringifyPrimitive(issue2.values[0])} می‌بود`;
          }
          return `گزینه نامعتبر: می‌بایست یکی از ${joinValues(issue2.values, "|")} می‌بود`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$p(issue2.origin);
          if (sizing) {
            return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"} باشد`;
          }
          return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} باشد`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$p(issue2.origin);
          if (sizing) {
            return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} باشد`;
          }
          return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} باشد`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `رشته نامعتبر: باید با "${_issue.prefix}" شروع شود`;
          }
          if (_issue.format === "ends_with") {
            return `رشته نامعتبر: باید با "${_issue.suffix}" تمام شود`;
          }
          if (_issue.format === "includes") {
            return `رشته نامعتبر: باید شامل "${_issue.includes}" باشد`;
          }
          if (_issue.format === "regex") {
            return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;
          }
          return `${Nouns$p[_issue.format] ?? issue2.format} نامعتبر`;
        }
        case "not_multiple_of":
          return `عدد نامعتبر: باید مضرب ${issue2.divisor} باشد`;
        case "unrecognized_keys":
          return `کلید${issue2.keys.length > 1 ? "های" : ""} ناشناس: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `کلید ناشناس در ${issue2.origin}`;
        case "invalid_union":
          return `ورودی نامعتبر`;
        case "invalid_element":
          return `مقدار نامعتبر در ${issue2.origin}`;
        default:
          return `ورودی نامعتبر`;
      }
    };
    function fa() {
      return {
        localeError: error$p
      };
    }
    const Sizable$o = {
      string: { unit: "merkkiä", subject: "merkkijonon" },
      file: { unit: "tavua", subject: "tiedoston" },
      array: { unit: "alkiota", subject: "listan" },
      set: { unit: "alkiota", subject: "joukon" },
      number: { unit: "", subject: "luvun" },
      bigint: { unit: "", subject: "suuren kokonaisluvun" },
      int: { unit: "", subject: "kokonaisluvun" },
      date: { unit: "", subject: "päivämäärän" }
    };
    function getSizing$o(origin) {
      return Sizable$o[origin] ?? null;
    }
    const parsedType$o = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$o = {
      regex: "säännöllinen lauseke",
      email: "sähköpostiosoite",
      url: "URL-osoite",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-aikaleima",
      date: "ISO-päivämäärä",
      time: "ISO-aika",
      duration: "ISO-kesto",
      ipv4: "IPv4-osoite",
      ipv6: "IPv6-osoite",
      cidrv4: "IPv4-alue",
      cidrv6: "IPv6-alue",
      base64: "base64-koodattu merkkijono",
      base64url: "base64url-koodattu merkkijono",
      json_string: "JSON-merkkijono",
      e164: "E.164-luku",
      jwt: "JWT",
      template_literal: "templaattimerkkijono"
    };
    const error$o = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType$o(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Virheellinen syöte: täytyy olla ${stringifyPrimitive(issue2.values[0])}`;
          return `Virheellinen valinta: täytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$o(issue2.origin);
          if (sizing) {
            return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
          }
          return `Liian suuri: arvon täytyy olla ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$o(issue2.origin);
          if (sizing) {
            return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
          }
          return `Liian pieni: arvon täytyy olla ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Virheellinen syöte: täytyy alkaa "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Virheellinen syöte: täytyy loppua "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Virheellinen syöte: täytyy sisältää "${_issue.includes}"`;
          if (_issue.format === "regex") {
            return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;
          }
          return `Virheellinen ${Nouns$o[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Virheellinen luku: täytyy olla luvun ${issue2.divisor} monikerta`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return "Virheellinen avain tietueessa";
        case "invalid_union":
          return "Virheellinen unioni";
        case "invalid_element":
          return "Virheellinen arvo joukossa";
        default:
          return `Virheellinen syöte`;
      }
    };
    function fi() {
      return {
        localeError: error$o
      };
    }
    const Sizable$n = {
      string: { unit: "caractères", verb: "avoir" },
      file: { unit: "octets", verb: "avoir" },
      array: { unit: "éléments", verb: "avoir" },
      set: { unit: "éléments", verb: "avoir" }
    };
    function getSizing$n(origin) {
      return Sizable$n[origin] ?? null;
    }
    const parsedType$n = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "nombre";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "tableau";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$n = {
      regex: "entrée",
      email: "adresse e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date et heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "durée ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "chaîne encodée en base64",
      base64url: "chaîne encodée en base64url",
      json_string: "chaîne JSON",
      e164: "numéro E.164",
      jwt: "JWT",
      template_literal: "entrée"
    };
    const error$n = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Entrée invalide : ${issue2.expected} attendu, ${parsedType$n(issue2.input)} reçu`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrée invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
          return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$n(issue2.origin);
          if (sizing)
            return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "élément(s)"}`;
          return `Trop grand : ${issue2.origin ?? "valeur"} doit être ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$n(issue2.origin);
          if (sizing) {
            return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Trop petit : ${issue2.origin} doit être ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Chaîne invalide : doit inclure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;
          return `${Nouns$n[_issue.format] ?? issue2.format} invalide`;
        }
        case "not_multiple_of":
          return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Clé invalide dans ${issue2.origin}`;
        case "invalid_union":
          return "Entrée invalide";
        case "invalid_element":
          return `Valeur invalide dans ${issue2.origin}`;
        default:
          return `Entrée invalide`;
      }
    };
    function fr() {
      return {
        localeError: error$n
      };
    }
    const Sizable$m = {
      string: { unit: "caractères", verb: "avoir" },
      file: { unit: "octets", verb: "avoir" },
      array: { unit: "éléments", verb: "avoir" },
      set: { unit: "éléments", verb: "avoir" }
    };
    function getSizing$m(origin) {
      return Sizable$m[origin] ?? null;
    }
    const parsedType$m = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$m = {
      regex: "entrée",
      email: "adresse courriel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date-heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "durée ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "chaîne encodée en base64",
      base64url: "chaîne encodée en base64url",
      json_string: "chaîne JSON",
      e164: "numéro E.164",
      jwt: "JWT",
      template_literal: "entrée"
    };
    const error$m = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Entrée invalide : attendu ${issue2.expected}, reçu ${parsedType$m(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrée invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
          return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "≤" : "<";
          const sizing = getSizing$m(issue2.origin);
          if (sizing)
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "≥" : ">";
          const sizing = getSizing$m(issue2.origin);
          if (sizing) {
            return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Chaîne invalide : doit inclure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;
          return `${Nouns$m[_issue.format] ?? issue2.format} invalide`;
        }
        case "not_multiple_of":
          return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Clé invalide dans ${issue2.origin}`;
        case "invalid_union":
          return "Entrée invalide";
        case "invalid_element":
          return `Valeur invalide dans ${issue2.origin}`;
        default:
          return `Entrée invalide`;
      }
    };
    function frCA() {
      return {
        localeError: error$m
      };
    }
    const Sizable$l = {
      string: { unit: "אותיות", verb: "לכלול" },
      file: { unit: "בייטים", verb: "לכלול" },
      array: { unit: "פריטים", verb: "לכלול" },
      set: { unit: "פריטים", verb: "לכלול" }
    };
    function getSizing$l(origin) {
      return Sizable$l[origin] ?? null;
    }
    const parsedType$l = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$l = {
      regex: "קלט",
      email: "כתובת אימייל",
      url: "כתובת רשת",
      emoji: "אימוג'י",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "תאריך וזמן ISO",
      date: "תאריך ISO",
      time: "זמן ISO",
      duration: "משך זמן ISO",
      ipv4: "כתובת IPv4",
      ipv6: "כתובת IPv6",
      cidrv4: "טווח IPv4",
      cidrv6: "טווח IPv6",
      base64: "מחרוזת בבסיס 64",
      base64url: "מחרוזת בבסיס 64 לכתובות רשת",
      json_string: "מחרוזת JSON",
      e164: "מספר E.164",
      jwt: "JWT",
      template_literal: "קלט"
    };
    const error$l = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `קלט לא תקין: צריך ${issue2.expected}, התקבל ${parsedType$l(issue2.input)}`;
        // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `קלט לא תקין: צריך ${stringifyPrimitive(issue2.values[0])}`;
          return `קלט לא תקין: צריך אחת מהאפשרויות  ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$l(issue2.origin);
          if (sizing)
            return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$l(issue2.origin);
          if (sizing) {
            return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `מחרוזת לא תקינה: חייבת להתחיל ב"${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `מחרוזת לא תקינה: חייבת להסתיים ב "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `מחרוזת לא תקינה: חייבת לכלול "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${_issue.pattern}`;
          return `${Nouns$l[_issue.format] ?? issue2.format} לא תקין`;
        }
        case "not_multiple_of":
          return `מספר לא תקין: חייב להיות מכפלה של ${issue2.divisor}`;
        case "unrecognized_keys":
          return `מפתח${issue2.keys.length > 1 ? "ות" : ""} לא מזוה${issue2.keys.length > 1 ? "ים" : "ה"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `מפתח לא תקין ב${issue2.origin}`;
        case "invalid_union":
          return "קלט לא תקין";
        case "invalid_element":
          return `ערך לא תקין ב${issue2.origin}`;
        default:
          return `קלט לא תקין`;
      }
    };
    function he() {
      return {
        localeError: error$l
      };
    }
    const Sizable$k = {
      string: { unit: "karakter", verb: "legyen" },
      file: { unit: "byte", verb: "legyen" },
      array: { unit: "elem", verb: "legyen" },
      set: { unit: "elem", verb: "legyen" }
    };
    function getSizing$k(origin) {
      return Sizable$k[origin] ?? null;
    }
    const parsedType$k = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "szám";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "tömb";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$k = {
      regex: "bemenet",
      email: "email cím",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO időbélyeg",
      date: "ISO dátum",
      time: "ISO idő",
      duration: "ISO időintervallum",
      ipv4: "IPv4 cím",
      ipv6: "IPv6 cím",
      cidrv4: "IPv4 tartomány",
      cidrv6: "IPv6 tartomány",
      base64: "base64-kódolt string",
      base64url: "base64url-kódolt string",
      json_string: "JSON string",
      e164: "E.164 szám",
      jwt: "JWT",
      template_literal: "bemenet"
    };
    const error$k = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Érvénytelen bemenet: a várt érték ${issue2.expected}, a kapott érték ${parsedType$k(issue2.input)}`;
        // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Érvénytelen bemenet: a várt érték ${stringifyPrimitive(issue2.values[0])}`;
          return `Érvénytelen opció: valamelyik érték várt ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$k(issue2.origin);
          if (sizing)
            return `Túl nagy: ${issue2.origin ?? "érték"} mérete túl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
          return `Túl nagy: a bemeneti érték ${issue2.origin ?? "érték"} túl nagy: ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$k(issue2.origin);
          if (sizing) {
            return `Túl kicsi: a bemeneti érték ${issue2.origin} mérete túl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Túl kicsi: a bemeneti érték ${issue2.origin} túl kicsi ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Érvénytelen string: "${_issue.prefix}" értékkel kell kezdődnie`;
          if (_issue.format === "ends_with")
            return `Érvénytelen string: "${_issue.suffix}" értékkel kell végződnie`;
          if (_issue.format === "includes")
            return `Érvénytelen string: "${_issue.includes}" értéket kell tartalmaznia`;
          if (_issue.format === "regex")
            return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;
          return `Érvénytelen ${Nouns$k[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Érvénytelen szám: ${issue2.divisor} többszörösének kell lennie`;
        case "unrecognized_keys":
          return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Érvénytelen kulcs ${issue2.origin}`;
        case "invalid_union":
          return "Érvénytelen bemenet";
        case "invalid_element":
          return `Érvénytelen érték: ${issue2.origin}`;
        default:
          return `Érvénytelen bemenet`;
      }
    };
    function hu() {
      return {
        localeError: error$k
      };
    }
    const Sizable$j = {
      string: { unit: "karakter", verb: "memiliki" },
      file: { unit: "byte", verb: "memiliki" },
      array: { unit: "item", verb: "memiliki" },
      set: { unit: "item", verb: "memiliki" }
    };
    function getSizing$j(origin) {
      return Sizable$j[origin] ?? null;
    }
    const parsedType$j = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$j = {
      regex: "input",
      email: "alamat email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tanggal dan waktu format ISO",
      date: "tanggal format ISO",
      time: "jam format ISO",
      duration: "durasi format ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "rentang alamat IPv4",
      cidrv6: "rentang alamat IPv6",
      base64: "string dengan enkode base64",
      base64url: "string dengan enkode base64url",
      json_string: "string JSON",
      e164: "angka E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const error$j = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType$j(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
          return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$j(issue2.origin);
          if (sizing)
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$j(issue2.origin);
          if (sizing) {
            return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `String tidak valid: harus menyertakan "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
          return `${Nouns$j[_issue.format] ?? issue2.format} tidak valid`;
        }
        case "not_multiple_of":
          return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kunci tidak valid di ${issue2.origin}`;
        case "invalid_union":
          return "Input tidak valid";
        case "invalid_element":
          return `Nilai tidak valid di ${issue2.origin}`;
        default:
          return `Input tidak valid`;
      }
    };
    function id() {
      return {
        localeError: error$j
      };
    }
    const Sizable$i = {
      string: { unit: "caratteri", verb: "avere" },
      file: { unit: "byte", verb: "avere" },
      array: { unit: "elementi", verb: "avere" },
      set: { unit: "elementi", verb: "avere" }
    };
    function getSizing$i(origin) {
      return Sizable$i[origin] ?? null;
    }
    const parsedType$i = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "numero";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "vettore";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$i = {
      regex: "input",
      email: "indirizzo email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e ora ISO",
      date: "data ISO",
      time: "ora ISO",
      duration: "durata ISO",
      ipv4: "indirizzo IPv4",
      ipv6: "indirizzo IPv6",
      cidrv4: "intervallo IPv4",
      cidrv6: "intervallo IPv6",
      base64: "stringa codificata in base64",
      base64url: "URL codificata in base64",
      json_string: "stringa JSON",
      e164: "numero E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const error$i = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType$i(issue2.input)}`;
        // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
          return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$i(issue2.origin);
          if (sizing)
            return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
          return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$i(issue2.origin);
          if (sizing) {
            return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Stringa non valida: deve includere "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
          return `Invalid ${Nouns$i[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Chiave non valida in ${issue2.origin}`;
        case "invalid_union":
          return "Input non valido";
        case "invalid_element":
          return `Valore non valido in ${issue2.origin}`;
        default:
          return `Input non valido`;
      }
    };
    function it() {
      return {
        localeError: error$i
      };
    }
    const Sizable$h = {
      string: { unit: "文字", verb: "である" },
      file: { unit: "バイト", verb: "である" },
      array: { unit: "要素", verb: "である" },
      set: { unit: "要素", verb: "である" }
    };
    function getSizing$h(origin) {
      return Sizable$h[origin] ?? null;
    }
    const parsedType$h = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "数値";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "配列";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$h = {
      regex: "入力値",
      email: "メールアドレス",
      url: "URL",
      emoji: "絵文字",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO日時",
      date: "ISO日付",
      time: "ISO時刻",
      duration: "ISO期間",
      ipv4: "IPv4アドレス",
      ipv6: "IPv6アドレス",
      cidrv4: "IPv4範囲",
      cidrv6: "IPv6範囲",
      base64: "base64エンコード文字列",
      base64url: "base64urlエンコード文字列",
      json_string: "JSON文字列",
      e164: "E.164番号",
      jwt: "JWT",
      template_literal: "入力値"
    };
    const error$h = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `無効な入力: ${issue2.expected}が期待されましたが、${parsedType$h(issue2.input)}が入力されました`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `無効な入力: ${stringifyPrimitive(issue2.values[0])}が期待されました`;
          return `無効な選択: ${joinValues(issue2.values, "、")}のいずれかである必要があります`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$h(issue2.origin);
          if (sizing)
            return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${sizing.unit ?? "要素"}${adj}である必要があります`;
          return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${adj}である必要があります`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$h(issue2.origin);
          if (sizing)
            return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${sizing.unit}${adj}である必要があります`;
          return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${adj}である必要があります`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `無効な文字列: "${_issue.prefix}"で始まる必要があります`;
          if (_issue.format === "ends_with")
            return `無効な文字列: "${_issue.suffix}"で終わる必要があります`;
          if (_issue.format === "includes")
            return `無効な文字列: "${_issue.includes}"を含む必要があります`;
          if (_issue.format === "regex")
            return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;
          return `無効な${Nouns$h[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `無効な数値: ${issue2.divisor}の倍数である必要があります`;
        case "unrecognized_keys":
          return `認識されていないキー${issue2.keys.length > 1 ? "群" : ""}: ${joinValues(issue2.keys, "、")}`;
        case "invalid_key":
          return `${issue2.origin}内の無効なキー`;
        case "invalid_union":
          return "無効な入力";
        case "invalid_element":
          return `${issue2.origin}内の無効な値`;
        default:
          return `無効な入力`;
      }
    };
    function ja() {
      return {
        localeError: error$h
      };
    }
    const Sizable$g = {
      string: { unit: "문자", verb: "to have" },
      file: { unit: "바이트", verb: "to have" },
      array: { unit: "개", verb: "to have" },
      set: { unit: "개", verb: "to have" }
    };
    function getSizing$g(origin) {
      return Sizable$g[origin] ?? null;
    }
    const parsedType$g = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$g = {
      regex: "입력",
      email: "이메일 주소",
      url: "URL",
      emoji: "이모지",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO 날짜시간",
      date: "ISO 날짜",
      time: "ISO 시간",
      duration: "ISO 기간",
      ipv4: "IPv4 주소",
      ipv6: "IPv6 주소",
      cidrv4: "IPv4 범위",
      cidrv6: "IPv6 범위",
      base64: "base64 인코딩 문자열",
      base64url: "base64url 인코딩 문자열",
      json_string: "JSON 문자열",
      e164: "E.164 번호",
      jwt: "JWT",
      template_literal: "입력"
    };
    const error$g = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `잘못된 입력: 예상 타입은 ${issue2.expected}, 받은 타입은 ${parsedType$g(issue2.input)}입니다`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `잘못된 입력: 값은 ${stringifyPrimitive(issue2.values[0])} 이어야 합니다`;
          return `잘못된 옵션: ${joinValues(issue2.values, "또는 ")} 중 하나여야 합니다`;
        case "too_big": {
          const adj = issue2.inclusive ? "이하" : "미만";
          const suffix = adj === "미만" ? "이어야 합니다" : "여야 합니다";
          const sizing = getSizing$g(issue2.origin);
          const unit = (sizing == null ? void 0 : sizing.unit) ?? "요소";
          if (sizing)
            return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
          return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()} ${adj}${suffix}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "이상" : "초과";
          const suffix = adj === "이상" ? "이어야 합니다" : "여야 합니다";
          const sizing = getSizing$g(issue2.origin);
          const unit = (sizing == null ? void 0 : sizing.unit) ?? "요소";
          if (sizing) {
            return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
          }
          return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()} ${adj}${suffix}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `잘못된 문자열: "${_issue.prefix}"(으)로 시작해야 합니다`;
          }
          if (_issue.format === "ends_with")
            return `잘못된 문자열: "${_issue.suffix}"(으)로 끝나야 합니다`;
          if (_issue.format === "includes")
            return `잘못된 문자열: "${_issue.includes}"을(를) 포함해야 합니다`;
          if (_issue.format === "regex")
            return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;
          return `잘못된 ${Nouns$g[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `잘못된 숫자: ${issue2.divisor}의 배수여야 합니다`;
        case "unrecognized_keys":
          return `인식할 수 없는 키: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `잘못된 키: ${issue2.origin}`;
        case "invalid_union":
          return `잘못된 입력`;
        case "invalid_element":
          return `잘못된 값: ${issue2.origin}`;
        default:
          return `잘못된 입력`;
      }
    };
    function ko() {
      return {
        localeError: error$g
      };
    }
    const Sizable$f = {
      string: { unit: "знаци", verb: "да имаат" },
      file: { unit: "бајти", verb: "да имаат" },
      array: { unit: "ставки", verb: "да имаат" },
      set: { unit: "ставки", verb: "да имаат" }
    };
    function getSizing$f(origin) {
      return Sizable$f[origin] ?? null;
    }
    const parsedType$f = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "број";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "низа";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$f = {
      regex: "внес",
      email: "адреса на е-пошта",
      url: "URL",
      emoji: "емоџи",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO датум и време",
      date: "ISO датум",
      time: "ISO време",
      duration: "ISO времетраење",
      ipv4: "IPv4 адреса",
      ipv6: "IPv6 адреса",
      cidrv4: "IPv4 опсег",
      cidrv6: "IPv6 опсег",
      base64: "base64-енкодирана низа",
      base64url: "base64url-енкодирана низа",
      json_string: "JSON низа",
      e164: "E.164 број",
      jwt: "JWT",
      template_literal: "внес"
    };
    const error$f = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Грешен внес: се очекува ${issue2.expected}, примено ${parsedType$f(issue2.input)}`;
        // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
          return `Грешана опција: се очекува една ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$f(issue2.origin);
          if (sizing)
            return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да има ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементи"}`;
          return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да биде ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$f(issue2.origin);
          if (sizing) {
            return `Премногу мал: се очекува ${issue2.origin} да има ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Премногу мал: се очекува ${issue2.origin} да биде ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Неважечка низа: мора да започнува со "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Неважечка низа: мора да завршува со "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Неважечка низа: мора да вклучува "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;
          return `Invalid ${Nouns$f[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Грешен број: мора да биде делив со ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Грешен клуч во ${issue2.origin}`;
        case "invalid_union":
          return "Грешен внес";
        case "invalid_element":
          return `Грешна вредност во ${issue2.origin}`;
        default:
          return `Грешен внес`;
      }
    };
    function mk() {
      return {
        localeError: error$f
      };
    }
    const Sizable$e = {
      string: { unit: "aksara", verb: "mempunyai" },
      file: { unit: "bait", verb: "mempunyai" },
      array: { unit: "elemen", verb: "mempunyai" },
      set: { unit: "elemen", verb: "mempunyai" }
    };
    function getSizing$e(origin) {
      return Sizable$e[origin] ?? null;
    }
    const parsedType$e = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "nombor";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$e = {
      regex: "input",
      email: "alamat e-mel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tarikh masa ISO",
      date: "tarikh ISO",
      time: "masa ISO",
      duration: "tempoh ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "julat IPv4",
      cidrv6: "julat IPv6",
      base64: "string dikodkan base64",
      base64url: "string dikodkan base64url",
      json_string: "string JSON",
      e164: "nombor E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const error$e = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType$e(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
          return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$e(issue2.origin);
          if (sizing)
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$e(issue2.origin);
          if (sizing) {
            return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
          return `${Nouns$e[_issue.format] ?? issue2.format} tidak sah`;
        }
        case "not_multiple_of":
          return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kunci tidak sah dalam ${issue2.origin}`;
        case "invalid_union":
          return "Input tidak sah";
        case "invalid_element":
          return `Nilai tidak sah dalam ${issue2.origin}`;
        default:
          return `Input tidak sah`;
      }
    };
    function ms() {
      return {
        localeError: error$e
      };
    }
    const Sizable$d = {
      string: { unit: "tegn", verb: "å ha" },
      file: { unit: "bytes", verb: "å ha" },
      array: { unit: "elementer", verb: "å inneholde" },
      set: { unit: "elementer", verb: "å inneholde" }
    };
    function getSizing$d(origin) {
      return Sizable$d[origin] ?? null;
    }
    const parsedType$d = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "tall";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "liste";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$d = {
      regex: "input",
      email: "e-postadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkeslett",
      date: "ISO-dato",
      time: "ISO-klokkeslett",
      duration: "ISO-varighet",
      ipv4: "IPv4-område",
      ipv6: "IPv6-område",
      cidrv4: "IPv4-spekter",
      cidrv6: "IPv6-spekter",
      base64: "base64-enkodet streng",
      base64url: "base64url-enkodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input"
    };
    const error$d = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType$d(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
          return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$d(issue2.origin);
          if (sizing)
            return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
          return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$d(issue2.origin);
          if (sizing) {
            return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ugyldig streng: må starte med "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Ugyldig streng: må ende med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ugyldig streng: må inneholde "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;
          return `Ugyldig ${Nouns$d[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ugyldig tall: må være et multiplum av ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ugyldig nøkkel i ${issue2.origin}`;
        case "invalid_union":
          return "Ugyldig input";
        case "invalid_element":
          return `Ugyldig verdi i ${issue2.origin}`;
        default:
          return `Ugyldig input`;
      }
    };
    function no() {
      return {
        localeError: error$d
      };
    }
    const Sizable$c = {
      string: { unit: "harf", verb: "olmalıdır" },
      file: { unit: "bayt", verb: "olmalıdır" },
      array: { unit: "unsur", verb: "olmalıdır" },
      set: { unit: "unsur", verb: "olmalıdır" }
    };
    function getSizing$c(origin) {
      return Sizable$c[origin] ?? null;
    }
    const parsedType$c = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "numara";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "saf";
          }
          if (data2 === null) {
            return "gayb";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$c = {
      regex: "giren",
      email: "epostagâh",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO hengâmı",
      date: "ISO tarihi",
      time: "ISO zamanı",
      duration: "ISO müddeti",
      ipv4: "IPv4 nişânı",
      ipv6: "IPv6 nişânı",
      cidrv4: "IPv4 menzili",
      cidrv6: "IPv6 menzili",
      base64: "base64-şifreli metin",
      base64url: "base64url-şifreli metin",
      json_string: "JSON metin",
      e164: "E.164 sayısı",
      jwt: "JWT",
      template_literal: "giren"
    };
    const error$c = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Fâsit giren: umulan ${issue2.expected}, alınan ${parsedType$c(issue2.input)}`;
        // return `Fâsit giren: umulan ${issue.expected}, alınan ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Fâsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
          return `Fâsit tercih: mûteberler ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$c(issue2.origin);
          if (sizing)
            return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalıydı.`;
          return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalıydı.`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$c(issue2.origin);
          if (sizing) {
            return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;
          }
          return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalıydı.`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Fâsit metin: "${_issue.prefix}" ile başlamalı.`;
          if (_issue.format === "ends_with")
            return `Fâsit metin: "${_issue.suffix}" ile bitmeli.`;
          if (_issue.format === "includes")
            return `Fâsit metin: "${_issue.includes}" ihtivâ etmeli.`;
          if (_issue.format === "regex")
            return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;
          return `Fâsit ${Nouns$c[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Fâsit sayı: ${issue2.divisor} katı olmalıydı.`;
        case "unrecognized_keys":
          return `Tanınmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} için tanınmayan anahtar var.`;
        case "invalid_union":
          return "Giren tanınamadı.";
        case "invalid_element":
          return `${issue2.origin} için tanınmayan kıymet var.`;
        default:
          return `Kıymet tanınamadı.`;
      }
    };
    function ota() {
      return {
        localeError: error$c
      };
    }
    const Sizable$b = {
      string: { unit: "znaków", verb: "mieć" },
      file: { unit: "bajtów", verb: "mieć" },
      array: { unit: "elementów", verb: "mieć" },
      set: { unit: "elementów", verb: "mieć" }
    };
    function getSizing$b(origin) {
      return Sizable$b[origin] ?? null;
    }
    const parsedType$b = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "liczba";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "tablica";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$b = {
      regex: "wyrażenie",
      email: "adres email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i godzina w formacie ISO",
      date: "data w formacie ISO",
      time: "godzina w formacie ISO",
      duration: "czas trwania ISO",
      ipv4: "adres IPv4",
      ipv6: "adres IPv6",
      cidrv4: "zakres IPv4",
      cidrv6: "zakres IPv6",
      base64: "ciąg znaków zakodowany w formacie base64",
      base64url: "ciąg znaków zakodowany w formacie base64url",
      json_string: "ciąg znaków w formacie JSON",
      e164: "liczba E.164",
      jwt: "JWT",
      template_literal: "wejście"
    };
    const error$b = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Nieprawidłowe dane wejściowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType$b(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Nieprawidłowe dane wejściowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
          return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$b(issue2.origin);
          if (sizing) {
            return `Za duża wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementów"}`;
          }
          return `Zbyt duż(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$b(issue2.origin);
          if (sizing) {
            return `Za mała wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementów"}`;
          }
          return `Zbyt mał(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Nieprawidłowy ciąg znaków: musi zaczynać się od "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Nieprawidłowy ciąg znaków: musi kończyć się na "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Nieprawidłowy ciąg znaków: musi zawierać "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;
          return `Nieprawidłow(y/a/e) ${Nouns$b[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Nieprawidłowa liczba: musi być wielokrotnością ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Nieprawidłowy klucz w ${issue2.origin}`;
        case "invalid_union":
          return "Nieprawidłowe dane wejściowe";
        case "invalid_element":
          return `Nieprawidłowa wartość w ${issue2.origin}`;
        default:
          return `Nieprawidłowe dane wejściowe`;
      }
    };
    function pl() {
      return {
        localeError: error$b
      };
    }
    const Sizable$a = {
      string: { unit: "caracteres", verb: "ter" },
      file: { unit: "bytes", verb: "ter" },
      array: { unit: "itens", verb: "ter" },
      set: { unit: "itens", verb: "ter" }
    };
    function getSizing$a(origin) {
      return Sizable$a[origin] ?? null;
    }
    const parsedType$a = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "número";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "nulo";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$a = {
      regex: "padrão",
      email: "endereço de e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "duração ISO",
      ipv4: "endereço IPv4",
      ipv6: "endereço IPv6",
      cidrv4: "faixa de IPv4",
      cidrv6: "faixa de IPv6",
      base64: "texto codificado em base64",
      base64url: "URL codificada em base64",
      json_string: "texto JSON",
      e164: "número E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const error$a = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Tipo inválido: esperado ${issue2.expected}, recebido ${parsedType$a(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrada inválida: esperado ${stringifyPrimitive(issue2.values[0])}`;
          return `Opção inválida: esperada uma das ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$a(issue2.origin);
          if (sizing)
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$a(issue2.origin);
          if (sizing) {
            return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Texto inválido: deve começar com "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Texto inválido: deve terminar com "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Texto inválido: deve incluir "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;
          return `${Nouns$a[_issue.format] ?? issue2.format} inválido`;
        }
        case "not_multiple_of":
          return `Número inválido: deve ser múltiplo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Chave inválida em ${issue2.origin}`;
        case "invalid_union":
          return "Entrada inválida";
        case "invalid_element":
          return `Valor inválido em ${issue2.origin}`;
        default:
          return `Campo inválido`;
      }
    };
    function pt() {
      return {
        localeError: error$a
      };
    }
    function getRussianPlural(count2, one, few, many) {
      const absCount = Math.abs(count2);
      const lastDigit = absCount % 10;
      const lastTwoDigits = absCount % 100;
      if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
        return many;
      }
      if (lastDigit === 1) {
        return one;
      }
      if (lastDigit >= 2 && lastDigit <= 4) {
        return few;
      }
      return many;
    }
    const Sizable$9 = {
      string: {
        unit: {
          one: "символ",
          few: "символа",
          many: "символов"
        },
        verb: "иметь"
      },
      file: {
        unit: {
          one: "байт",
          few: "байта",
          many: "байт"
        },
        verb: "иметь"
      },
      array: {
        unit: {
          one: "элемент",
          few: "элемента",
          many: "элементов"
        },
        verb: "иметь"
      },
      set: {
        unit: {
          one: "элемент",
          few: "элемента",
          many: "элементов"
        },
        verb: "иметь"
      }
    };
    function getSizing$9(origin) {
      return Sizable$9[origin] ?? null;
    }
    const parsedType$9 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "число";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "массив";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$9 = {
      regex: "ввод",
      email: "email адрес",
      url: "URL",
      emoji: "эмодзи",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO дата и время",
      date: "ISO дата",
      time: "ISO время",
      duration: "ISO длительность",
      ipv4: "IPv4 адрес",
      ipv6: "IPv6 адрес",
      cidrv4: "IPv4 диапазон",
      cidrv6: "IPv6 диапазон",
      base64: "строка в формате base64",
      base64url: "строка в формате base64url",
      json_string: "JSON строка",
      e164: "номер E.164",
      jwt: "JWT",
      template_literal: "ввод"
    };
    const error$9 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Неверный ввод: ожидалось ${issue2.expected}, получено ${parsedType$9(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Неверный ввод: ожидалось ${stringifyPrimitive(issue2.values[0])}`;
          return `Неверный вариант: ожидалось одно из ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$9(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет иметь ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$9(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет иметь ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Неверная строка: должна начинаться с "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Неверная строка: должна заканчиваться на "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Неверная строка: должна содержать "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;
          return `Неверный ${Nouns$9[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Неверное число: должно быть кратным ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Нераспознанн${issue2.keys.length > 1 ? "ые" : "ый"} ключ${issue2.keys.length > 1 ? "и" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Неверный ключ в ${issue2.origin}`;
        case "invalid_union":
          return "Неверные входные данные";
        case "invalid_element":
          return `Неверное значение в ${issue2.origin}`;
        default:
          return `Неверные входные данные`;
      }
    };
    function ru() {
      return {
        localeError: error$9
      };
    }
    const Sizable$8 = {
      string: { unit: "znakov", verb: "imeti" },
      file: { unit: "bajtov", verb: "imeti" },
      array: { unit: "elementov", verb: "imeti" },
      set: { unit: "elementov", verb: "imeti" }
    };
    function getSizing$8(origin) {
      return Sizable$8[origin] ?? null;
    }
    const parsedType$8 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "število";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "tabela";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$8 = {
      regex: "vnos",
      email: "e-poštni naslov",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum in čas",
      date: "ISO datum",
      time: "ISO čas",
      duration: "ISO trajanje",
      ipv4: "IPv4 naslov",
      ipv6: "IPv6 naslov",
      cidrv4: "obseg IPv4",
      cidrv6: "obseg IPv6",
      base64: "base64 kodiran niz",
      base64url: "base64url kodiran niz",
      json_string: "JSON niz",
      e164: "E.164 številka",
      jwt: "JWT",
      template_literal: "vnos"
    };
    const error$8 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Neveljaven vnos: pričakovano ${issue2.expected}, prejeto ${parsedType$8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Neveljaven vnos: pričakovano ${stringifyPrimitive(issue2.values[0])}`;
          return `Neveljavna možnost: pričakovano eno izmed ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$8(issue2.origin);
          if (sizing)
            return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
          return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$8(issue2.origin);
          if (sizing) {
            return `Premajhno: pričakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Premajhno: pričakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Neveljaven niz: mora se začeti z "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Neveljaven niz: mora se končati z "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
          return `Neveljaven ${Nouns$8[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Neveljavno število: mora biti večkratnik ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Neprepoznan${issue2.keys.length > 1 ? "i ključi" : " ključ"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Neveljaven ključ v ${issue2.origin}`;
        case "invalid_union":
          return "Neveljaven vnos";
        case "invalid_element":
          return `Neveljavna vrednost v ${issue2.origin}`;
        default:
          return "Neveljaven vnos";
      }
    };
    function sl() {
      return {
        localeError: error$8
      };
    }
    const Sizable$7 = {
      string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
      file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
      array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
      set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
    };
    function getSizing$7(origin) {
      return Sizable$7[origin] ?? null;
    }
    const parsedType$7 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "எண் அல்லாதது" : "எண்";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "அணி";
          }
          if (data2 === null) {
            return "வெறுமை";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$7 = {
      regex: "உள்ளீடு",
      email: "மின்னஞ்சல் முகவரி",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO தேதி நேரம்",
      date: "ISO தேதி",
      time: "ISO நேரம்",
      duration: "ISO கால அளவு",
      ipv4: "IPv4 முகவரி",
      ipv6: "IPv6 முகவரி",
      cidrv4: "IPv4 வரம்பு",
      cidrv6: "IPv6 வரம்பு",
      base64: "base64-encoded சரம்",
      base64url: "base64url-encoded சரம்",
      json_string: "JSON சரம்",
      e164: "E.164 எண்",
      jwt: "JWT",
      template_literal: "input"
    };
    const error$7 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${issue2.expected}, பெறப்பட்டது ${parsedType$7(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${stringifyPrimitive(issue2.values[0])}`;
          return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${joinValues(issue2.values, "|")} இல் ஒன்று`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$7(issue2.origin);
          if (sizing) {
            return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்`;
          }
          return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ஆக இருக்க வேண்டும்`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$7(issue2.origin);
          if (sizing) {
            return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`;
          }
          return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ஆக இருக்க வேண்டும்`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `தவறான சரம்: "${_issue.prefix}" இல் தொடங்க வேண்டும்`;
          if (_issue.format === "ends_with")
            return `தவறான சரம்: "${_issue.suffix}" இல் முடிவடைய வேண்டும்`;
          if (_issue.format === "includes")
            return `தவறான சரம்: "${_issue.includes}" ஐ உள்ளடக்க வேண்டும்`;
          if (_issue.format === "regex")
            return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
          return `தவறான ${Nouns$7[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `தவறான எண்: ${issue2.divisor} இன் பலமாக இருக்க வேண்டும்`;
        case "unrecognized_keys":
          return `அடையாளம் தெரியாத விசை${issue2.keys.length > 1 ? "கள்" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} இல் தவறான விசை`;
        case "invalid_union":
          return "தவறான உள்ளீடு";
        case "invalid_element":
          return `${issue2.origin} இல் தவறான மதிப்பு`;
        default:
          return `தவறான உள்ளீடு`;
      }
    };
    function ta() {
      return {
        localeError: error$7
      };
    }
    const Sizable$6 = {
      string: { unit: "ตัวอักษร", verb: "ควรมี" },
      file: { unit: "ไบต์", verb: "ควรมี" },
      array: { unit: "รายการ", verb: "ควรมี" },
      set: { unit: "รายการ", verb: "ควรมี" }
    };
    function getSizing$6(origin) {
      return Sizable$6[origin] ?? null;
    }
    const parsedType$6 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "อาร์เรย์ (Array)";
          }
          if (data2 === null) {
            return "ไม่มีค่า (null)";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$6 = {
      regex: "ข้อมูลที่ป้อน",
      email: "ที่อยู่อีเมล",
      url: "URL",
      emoji: "อิโมจิ",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "วันที่เวลาแบบ ISO",
      date: "วันที่แบบ ISO",
      time: "เวลาแบบ ISO",
      duration: "ช่วงเวลาแบบ ISO",
      ipv4: "ที่อยู่ IPv4",
      ipv6: "ที่อยู่ IPv6",
      cidrv4: "ช่วง IP แบบ IPv4",
      cidrv6: "ช่วง IP แบบ IPv6",
      base64: "ข้อความแบบ Base64",
      base64url: "ข้อความแบบ Base64 สำหรับ URL",
      json_string: "ข้อความแบบ JSON",
      e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
      jwt: "โทเคน JWT",
      template_literal: "ข้อมูลที่ป้อน"
    };
    const error$6 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${issue2.expected} แต่ได้รับ ${parsedType$6(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `ค่าไม่ถูกต้อง: ควรเป็น ${stringifyPrimitive(issue2.values[0])}`;
          return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "ไม่เกิน" : "น้อยกว่า";
          const sizing = getSizing$6(issue2.origin);
          if (sizing)
            return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "รายการ"}`;
          return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "อย่างน้อย" : "มากกว่า";
          const sizing = getSizing$6(issue2.origin);
          if (sizing) {
            return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${_issue.includes}" อยู่ในข้อความ`;
          if (_issue.format === "regex")
            return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;
          return `รูปแบบไม่ถูกต้อง: ${Nouns$6[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue2.divisor} ได้ลงตัว`;
        case "unrecognized_keys":
          return `พบคีย์ที่ไม่รู้จัก: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `คีย์ไม่ถูกต้องใน ${issue2.origin}`;
        case "invalid_union":
          return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
        case "invalid_element":
          return `ข้อมูลไม่ถูกต้องใน ${issue2.origin}`;
        default:
          return `ข้อมูลไม่ถูกต้อง`;
      }
    };
    function th() {
      return {
        localeError: error$6
      };
    }
    const Sizable$5 = {
      string: { unit: "karakter", verb: "olmalı" },
      file: { unit: "bayt", verb: "olmalı" },
      array: { unit: "öğe", verb: "olmalı" },
      set: { unit: "öğe", verb: "olmalı" }
    };
    function getSizing$5(origin) {
      return Sizable$5[origin] ?? null;
    }
    const parsedType$5 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$5 = {
      regex: "girdi",
      email: "e-posta adresi",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO tarih ve saat",
      date: "ISO tarih",
      time: "ISO saat",
      duration: "ISO süre",
      ipv4: "IPv4 adresi",
      ipv6: "IPv6 adresi",
      cidrv4: "IPv4 aralığı",
      cidrv6: "IPv6 aralığı",
      base64: "base64 ile şifrelenmiş metin",
      base64url: "base64url ile şifrelenmiş metin",
      json_string: "JSON dizesi",
      e164: "E.164 sayısı",
      jwt: "JWT",
      template_literal: "Şablon dizesi"
    };
    const error$5 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Geçersiz değer: beklenen ${issue2.expected}, alınan ${parsedType$5(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Geçersiz değer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
          return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$5(issue2.origin);
          if (sizing)
            return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "öğe"}`;
          return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$5(issue2.origin);
          if (sizing)
            return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Geçersiz metin: "${_issue.prefix}" ile başlamalı`;
          if (_issue.format === "ends_with")
            return `Geçersiz metin: "${_issue.suffix}" ile bitmeli`;
          if (_issue.format === "includes")
            return `Geçersiz metin: "${_issue.includes}" içermeli`;
          if (_issue.format === "regex")
            return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;
          return `Geçersiz ${Nouns$5[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Geçersiz sayı: ${issue2.divisor} ile tam bölünebilmeli`;
        case "unrecognized_keys":
          return `Tanınmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} içinde geçersiz anahtar`;
        case "invalid_union":
          return "Geçersiz değer";
        case "invalid_element":
          return `${issue2.origin} içinde geçersiz değer`;
        default:
          return `Geçersiz değer`;
      }
    };
    function tr() {
      return {
        localeError: error$5
      };
    }
    const Sizable$4 = {
      string: { unit: "символів", verb: "матиме" },
      file: { unit: "байтів", verb: "матиме" },
      array: { unit: "елементів", verb: "матиме" },
      set: { unit: "елементів", verb: "матиме" }
    };
    function getSizing$4(origin) {
      return Sizable$4[origin] ?? null;
    }
    const parsedType$4 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "число";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "масив";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$4 = {
      regex: "вхідні дані",
      email: "адреса електронної пошти",
      url: "URL",
      emoji: "емодзі",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "дата та час ISO",
      date: "дата ISO",
      time: "час ISO",
      duration: "тривалість ISO",
      ipv4: "адреса IPv4",
      ipv6: "адреса IPv6",
      cidrv4: "діапазон IPv4",
      cidrv6: "діапазон IPv6",
      base64: "рядок у кодуванні base64",
      base64url: "рядок у кодуванні base64url",
      json_string: "рядок JSON",
      e164: "номер E.164",
      jwt: "JWT",
      template_literal: "вхідні дані"
    };
    const error$4 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Неправильні вхідні дані: очікується ${issue2.expected}, отримано ${parsedType$4(issue2.input)}`;
        // return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${util.getParsedType(issue.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Неправильні вхідні дані: очікується ${stringifyPrimitive(issue2.values[0])}`;
          return `Неправильна опція: очікується одне з ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$4(issue2.origin);
          if (sizing)
            return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементів"}`;
          return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} буде ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$4(issue2.origin);
          if (sizing) {
            return `Занадто мале: очікується, що ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Занадто мале: очікується, що ${issue2.origin} буде ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Неправильний рядок: повинен починатися з "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Неправильний рядок: повинен закінчуватися на "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Неправильний рядок: повинен містити "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;
          return `Неправильний ${Nouns$4[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Неправильне число: повинно бути кратним ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Нерозпізнаний ключ${issue2.keys.length > 1 ? "і" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Неправильний ключ у ${issue2.origin}`;
        case "invalid_union":
          return "Неправильні вхідні дані";
        case "invalid_element":
          return `Неправильне значення у ${issue2.origin}`;
        default:
          return `Неправильні вхідні дані`;
      }
    };
    function ua() {
      return {
        localeError: error$4
      };
    }
    const Sizable$3 = {
      string: { unit: "حروف", verb: "ہونا" },
      file: { unit: "بائٹس", verb: "ہونا" },
      array: { unit: "آئٹمز", verb: "ہونا" },
      set: { unit: "آئٹمز", verb: "ہونا" }
    };
    function getSizing$3(origin) {
      return Sizable$3[origin] ?? null;
    }
    const parsedType$3 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "نمبر";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "آرے";
          }
          if (data2 === null) {
            return "نل";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$3 = {
      regex: "ان پٹ",
      email: "ای میل ایڈریس",
      url: "یو آر ایل",
      emoji: "ایموجی",
      uuid: "یو یو آئی ڈی",
      uuidv4: "یو یو آئی ڈی وی 4",
      uuidv6: "یو یو آئی ڈی وی 6",
      nanoid: "نینو آئی ڈی",
      guid: "جی یو آئی ڈی",
      cuid: "سی یو آئی ڈی",
      cuid2: "سی یو آئی ڈی 2",
      ulid: "یو ایل آئی ڈی",
      xid: "ایکس آئی ڈی",
      ksuid: "کے ایس یو آئی ڈی",
      datetime: "آئی ایس او ڈیٹ ٹائم",
      date: "آئی ایس او تاریخ",
      time: "آئی ایس او وقت",
      duration: "آئی ایس او مدت",
      ipv4: "آئی پی وی 4 ایڈریس",
      ipv6: "آئی پی وی 6 ایڈریس",
      cidrv4: "آئی پی وی 4 رینج",
      cidrv6: "آئی پی وی 6 رینج",
      base64: "بیس 64 ان کوڈڈ سٹرنگ",
      base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
      json_string: "جے ایس او این سٹرنگ",
      e164: "ای 164 نمبر",
      jwt: "جے ڈبلیو ٹی",
      template_literal: "ان پٹ"
    };
    const error$3 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `غلط ان پٹ: ${issue2.expected} متوقع تھا، ${parsedType$3(issue2.input)} موصول ہوا`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `غلط ان پٹ: ${stringifyPrimitive(issue2.values[0])} متوقع تھا`;
          return `غلط آپشن: ${joinValues(issue2.values, "|")} میں سے ایک متوقع تھا`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$3(issue2.origin);
          if (sizing)
            return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کے ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عناصر"} ہونے متوقع تھے`;
          return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کا ${adj}${issue2.maximum.toString()} ہونا متوقع تھا`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$3(issue2.origin);
          if (sizing) {
            return `بہت چھوٹا: ${issue2.origin} کے ${adj}${issue2.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;
          }
          return `بہت چھوٹا: ${issue2.origin} کا ${adj}${issue2.minimum.toString()} ہونا متوقع تھا`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `غلط سٹرنگ: "${_issue.prefix}" سے شروع ہونا چاہیے`;
          }
          if (_issue.format === "ends_with")
            return `غلط سٹرنگ: "${_issue.suffix}" پر ختم ہونا چاہیے`;
          if (_issue.format === "includes")
            return `غلط سٹرنگ: "${_issue.includes}" شامل ہونا چاہیے`;
          if (_issue.format === "regex")
            return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;
          return `غلط ${Nouns$3[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `غلط نمبر: ${issue2.divisor} کا مضاعف ہونا چاہیے`;
        case "unrecognized_keys":
          return `غیر تسلیم شدہ کی${issue2.keys.length > 1 ? "ز" : ""}: ${joinValues(issue2.keys, "، ")}`;
        case "invalid_key":
          return `${issue2.origin} میں غلط کی`;
        case "invalid_union":
          return "غلط ان پٹ";
        case "invalid_element":
          return `${issue2.origin} میں غلط ویلیو`;
        default:
          return `غلط ان پٹ`;
      }
    };
    function ur() {
      return {
        localeError: error$3
      };
    }
    const Sizable$2 = {
      string: { unit: "ký tự", verb: "có" },
      file: { unit: "byte", verb: "có" },
      array: { unit: "phần tử", verb: "có" },
      set: { unit: "phần tử", verb: "có" }
    };
    function getSizing$2(origin) {
      return Sizable$2[origin] ?? null;
    }
    const parsedType$2 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "số";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "mảng";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$2 = {
      regex: "đầu vào",
      email: "địa chỉ email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ngày giờ ISO",
      date: "ngày ISO",
      time: "giờ ISO",
      duration: "khoảng thời gian ISO",
      ipv4: "địa chỉ IPv4",
      ipv6: "địa chỉ IPv6",
      cidrv4: "dải IPv4",
      cidrv6: "dải IPv6",
      base64: "chuỗi mã hóa base64",
      base64url: "chuỗi mã hóa base64url",
      json_string: "chuỗi JSON",
      e164: "số E.164",
      jwt: "JWT",
      template_literal: "đầu vào"
    };
    const error$2 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Đầu vào không hợp lệ: mong đợi ${issue2.expected}, nhận được ${parsedType$2(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Đầu vào không hợp lệ: mong đợi ${stringifyPrimitive(issue2.values[0])}`;
          return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$2(issue2.origin);
          if (sizing)
            return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phần tử"}`;
          return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$2(issue2.origin);
          if (sizing) {
            return `Quá nhỏ: mong đợi ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Quá nhỏ: mong đợi ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Chuỗi không hợp lệ: phải bắt đầu bằng "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Chuỗi không hợp lệ: phải kết thúc bằng "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Chuỗi không hợp lệ: phải bao gồm "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;
          return `${Nouns$2[_issue.format] ?? issue2.format} không hợp lệ`;
        }
        case "not_multiple_of":
          return `Số không hợp lệ: phải là bội số của ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Khóa không được nhận dạng: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Khóa không hợp lệ trong ${issue2.origin}`;
        case "invalid_union":
          return "Đầu vào không hợp lệ";
        case "invalid_element":
          return `Giá trị không hợp lệ trong ${issue2.origin}`;
        default:
          return `Đầu vào không hợp lệ`;
      }
    };
    function vi() {
      return {
        localeError: error$2
      };
    }
    const Sizable$1 = {
      string: { unit: "字符", verb: "包含" },
      file: { unit: "字节", verb: "包含" },
      array: { unit: "项", verb: "包含" },
      set: { unit: "项", verb: "包含" }
    };
    function getSizing$1(origin) {
      return Sizable$1[origin] ?? null;
    }
    const parsedType$1 = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "非数字(NaN)" : "数字";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "数组";
          }
          if (data2 === null) {
            return "空值(null)";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns$1 = {
      regex: "输入",
      email: "电子邮件",
      url: "URL",
      emoji: "表情符号",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO日期时间",
      date: "ISO日期",
      time: "ISO时间",
      duration: "ISO时长",
      ipv4: "IPv4地址",
      ipv6: "IPv6地址",
      cidrv4: "IPv4网段",
      cidrv6: "IPv6网段",
      base64: "base64编码字符串",
      base64url: "base64url编码字符串",
      json_string: "JSON字符串",
      e164: "E.164号码",
      jwt: "JWT",
      template_literal: "输入"
    };
    const error$1 = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `无效输入：期望 ${issue2.expected}，实际接收 ${parsedType$1(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `无效输入：期望 ${stringifyPrimitive(issue2.values[0])}`;
          return `无效选项：期望以下之一 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing$1(issue2.origin);
          if (sizing)
            return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "个元素"}`;
          return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing$1(issue2.origin);
          if (sizing) {
            return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `无效字符串：必须以 "${_issue.prefix}" 开头`;
          if (_issue.format === "ends_with")
            return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
          if (_issue.format === "includes")
            return `无效字符串：必须包含 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
          return `无效${Nouns$1[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `无效数字：必须是 ${issue2.divisor} 的倍数`;
        case "unrecognized_keys":
          return `出现未知的键(key): ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} 中的键(key)无效`;
        case "invalid_union":
          return "无效输入";
        case "invalid_element":
          return `${issue2.origin} 中包含无效值(value)`;
        default:
          return `无效输入`;
      }
    };
    function zhCN() {
      return {
        localeError: error$1
      };
    }
    const Sizable = {
      string: { unit: "字元", verb: "擁有" },
      file: { unit: "位元組", verb: "擁有" },
      array: { unit: "項目", verb: "擁有" },
      set: { unit: "項目", verb: "擁有" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType = (data2) => {
      const t = typeof data2;
      switch (t) {
        case "number": {
          return Number.isNaN(data2) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data2)) {
            return "array";
          }
          if (data2 === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data2) !== Object.prototype && data2.constructor) {
            return data2.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "輸入",
      email: "郵件地址",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO 日期時間",
      date: "ISO 日期",
      time: "ISO 時間",
      duration: "ISO 期間",
      ipv4: "IPv4 位址",
      ipv6: "IPv6 位址",
      cidrv4: "IPv4 範圍",
      cidrv6: "IPv6 範圍",
      base64: "base64 編碼字串",
      base64url: "base64url 編碼字串",
      json_string: "JSON 字串",
      e164: "E.164 數值",
      jwt: "JWT",
      template_literal: "輸入"
    };
    const error = (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `無效的輸入值：預期為 ${issue2.expected}，但收到 ${parsedType(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `無效的輸入值：預期為 ${stringifyPrimitive(issue2.values[0])}`;
          return `無效的選項：預期為以下其中之一 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "個元素"}`;
          return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `無效的字串：必須以 "${_issue.prefix}" 開頭`;
          }
          if (_issue.format === "ends_with")
            return `無效的字串：必須以 "${_issue.suffix}" 結尾`;
          if (_issue.format === "includes")
            return `無效的字串：必須包含 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `無效的字串：必須符合格式 ${_issue.pattern}`;
          return `無效的 ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `無效的數字：必須為 ${issue2.divisor} 的倍數`;
        case "unrecognized_keys":
          return `無法識別的鍵值${issue2.keys.length > 1 ? "們" : ""}：${joinValues(issue2.keys, "、")}`;
        case "invalid_key":
          return `${issue2.origin} 中有無效的鍵值`;
        case "invalid_union":
          return "無效的輸入值";
        case "invalid_element":
          return `${issue2.origin} 中有無效的值`;
        default:
          return `無效的輸入值`;
      }
    };
    function zhTw() {
      return {
        localeError: error
      };
    }
    const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      ar,
      az,
      be,
      ca,
      cs,
      de,
      en,
      es,
      fa,
      fi,
      fr,
      frCA,
      he,
      hu,
      id,
      it,
      ja,
      ko,
      mk,
      ms,
      no,
      ota,
      pl,
      pt,
      ru,
      sl,
      ta,
      th,
      tr,
      ua,
      ur,
      vi,
      zhCN,
      zhTW: zhTw
    }, Symbol.toStringTag, { value: "Module" }));
    const $output = Symbol("ZodOutput");
    const $input = Symbol("ZodInput");
    class $ZodRegistry {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
          if (this._idmap.has(meta.id)) {
            throw new Error(`ID ${meta.id} already exists in the registry`);
          }
          this._idmap.set(meta.id, schema);
        }
        return this;
      }
      remove(schema) {
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          return { ...pm, ...this._map.get(schema) };
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    }
    function registry() {
      return new $ZodRegistry();
    }
    const globalRegistry = /* @__PURE__ */ registry();
    function _string(Class2, params) {
      return new Class2({
        type: "string",
        ...normalizeParams(params)
      });
    }
    function _coercedString(Class2, params) {
      return new Class2({
        type: "string",
        coerce: true,
        ...normalizeParams(params)
      });
    }
    function _email(Class2, params) {
      return new Class2({
        type: "string",
        format: "email",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _guid(Class2, params) {
      return new Class2({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _uuid(Class2, params) {
      return new Class2({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _uuidv4(Class2, params) {
      return new Class2({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v4",
        ...normalizeParams(params)
      });
    }
    function _uuidv6(Class2, params) {
      return new Class2({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v6",
        ...normalizeParams(params)
      });
    }
    function _uuidv7(Class2, params) {
      return new Class2({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v7",
        ...normalizeParams(params)
      });
    }
    function _url(Class2, params) {
      return new Class2({
        type: "string",
        format: "url",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _emoji(Class2, params) {
      return new Class2({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _nanoid(Class2, params) {
      return new Class2({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _cuid(Class2, params) {
      return new Class2({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _cuid2(Class2, params) {
      return new Class2({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _ulid(Class2, params) {
      return new Class2({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _xid(Class2, params) {
      return new Class2({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _ksuid(Class2, params) {
      return new Class2({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _ipv4(Class2, params) {
      return new Class2({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _ipv6(Class2, params) {
      return new Class2({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _cidrv4(Class2, params) {
      return new Class2({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _cidrv6(Class2, params) {
      return new Class2({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _base64(Class2, params) {
      return new Class2({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _base64url(Class2, params) {
      return new Class2({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _e164(Class2, params) {
      return new Class2({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _jwt(Class2, params) {
      return new Class2({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: false,
        ...normalizeParams(params)
      });
    }
    function _isoDateTime(Class2, params) {
      return new Class2({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: false,
        local: false,
        precision: null,
        ...normalizeParams(params)
      });
    }
    function _isoDate(Class2, params) {
      return new Class2({
        type: "string",
        format: "date",
        check: "string_format",
        ...normalizeParams(params)
      });
    }
    function _isoTime(Class2, params) {
      return new Class2({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...normalizeParams(params)
      });
    }
    function _isoDuration(Class2, params) {
      return new Class2({
        type: "string",
        format: "duration",
        check: "string_format",
        ...normalizeParams(params)
      });
    }
    function _number(Class2, params) {
      return new Class2({
        type: "number",
        checks: [],
        ...normalizeParams(params)
      });
    }
    function _coercedNumber(Class2, params) {
      return new Class2({
        type: "number",
        coerce: true,
        checks: [],
        ...normalizeParams(params)
      });
    }
    function _int(Class2, params) {
      return new Class2({
        type: "number",
        check: "number_format",
        abort: false,
        format: "safeint",
        ...normalizeParams(params)
      });
    }
    function _float32(Class2, params) {
      return new Class2({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float32",
        ...normalizeParams(params)
      });
    }
    function _float64(Class2, params) {
      return new Class2({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float64",
        ...normalizeParams(params)
      });
    }
    function _int32(Class2, params) {
      return new Class2({
        type: "number",
        check: "number_format",
        abort: false,
        format: "int32",
        ...normalizeParams(params)
      });
    }
    function _uint32(Class2, params) {
      return new Class2({
        type: "number",
        check: "number_format",
        abort: false,
        format: "uint32",
        ...normalizeParams(params)
      });
    }
    function _boolean(Class2, params) {
      return new Class2({
        type: "boolean",
        ...normalizeParams(params)
      });
    }
    function _coercedBoolean(Class2, params) {
      return new Class2({
        type: "boolean",
        coerce: true,
        ...normalizeParams(params)
      });
    }
    function _bigint(Class2, params) {
      return new Class2({
        type: "bigint",
        ...normalizeParams(params)
      });
    }
    function _coercedBigint(Class2, params) {
      return new Class2({
        type: "bigint",
        coerce: true,
        ...normalizeParams(params)
      });
    }
    function _int64(Class2, params) {
      return new Class2({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "int64",
        ...normalizeParams(params)
      });
    }
    function _uint64(Class2, params) {
      return new Class2({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "uint64",
        ...normalizeParams(params)
      });
    }
    function _symbol(Class2, params) {
      return new Class2({
        type: "symbol",
        ...normalizeParams(params)
      });
    }
    function _undefined$1(Class2, params) {
      return new Class2({
        type: "undefined",
        ...normalizeParams(params)
      });
    }
    function _null$1(Class2, params) {
      return new Class2({
        type: "null",
        ...normalizeParams(params)
      });
    }
    function _any(Class2) {
      return new Class2({
        type: "any"
      });
    }
    function _unknown(Class2) {
      return new Class2({
        type: "unknown"
      });
    }
    function _never(Class2, params) {
      return new Class2({
        type: "never",
        ...normalizeParams(params)
      });
    }
    function _void$1(Class2, params) {
      return new Class2({
        type: "void",
        ...normalizeParams(params)
      });
    }
    function _date(Class2, params) {
      return new Class2({
        type: "date",
        ...normalizeParams(params)
      });
    }
    function _coercedDate(Class2, params) {
      return new Class2({
        type: "date",
        coerce: true,
        ...normalizeParams(params)
      });
    }
    function _nan(Class2, params) {
      return new Class2({
        type: "nan",
        ...normalizeParams(params)
      });
    }
    function _lt(value, params) {
      return new $ZodCheckLessThan({
        check: "less_than",
        ...normalizeParams(params),
        value,
        inclusive: false
      });
    }
    function _lte(value, params) {
      return new $ZodCheckLessThan({
        check: "less_than",
        ...normalizeParams(params),
        value,
        inclusive: true
      });
    }
    function _gt(value, params) {
      return new $ZodCheckGreaterThan({
        check: "greater_than",
        ...normalizeParams(params),
        value,
        inclusive: false
      });
    }
    function _gte(value, params) {
      return new $ZodCheckGreaterThan({
        check: "greater_than",
        ...normalizeParams(params),
        value,
        inclusive: true
      });
    }
    function _positive(params) {
      return _gt(0, params);
    }
    function _negative(params) {
      return _lt(0, params);
    }
    function _nonpositive(params) {
      return _lte(0, params);
    }
    function _nonnegative(params) {
      return _gte(0, params);
    }
    function _multipleOf(value, params) {
      return new $ZodCheckMultipleOf({
        check: "multiple_of",
        ...normalizeParams(params),
        value
      });
    }
    function _maxSize(maximum, params) {
      return new $ZodCheckMaxSize({
        check: "max_size",
        ...normalizeParams(params),
        maximum
      });
    }
    function _minSize(minimum, params) {
      return new $ZodCheckMinSize({
        check: "min_size",
        ...normalizeParams(params),
        minimum
      });
    }
    function _size(size, params) {
      return new $ZodCheckSizeEquals({
        check: "size_equals",
        ...normalizeParams(params),
        size
      });
    }
    function _maxLength(maximum, params) {
      const ch = new $ZodCheckMaxLength({
        check: "max_length",
        ...normalizeParams(params),
        maximum
      });
      return ch;
    }
    function _minLength(minimum, params) {
      return new $ZodCheckMinLength({
        check: "min_length",
        ...normalizeParams(params),
        minimum
      });
    }
    function _length(length, params) {
      return new $ZodCheckLengthEquals({
        check: "length_equals",
        ...normalizeParams(params),
        length
      });
    }
    function _regex(pattern, params) {
      return new $ZodCheckRegex({
        check: "string_format",
        format: "regex",
        ...normalizeParams(params),
        pattern
      });
    }
    function _lowercase(params) {
      return new $ZodCheckLowerCase({
        check: "string_format",
        format: "lowercase",
        ...normalizeParams(params)
      });
    }
    function _uppercase(params) {
      return new $ZodCheckUpperCase({
        check: "string_format",
        format: "uppercase",
        ...normalizeParams(params)
      });
    }
    function _includes(includes, params) {
      return new $ZodCheckIncludes({
        check: "string_format",
        format: "includes",
        ...normalizeParams(params),
        includes
      });
    }
    function _startsWith(prefix, params) {
      return new $ZodCheckStartsWith({
        check: "string_format",
        format: "starts_with",
        ...normalizeParams(params),
        prefix
      });
    }
    function _endsWith(suffix, params) {
      return new $ZodCheckEndsWith({
        check: "string_format",
        format: "ends_with",
        ...normalizeParams(params),
        suffix
      });
    }
    function _property(property, schema, params) {
      return new $ZodCheckProperty({
        check: "property",
        property,
        schema,
        ...normalizeParams(params)
      });
    }
    function _mime(types, params) {
      return new $ZodCheckMimeType({
        check: "mime_type",
        mime: types,
        ...normalizeParams(params)
      });
    }
    function _overwrite(tx) {
      return new $ZodCheckOverwrite({
        check: "overwrite",
        tx
      });
    }
    function _normalize(form) {
      return _overwrite((input) => input.normalize(form));
    }
    function _trim() {
      return _overwrite((input) => input.trim());
    }
    function _toLowerCase() {
      return _overwrite((input) => input.toLowerCase());
    }
    function _toUpperCase() {
      return _overwrite((input) => input.toUpperCase());
    }
    function _array(Class2, element, params) {
      return new Class2({
        type: "array",
        element,
        // get element() {
        //   return element;
        // },
        ...normalizeParams(params)
      });
    }
    function _union(Class2, options, params) {
      return new Class2({
        type: "union",
        options,
        ...normalizeParams(params)
      });
    }
    function _discriminatedUnion(Class2, discriminator, options, params) {
      return new Class2({
        type: "union",
        options,
        discriminator,
        ...normalizeParams(params)
      });
    }
    function _intersection(Class2, left, right) {
      return new Class2({
        type: "intersection",
        left,
        right
      });
    }
    function _tuple(Class2, items, _paramsOrRest, _params) {
      const hasRest = _paramsOrRest instanceof $ZodType;
      const params = hasRest ? _params : _paramsOrRest;
      const rest = hasRest ? _paramsOrRest : null;
      return new Class2({
        type: "tuple",
        items,
        rest,
        ...normalizeParams(params)
      });
    }
    function _record(Class2, keyType, valueType, params) {
      return new Class2({
        type: "record",
        keyType,
        valueType,
        ...normalizeParams(params)
      });
    }
    function _map(Class2, keyType, valueType, params) {
      return new Class2({
        type: "map",
        keyType,
        valueType,
        ...normalizeParams(params)
      });
    }
    function _set(Class2, valueType, params) {
      return new Class2({
        type: "set",
        valueType,
        ...normalizeParams(params)
      });
    }
    function _enum$1(Class2, values, params) {
      const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
      return new Class2({
        type: "enum",
        entries,
        ...normalizeParams(params)
      });
    }
    function _nativeEnum(Class2, entries, params) {
      return new Class2({
        type: "enum",
        entries,
        ...normalizeParams(params)
      });
    }
    function _literal(Class2, value, params) {
      return new Class2({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ...normalizeParams(params)
      });
    }
    function _file(Class2, params) {
      return new Class2({
        type: "file",
        ...normalizeParams(params)
      });
    }
    function _transform(Class2, fn) {
      return new Class2({
        type: "transform",
        transform: fn
      });
    }
    function _optional(Class2, innerType) {
      return new Class2({
        type: "optional",
        innerType
      });
    }
    function _nullable(Class2, innerType) {
      return new Class2({
        type: "nullable",
        innerType
      });
    }
    function _default$1(Class2, innerType, defaultValue) {
      return new Class2({
        type: "default",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        }
      });
    }
    function _nonoptional(Class2, innerType, params) {
      return new Class2({
        type: "nonoptional",
        innerType,
        ...normalizeParams(params)
      });
    }
    function _success(Class2, innerType) {
      return new Class2({
        type: "success",
        innerType
      });
    }
    function _catch$1(Class2, innerType, catchValue) {
      return new Class2({
        type: "catch",
        innerType,
        catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
      });
    }
    function _pipe(Class2, in_, out) {
      return new Class2({
        type: "pipe",
        in: in_,
        out
      });
    }
    function _readonly(Class2, innerType) {
      return new Class2({
        type: "readonly",
        innerType
      });
    }
    function _templateLiteral(Class2, parts, params) {
      return new Class2({
        type: "template_literal",
        parts,
        ...normalizeParams(params)
      });
    }
    function _lazy(Class2, getter) {
      return new Class2({
        type: "lazy",
        getter
      });
    }
    function _promise(Class2, innerType) {
      return new Class2({
        type: "promise",
        innerType
      });
    }
    function _custom(Class2, fn, _params) {
      const schema = new Class2({
        type: "custom",
        check: "custom",
        fn,
        ...normalizeParams(_params)
      });
      return schema;
    }
    function _refine(Class2, fn, _params = {}) {
      return _custom(Class2, fn, _params);
    }
    function _stringbool(Classes, _params) {
      const params = normalizeParams(_params);
      const trueValues = new Set((params == null ? void 0 : params.truthy) ?? ["true", "1", "yes", "on", "y", "enabled"]);
      const falseValues = new Set((params == null ? void 0 : params.falsy) ?? ["false", "0", "no", "off", "n", "disabled"]);
      const _Pipe = Classes.Pipe ?? $ZodPipe;
      const _Boolean = Classes.Boolean ?? $ZodBoolean;
      const _Unknown = Classes.Unknown ?? $ZodUnknown;
      const inst = new _Unknown({
        type: "unknown",
        checks: [
          {
            _zod: {
              check: (ctx) => {
                if (typeof ctx.value === "string") {
                  let data2 = ctx.value;
                  if ((params == null ? void 0 : params.case) !== "sensitive")
                    data2 = data2.toLowerCase();
                  if (trueValues.has(data2)) {
                    ctx.value = true;
                  } else if (falseValues.has(data2)) {
                    ctx.value = false;
                  } else {
                    ctx.issues.push({
                      code: "invalid_value",
                      expected: "stringbool",
                      values: [...trueValues, ...falseValues],
                      input: ctx.value,
                      inst
                    });
                  }
                } else {
                  ctx.issues.push({
                    code: "invalid_type",
                    expected: "string",
                    input: ctx.value
                  });
                }
              },
              def: {
                check: "custom"
              },
              onattach: []
            }
          }
        ]
      });
      return new _Pipe({
        type: "pipe",
        in: inst,
        out: new _Boolean({
          type: "boolean"
        })
      });
    }
    class $ZodFunction {
      constructor(def) {
        this._def = def;
        this.def = def;
      }
      implement(func) {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        const impl = (...args) => {
          const parsedArgs = this._def.input ? parse$1(this._def.input, args, void 0, { callee: impl }) : args;
          if (!Array.isArray(parsedArgs)) {
            throw new Error("Invalid arguments schema: not an array or tuple schema.");
          }
          const output2 = func(...parsedArgs);
          return this._def.output ? parse$1(this._def.output, output2, void 0, { callee: impl }) : output2;
        };
        return impl;
      }
      implementAsync(func) {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        const impl = async (...args) => {
          const parsedArgs = this._def.input ? await parseAsync$1(this._def.input, args, void 0, { callee: impl }) : args;
          if (!Array.isArray(parsedArgs)) {
            throw new Error("Invalid arguments schema: not an array or tuple schema.");
          }
          const output2 = await func(...parsedArgs);
          return this._def.output ? parseAsync$1(this._def.output, output2, void 0, { callee: impl }) : output2;
        };
        return impl;
      }
      input(...args) {
        if (Array.isArray(args[0])) {
          return new $ZodFunction({
            type: "function",
            input: new $ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: this._def.output
          });
        }
        return new $ZodFunction({
          type: "function",
          input: args[0],
          output: this._def.output
        });
      }
      output(output2) {
        return new $ZodFunction({
          type: "function",
          input: this._def.input,
          output: output2
        });
      }
    }
    function _function(params) {
      return new $ZodFunction({
        type: "function",
        input: Array.isArray(params == null ? void 0 : params.input) ? _tuple($ZodTuple, params == null ? void 0 : params.input) : (params == null ? void 0 : params.input) ?? null,
        output: (params == null ? void 0 : params.output) ?? null
      });
    }
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string"
    };
    class JSONSchemaGenerator {
      constructor(params) {
        this.counter = 0;
        this.metadataRegistry = (params == null ? void 0 : params.metadata) ?? globalRegistry;
        this.target = (params == null ? void 0 : params.target) ?? "draft-2020-12";
        this.unrepresentable = (params == null ? void 0 : params.unrepresentable) ?? "throw";
        this.override = (params == null ? void 0 : params.override) ?? (() => {
        });
        this.io = (params == null ? void 0 : params.io) ?? "output";
        this.seen = /* @__PURE__ */ new Map();
      }
      process(schema, _params = { path: [], schemaPath: [] }) {
        var _a2;
        var _a;
        const def = schema._zod.def;
        const seen = this.seen.get(schema);
        if (seen) {
          seen.count++;
          const isCycle = _params.schemaPath.includes(schema);
          if (isCycle) {
            seen.cycle = _params.path;
          }
          seen.count++;
          return seen.schema;
        }
        const result = { schema: {}, count: 1, cycle: void 0 };
        this.seen.set(schema, result);
        if (schema._zod.toJSONSchema) {
          result.schema = schema._zod.toJSONSchema();
        }
        const params = {
          ..._params,
          schemaPath: [..._params.schemaPath, schema],
          path: _params.path
        };
        const parent = schema._zod.parent;
        if (parent) {
          result.ref = parent;
          this.process(parent, params);
          this.seen.get(parent).isParent = true;
        } else {
          const _json = result.schema;
          switch (def.type) {
            case "string": {
              const json2 = _json;
              json2.type = "string";
              const { minimum, maximum, format, pattern, contentEncoding } = schema._zod.bag;
              if (typeof minimum === "number")
                json2.minLength = minimum;
              if (typeof maximum === "number")
                json2.maxLength = maximum;
              if (format) {
                json2.format = formatMap[format] ?? format;
              }
              if (pattern) {
                json2.pattern = pattern.source;
              }
              if (contentEncoding)
                json2.contentEncoding = contentEncoding;
              break;
            }
            case "number": {
              const json2 = _json;
              const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
              if (typeof format === "string" && format.includes("int"))
                json2.type = "integer";
              else
                json2.type = "number";
              if (typeof exclusiveMinimum === "number")
                json2.exclusiveMinimum = exclusiveMinimum;
              if (typeof minimum === "number") {
                json2.minimum = minimum;
                if (typeof exclusiveMinimum === "number") {
                  if (exclusiveMinimum >= minimum)
                    delete json2.minimum;
                  else
                    delete json2.exclusiveMinimum;
                }
              }
              if (typeof exclusiveMaximum === "number")
                json2.exclusiveMaximum = exclusiveMaximum;
              if (typeof maximum === "number") {
                json2.maximum = maximum;
                if (typeof exclusiveMaximum === "number") {
                  if (exclusiveMaximum <= maximum)
                    delete json2.maximum;
                  else
                    delete json2.exclusiveMaximum;
                }
              }
              if (typeof multipleOf === "number")
                json2.multipleOf = multipleOf;
              break;
            }
            case "boolean": {
              const json2 = _json;
              json2.type = "boolean";
              break;
            }
            case "bigint": {
              if (this.unrepresentable === "throw") {
                throw new Error("BigInt cannot be represented in JSON Schema");
              }
              break;
            }
            case "symbol": {
              if (this.unrepresentable === "throw") {
                throw new Error("Symbols cannot be represented in JSON Schema");
              }
              break;
            }
            case "undefined": {
              const json2 = _json;
              json2.type = "null";
              break;
            }
            case "null": {
              _json.type = "null";
              break;
            }
            case "any": {
              break;
            }
            case "unknown": {
              break;
            }
            case "never": {
              _json.not = {};
              break;
            }
            case "void": {
              if (this.unrepresentable === "throw") {
                throw new Error("Void cannot be represented in JSON Schema");
              }
              break;
            }
            case "date": {
              if (this.unrepresentable === "throw") {
                throw new Error("Date cannot be represented in JSON Schema");
              }
              break;
            }
            case "array": {
              const json2 = _json;
              const { minimum, maximum } = schema._zod.bag;
              if (typeof minimum === "number")
                json2.minItems = minimum;
              if (typeof maximum === "number")
                json2.maxItems = maximum;
              json2.type = "array";
              json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
              break;
            }
            case "object": {
              const json2 = _json;
              json2.type = "object";
              json2.properties = {};
              const shape = def.shape;
              for (const key in shape) {
                json2.properties[key] = this.process(shape[key], {
                  ...params,
                  path: [...params.path, "properties", key]
                });
              }
              const allKeys = new Set(Object.keys(shape));
              const requiredKeys = new Set([...allKeys].filter((key) => {
                const v = def.shape[key]._zod;
                if (this.io === "input") {
                  return v.optin === void 0;
                } else {
                  return v.optout === void 0;
                }
              }));
              json2.required = Array.from(requiredKeys);
              if (((_a2 = def.catchall) == null ? void 0 : _a2._zod.def.type) === "never") {
                json2.additionalProperties = false;
              } else if (!def.catchall) {
                if (this.io === "output")
                  json2.additionalProperties = false;
              } else if (def.catchall) {
                json2.additionalProperties = this.process(def.catchall, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
              }
              break;
            }
            case "union": {
              const json2 = _json;
              json2.anyOf = def.options.map((x, i) => this.process(x, {
                ...params,
                path: [...params.path, "anyOf", i]
              }));
              break;
            }
            case "intersection": {
              const json2 = _json;
              json2.allOf = [
                this.process(def.left, {
                  ...params,
                  path: [...params.path, "allOf", 0]
                }),
                this.process(def.right, {
                  ...params,
                  path: [...params.path, "allOf", 1]
                })
              ];
              break;
            }
            case "tuple": {
              const json2 = _json;
              json2.type = "array";
              const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
              if (this.target === "draft-2020-12") {
                json2.prefixItems = prefixItems;
              } else {
                json2.items = prefixItems;
              }
              if (def.rest) {
                const rest = this.process(def.rest, {
                  ...params,
                  path: [...params.path, "items"]
                });
                if (this.target === "draft-2020-12") {
                  json2.items = rest;
                } else {
                  json2.additionalItems = rest;
                }
              }
              if (def.rest) {
                json2.items = this.process(def.rest, {
                  ...params,
                  path: [...params.path, "items"]
                });
              }
              const { minimum, maximum } = schema._zod.bag;
              if (typeof minimum === "number")
                json2.minItems = minimum;
              if (typeof maximum === "number")
                json2.maxItems = maximum;
              break;
            }
            case "record": {
              const json2 = _json;
              json2.type = "object";
              json2.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
              json2.additionalProperties = this.process(def.valueType, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
              break;
            }
            case "map": {
              if (this.unrepresentable === "throw") {
                throw new Error("Map cannot be represented in JSON Schema");
              }
              break;
            }
            case "set": {
              if (this.unrepresentable === "throw") {
                throw new Error("Set cannot be represented in JSON Schema");
              }
              break;
            }
            case "enum": {
              const json2 = _json;
              json2.enum = Object.values(def.entries);
              break;
            }
            case "literal": {
              const json2 = _json;
              const vals = [];
              for (const val of def.values) {
                if (val === void 0) {
                  if (this.unrepresentable === "throw") {
                    throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                  }
                } else if (typeof val === "bigint") {
                  if (this.unrepresentable === "throw") {
                    throw new Error("BigInt literals cannot be represented in JSON Schema");
                  } else {
                    vals.push(Number(val));
                  }
                } else {
                  vals.push(val);
                }
              }
              if (vals.length === 0) ;
              else if (vals.length === 1) {
                const val = vals[0];
                json2.const = val;
              } else {
                json2.enum = vals;
              }
              break;
            }
            case "file": {
              if (this.unrepresentable === "throw") {
                throw new Error("File cannot be represented in JSON Schema");
              }
              break;
            }
            case "transform": {
              if (this.unrepresentable === "throw") {
                throw new Error("Transforms cannot be represented in JSON Schema");
              }
              break;
            }
            case "nullable": {
              const inner = this.process(def.innerType, params);
              _json.anyOf = [inner, { type: "null" }];
              break;
            }
            case "nonoptional": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              break;
            }
            case "success": {
              const json2 = _json;
              json2.type = "boolean";
              break;
            }
            case "default": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              _json.default = def.defaultValue;
              break;
            }
            case "prefault": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              if (this.io === "input")
                _json._prefault = def.defaultValue;
              break;
            }
            case "catch": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              let catchValue;
              try {
                catchValue = def.catchValue(void 0);
              } catch {
                throw new Error("Dynamic catch values are not supported in JSON Schema");
              }
              _json.default = catchValue;
              break;
            }
            case "nan": {
              if (this.unrepresentable === "throw") {
                throw new Error("NaN cannot be represented in JSON Schema");
              }
              break;
            }
            case "template_literal": {
              const json2 = _json;
              const pattern = schema._zod.pattern;
              if (!pattern)
                throw new Error("Pattern not found in template literal");
              json2.type = "string";
              json2.pattern = pattern.source;
              break;
            }
            case "pipe": {
              const innerType = this.io === "input" ? def.in : def.out;
              this.process(innerType, params);
              result.ref = innerType;
              break;
            }
            case "readonly": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              _json.readOnly = true;
              break;
            }
            // passthrough types
            case "promise": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              break;
            }
            case "optional": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              break;
            }
            case "lazy": {
              const innerType = schema._zod.innerType;
              this.process(innerType, params);
              result.ref = innerType;
              break;
            }
            case "custom": {
              if (this.unrepresentable === "throw") {
                throw new Error("Custom types cannot be represented in JSON Schema");
              }
              break;
            }
          }
        }
        const meta = this.metadataRegistry.get(schema);
        if (meta)
          Object.assign(result.schema, meta);
        if (this.io === "input" && def.type === "pipe") {
          delete result.schema.examples;
          delete result.schema.default;
          if (result.schema._prefault)
            result.schema.default = result.schema._prefault;
        }
        if (this.io === "input" && result.schema._prefault)
          (_a = result.schema).default ?? (_a.default = result.schema._prefault);
        delete result.schema._prefault;
        const _result = this.seen.get(schema);
        return _result.schema;
      }
      emit(schema, _params) {
        var _a, _b, _c, _d;
        const params = {
          cycles: (_params == null ? void 0 : _params.cycles) ?? "ref",
          reused: (_params == null ? void 0 : _params.reused) ?? "inline",
          // unrepresentable: _params?.unrepresentable ?? "throw",
          // uri: _params?.uri ?? ((id) => `${id}`),
          external: (_params == null ? void 0 : _params.external) ?? void 0
        };
        const root = this.seen.get(schema);
        if (!root)
          throw new Error("Unprocessed schema. This is a bug in Zod.");
        const makeURI = (entry) => {
          var _a2;
          const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (params.external) {
            const externalId = (_a2 = params.external.registry.get(entry[0])) == null ? void 0 : _a2.id;
            if (externalId)
              return { ref: params.external.uri(externalId) };
            const id2 = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
            entry[1].defId = id2;
            return { defId: id2, ref: `${params.external.uri("__shared")}#/${defsSegment}/${id2}` };
          }
          if (entry[1] === root) {
            return { ref: "#" };
          }
          const uriPrefix = `#`;
          const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
          const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
          return { defId, ref: defUriPrefix + defId };
        };
        const extractToDef = (entry) => {
          if (entry[1].schema.$ref) {
            return;
          }
          const seen = entry[1];
          const { ref: ref2, defId } = makeURI(entry);
          seen.def = { ...seen.schema };
          if (defId)
            seen.defId = defId;
          const schema2 = seen.schema;
          for (const key in schema2) {
            delete schema2[key];
            schema2.$ref = ref2;
          }
        };
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (schema === entry[0]) {
            extractToDef(entry);
            continue;
          }
          if (params.external) {
            const ext = (_a = params.external.registry.get(entry[0])) == null ? void 0 : _a.id;
            if (schema !== entry[0] && ext) {
              extractToDef(entry);
              continue;
            }
          }
          const id2 = (_b = this.metadataRegistry.get(entry[0])) == null ? void 0 : _b.id;
          if (id2) {
            extractToDef(entry);
            continue;
          }
          if (seen.cycle) {
            if (params.cycles === "throw") {
              throw new Error(`Cycle detected: #/${(_c = seen.cycle) == null ? void 0 : _c.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            } else if (params.cycles === "ref") {
              extractToDef(entry);
            }
            continue;
          }
          if (seen.count > 1) {
            if (params.reused === "ref") {
              extractToDef(entry);
              continue;
            }
          }
        }
        const flattenRef = (zodSchema, params2) => {
          const seen = this.seen.get(zodSchema);
          const schema2 = seen.def ?? seen.schema;
          const _schema = { ...schema2 };
          if (seen.ref === null) {
            return;
          }
          const ref2 = seen.ref;
          seen.ref = null;
          if (ref2) {
            flattenRef(ref2, params2);
            const refSchema = this.seen.get(ref2).schema;
            if (refSchema.$ref && params2.target === "draft-7") {
              schema2.allOf = schema2.allOf ?? [];
              schema2.allOf.push(refSchema);
            } else {
              Object.assign(schema2, refSchema);
              Object.assign(schema2, _schema);
            }
          }
          if (!seen.isParent)
            this.override({
              zodSchema,
              jsonSchema: schema2
            });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
          flattenRef(entry[0], { target: this.target });
        }
        const result = { ...root.def };
        const defs = ((_d = params.external) == null ? void 0 : _d.defs) ?? {};
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (seen.def && seen.defId) {
            defs[seen.defId] = seen.def;
          }
        }
        if (!params.external && Object.keys(defs).length > 0) {
          if (this.target === "draft-2020-12") {
            result.$defs = defs;
          } else {
            result.definitions = defs;
          }
        }
        if (this.target === "draft-2020-12") {
          result.$schema = "https://json-schema.org/draft/2020-12/schema";
        } else if (this.target === "draft-7") {
          result.$schema = "http://json-schema.org/draft-07/schema#";
        } else {
          console.warn(`Invalid target: ${this.target}`);
        }
        try {
          return JSON.parse(JSON.stringify(result));
        } catch (_err) {
          throw new Error("Error converting schema to JSON.");
        }
      }
    }
    function toJSONSchema(input, _params) {
      if (input instanceof $ZodRegistry) {
        const gen2 = new JSONSchemaGenerator(_params);
        const defs = {};
        for (const entry of input._idmap.entries()) {
          const [_, schema] = entry;
          gen2.process(schema);
        }
        const schemas = {};
        const external = {
          registry: input,
          uri: (_params == null ? void 0 : _params.uri) || ((id2) => id2),
          defs
        };
        for (const entry of input._idmap.entries()) {
          const [key, schema] = entry;
          schemas[key] = gen2.emit(schema, {
            ..._params,
            external
          });
        }
        if (Object.keys(defs).length > 0) {
          const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
          schemas.__shared = {
            [defsSegment]: defs
          };
        }
        return { schemas };
      }
      const gen = new JSONSchemaGenerator(_params);
      gen.process(input);
      return gen.emit(input, _params);
    }
    const jsonSchema = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null
    }, Symbol.toStringTag, { value: "Module" }));
    const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      $ZodAny,
      $ZodArray,
      $ZodAsyncError,
      $ZodBase64,
      $ZodBase64URL,
      $ZodBigInt,
      $ZodBigIntFormat,
      $ZodBoolean,
      $ZodCIDRv4,
      $ZodCIDRv6,
      $ZodCUID,
      $ZodCUID2,
      $ZodCatch,
      $ZodCheck,
      $ZodCheckBigIntFormat,
      $ZodCheckEndsWith,
      $ZodCheckGreaterThan,
      $ZodCheckIncludes,
      $ZodCheckLengthEquals,
      $ZodCheckLessThan,
      $ZodCheckLowerCase,
      $ZodCheckMaxLength,
      $ZodCheckMaxSize,
      $ZodCheckMimeType,
      $ZodCheckMinLength,
      $ZodCheckMinSize,
      $ZodCheckMultipleOf,
      $ZodCheckNumberFormat,
      $ZodCheckOverwrite,
      $ZodCheckProperty,
      $ZodCheckRegex,
      $ZodCheckSizeEquals,
      $ZodCheckStartsWith,
      $ZodCheckStringFormat,
      $ZodCheckUpperCase,
      $ZodCustom,
      $ZodDate,
      $ZodDefault,
      $ZodDiscriminatedUnion,
      $ZodE164,
      $ZodEmail,
      $ZodEmoji,
      $ZodEnum,
      $ZodError,
      $ZodFile,
      $ZodFunction,
      $ZodGUID,
      $ZodIPv4,
      $ZodIPv6,
      $ZodISODate,
      $ZodISODateTime,
      $ZodISODuration,
      $ZodISOTime,
      $ZodIntersection,
      $ZodJWT,
      $ZodKSUID,
      $ZodLazy,
      $ZodLiteral,
      $ZodMap,
      $ZodNaN,
      $ZodNanoID,
      $ZodNever,
      $ZodNonOptional,
      $ZodNull,
      $ZodNullable,
      $ZodNumber,
      $ZodNumberFormat,
      $ZodObject,
      $ZodOptional,
      $ZodPipe,
      $ZodPrefault,
      $ZodPromise,
      $ZodReadonly,
      $ZodRealError,
      $ZodRecord,
      $ZodRegistry,
      $ZodSet,
      $ZodString,
      $ZodStringFormat,
      $ZodSuccess,
      $ZodSymbol,
      $ZodTemplateLiteral,
      $ZodTransform,
      $ZodTuple,
      $ZodType,
      $ZodULID,
      $ZodURL,
      $ZodUUID,
      $ZodUndefined,
      $ZodUnion,
      $ZodUnknown,
      $ZodVoid,
      $ZodXID,
      $brand,
      $constructor,
      $input,
      $output,
      Doc,
      JSONSchema: jsonSchema,
      JSONSchemaGenerator,
      _any,
      _array,
      _base64,
      _base64url,
      _bigint,
      _boolean,
      _catch: _catch$1,
      _cidrv4,
      _cidrv6,
      _coercedBigint,
      _coercedBoolean,
      _coercedDate,
      _coercedNumber,
      _coercedString,
      _cuid,
      _cuid2,
      _custom,
      _date,
      _default: _default$1,
      _discriminatedUnion,
      _e164,
      _email,
      _emoji,
      _endsWith,
      _enum: _enum$1,
      _file,
      _float32,
      _float64,
      _gt,
      _gte,
      _guid,
      _includes,
      _int,
      _int32,
      _int64,
      _intersection,
      _ipv4,
      _ipv6,
      _isoDate,
      _isoDateTime,
      _isoDuration,
      _isoTime,
      _jwt,
      _ksuid,
      _lazy,
      _length,
      _literal,
      _lowercase,
      _lt,
      _lte,
      _map,
      _max: _lte,
      _maxLength,
      _maxSize,
      _mime,
      _min: _gte,
      _minLength,
      _minSize,
      _multipleOf,
      _nan,
      _nanoid,
      _nativeEnum,
      _negative,
      _never,
      _nonnegative,
      _nonoptional,
      _nonpositive,
      _normalize,
      _null: _null$1,
      _nullable,
      _number,
      _optional,
      _overwrite,
      _parse,
      _parseAsync,
      _pipe,
      _positive,
      _promise,
      _property,
      _readonly,
      _record,
      _refine,
      _regex,
      _safeParse,
      _safeParseAsync,
      _set,
      _size,
      _startsWith,
      _string,
      _stringbool,
      _success,
      _symbol,
      _templateLiteral,
      _toLowerCase,
      _toUpperCase,
      _transform,
      _trim,
      _tuple,
      _uint32,
      _uint64,
      _ulid,
      _undefined: _undefined$1,
      _union,
      _unknown,
      _uppercase,
      _url,
      _uuid,
      _uuidv4,
      _uuidv6,
      _uuidv7,
      _void: _void$1,
      _xid,
      clone,
      config,
      flattenError,
      formatError,
      function: _function,
      globalConfig,
      globalRegistry,
      isValidBase64,
      isValidBase64URL,
      isValidJWT,
      locales: index$1,
      parse: parse$1,
      parseAsync: parseAsync$1,
      prettifyError,
      regexes,
      registry,
      safeParse: safeParse$1,
      safeParseAsync: safeParseAsync$1,
      toDotPath,
      toJSONSchema,
      treeifyError,
      util,
      version: version$1
    }, Symbol.toStringTag, { value: "Module" }));
    const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function datetime(params) {
      return _isoDateTime(ZodISODateTime, params);
    }
    const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function date$2(params) {
      return _isoDate(ZodISODate, params);
    }
    const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function time(params) {
      return _isoTime(ZodISOTime, params);
    }
    const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function duration(params) {
      return _isoDuration(ZodISODuration, params);
    }
    const iso = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      ZodISODate,
      ZodISODateTime,
      ZodISODuration,
      ZodISOTime,
      date: date$2,
      datetime,
      duration,
      time
    }, Symbol.toStringTag, { value: "Module" }));
    const initializer = (inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue2) => inst.issues.push(issue2)
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => inst.issues.push(...issues2)
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    const ZodError = $constructor("ZodError", initializer);
    const ZodRealError = $constructor("ZodError", initializer, {
      Parent: Error
    });
    const parse = /* @__PURE__ */ _parse(ZodRealError);
    const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
    const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
    const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
    function string$1(params) {
      return _coercedString(ZodString, params);
    }
    function number$1(params) {
      return _coercedNumber(ZodNumber, params);
    }
    function boolean$1(params) {
      return _coercedBoolean(ZodBoolean, params);
    }
    function bigint$1(params) {
      return _coercedBigint(ZodBigInt, params);
    }
    function date$1(params) {
      return _coercedDate(ZodDate, params);
    }
    const coerce = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      bigint: bigint$1,
      boolean: boolean$1,
      date: date$1,
      number: number$1,
      string: string$1
    }, Symbol.toStringTag, { value: "Module" }));
    const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      inst.def = def;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(
          {
            ...def,
            checks: [
              ...def.checks ?? [],
              ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
            ]
          }
          // { parent: true }
        );
      };
      inst.clone = (def2, params) => clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = (reg, meta) => {
        reg.add(inst, meta);
        return inst;
      };
      inst.parse = (data2, params) => parse(inst, data2, params, { callee: inst.parse });
      inst.safeParse = (data2, params) => safeParse(inst, data2, params);
      inst.parseAsync = async (data2, params) => parseAsync(inst, data2, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data2, params) => safeParseAsync(inst, data2, params);
      inst.spa = inst.safeParseAsync;
      inst.refine = (check2, params) => inst.check(refine(check2, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      inst.optional = () => optional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array$1(inst);
      inst.or = (arg) => union$1([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          var _a;
          return (_a = globalRegistry.get(inst)) == null ? void 0 : _a.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
    });
    const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (params) => inst.check(_startsWith(params));
      inst.endsWith = (params) => inst.check(_endsWith(params));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
    });
    const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      inst.datetime = (params) => inst.check(datetime(params));
      inst.date = (params) => inst.check(date$2(params));
      inst.time = (params) => inst.check(time(params));
      inst.duration = (params) => inst.check(duration(params));
    });
    function string(params) {
      return _string(ZodString, params);
    }
    const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
    });
    const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function email(params) {
      return _email(ZodEmail, params);
    }
    const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function guid(params) {
      return _guid(ZodGUID, params);
    }
    const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function uuid(params) {
      return _uuid(ZodUUID, params);
    }
    function uuidv4(params) {
      return _uuidv4(ZodUUID, params);
    }
    function uuidv6(params) {
      return _uuidv6(ZodUUID, params);
    }
    function uuidv7(params) {
      return _uuidv7(ZodUUID, params);
    }
    const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function url(params) {
      return _url(ZodURL, params);
    }
    const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function emoji(params) {
      return _emoji(ZodEmoji, params);
    }
    const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function nanoid(params) {
      return _nanoid(ZodNanoID, params);
    }
    const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function cuid(params) {
      return _cuid(ZodCUID, params);
    }
    const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function cuid2(params) {
      return _cuid2(ZodCUID2, params);
    }
    const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function ulid(params) {
      return _ulid(ZodULID, params);
    }
    const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function xid(params) {
      return _xid(ZodXID, params);
    }
    const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function ksuid(params) {
      return _ksuid(ZodKSUID, params);
    }
    const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function ipv4(params) {
      return _ipv4(ZodIPv4, params);
    }
    const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function ipv6(params) {
      return _ipv6(ZodIPv6, params);
    }
    const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function cidrv4(params) {
      return _cidrv4(ZodCIDRv4, params);
    }
    const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function cidrv6(params) {
      return _cidrv6(ZodCIDRv6, params);
    }
    const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function base64(params) {
      return _base64(ZodBase64, params);
    }
    const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function base64url(params) {
      return _base64url(ZodBase64URL, params);
    }
    const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function e164(params) {
      return _e164(ZodE164, params);
    }
    const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    function jwt(params) {
      return _jwt(ZodJWT, params);
    }
    const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType.init(inst, def);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    function number(params) {
      return _number(ZodNumber, params);
    }
    const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber.init(inst, def);
    });
    function int(params) {
      return _int(ZodNumberFormat, params);
    }
    function float32(params) {
      return _float32(ZodNumberFormat, params);
    }
    function float64(params) {
      return _float64(ZodNumberFormat, params);
    }
    function int32(params) {
      return _int32(ZodNumberFormat, params);
    }
    function uint32(params) {
      return _uint32(ZodNumberFormat, params);
    }
    const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType.init(inst, def);
    });
    function boolean(params) {
      return _boolean(ZodBoolean, params);
    }
    const ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType.init(inst, def);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    function bigint(params) {
      return _bigint(ZodBigInt, params);
    }
    const ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt.init(inst, def);
    });
    function int64(params) {
      return _int64(ZodBigIntFormat, params);
    }
    function uint64(params) {
      return _uint64(ZodBigIntFormat, params);
    }
    const ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType.init(inst, def);
    });
    function symbol(params) {
      return _symbol(ZodSymbol, params);
    }
    const ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType.init(inst, def);
    });
    function _undefined(params) {
      return _undefined$1(ZodUndefined, params);
    }
    const ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType.init(inst, def);
    });
    function _null(params) {
      return _null$1(ZodNull, params);
    }
    const ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType.init(inst, def);
    });
    function any() {
      return _any(ZodAny);
    }
    const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType.init(inst, def);
    });
    function unknown() {
      return _unknown(ZodUnknown);
    }
    const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType.init(inst, def);
    });
    function never(params) {
      return _never(ZodNever, params);
    }
    const ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType.init(inst, def);
    });
    function _void(params) {
      return _void$1(ZodVoid, params);
    }
    const ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    function date(params) {
      return _date(ZodDate, params);
    }
    const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
    });
    function array$1(element, params) {
      return _array(ZodArray, element, params);
    }
    function keyof(schema) {
      const shape = schema._zod.def.shape;
      return literal(Object.keys(shape));
    }
    const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
      $ZodObject.init(inst, def);
      ZodType.init(inst, def);
      defineLazy(inst, "shape", () => {
        return Object.fromEntries(Object.entries(inst._zod.def.shape));
      });
      inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return extend(inst, incoming);
      };
      inst.merge = (other) => merge(inst, other);
      inst.pick = (mask) => pick(inst, mask);
      inst.omit = (mask) => omit(inst, mask);
      inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
      inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
    });
    function object(shape, params) {
      const def = {
        type: "object",
        get shape() {
          assignProp(this, "shape", { ...shape });
          return this.shape;
        },
        ...normalizeParams(params)
      };
      return new ZodObject(def);
    }
    function strictObject(shape, params) {
      return new ZodObject({
        type: "object",
        get shape() {
          assignProp(this, "shape", { ...shape });
          return this.shape;
        },
        catchall: never(),
        ...normalizeParams(params)
      });
    }
    function looseObject(shape, params) {
      return new ZodObject({
        type: "object",
        get shape() {
          assignProp(this, "shape", { ...shape });
          return this.shape;
        },
        catchall: unknown(),
        ...normalizeParams(params)
      });
    }
    const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType.init(inst, def);
      inst.options = def.options;
    });
    function union$1(options, params) {
      return new ZodUnion({
        type: "union",
        options,
        ...normalizeParams(params)
      });
    }
    const ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
    });
    function discriminatedUnion(discriminator, options, params) {
      return new ZodDiscriminatedUnion({
        type: "union",
        options,
        discriminator,
        ...normalizeParams(params)
      });
    }
    const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType.init(inst, def);
    });
    function intersection(left, right) {
      return new ZodIntersection({
        type: "intersection",
        left,
        right
      });
    }
    const ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType.init(inst, def);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    function tuple$1(items, _paramsOrRest, _params) {
      const hasRest = _paramsOrRest instanceof $ZodType;
      const params = hasRest ? _params : _paramsOrRest;
      const rest = hasRest ? _paramsOrRest : null;
      return new ZodTuple({
        type: "tuple",
        items,
        rest,
        ...normalizeParams(params)
      });
    }
    const ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    function record(keyType, valueType, params) {
      return new ZodRecord({
        type: "record",
        keyType,
        valueType,
        ...normalizeParams(params)
      });
    }
    function partialRecord(keyType, valueType, params) {
      return new ZodRecord({
        type: "record",
        keyType: union$1([keyType, never()]),
        valueType,
        ...normalizeParams(params)
      });
    }
    const ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    function map(keyType, valueType, params) {
      return new ZodMap({
        type: "map",
        keyType,
        valueType,
        ...normalizeParams(params)
      });
    }
    const ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    function set(valueType, params) {
      return new ZodSet({
        type: "set",
        valueType,
        ...normalizeParams(params)
      });
    }
    const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...normalizeParams(params),
          entries: newEntries
        });
      };
    });
    function _enum(values, params) {
      const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
      return new ZodEnum({
        type: "enum",
        entries,
        ...normalizeParams(params)
      });
    }
    function nativeEnum(entries, params) {
      return new ZodEnum({
        type: "enum",
        entries,
        ...normalizeParams(params)
      });
    }
    const ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    function literal(value, params) {
      return new ZodLiteral({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ...normalizeParams(params)
      });
    }
    const ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types, params) => inst.check(_mime(types, params));
    });
    function file(params) {
      return _file(ZodFile, params);
    }
    const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.addIssue = (issue$1) => {
          if (typeof issue$1 === "string") {
            payload.issues.push(issue(issue$1, payload.value, def));
          } else {
            const _issue = issue$1;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            _issue.continue ?? (_issue.continue = true);
            payload.issues.push(issue(_issue));
          }
        };
        const output2 = def.transform(payload.value, payload);
        if (output2 instanceof Promise) {
          return output2.then((output3) => {
            payload.value = output3;
            return payload;
          });
        }
        payload.value = output2;
        return payload;
      };
    });
    function transform(fn) {
      return new ZodTransform({
        type: "transform",
        transform: fn
      });
    }
    const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function optional(innerType) {
      return new ZodOptional({
        type: "optional",
        innerType
      });
    }
    const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function nullable(innerType) {
      return new ZodNullable({
        type: "nullable",
        innerType
      });
    }
    function nullish(innerType) {
      return optional(nullable(innerType));
    }
    const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    function _default(innerType, defaultValue) {
      return new ZodDefault({
        type: "default",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        }
      });
    }
    const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function prefault(innerType, defaultValue) {
      return new ZodPrefault({
        type: "prefault",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        }
      });
    }
    const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function nonoptional(innerType, params) {
      return new ZodNonOptional({
        type: "nonoptional",
        innerType,
        ...normalizeParams(params)
      });
    }
    const ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function success(innerType) {
      return new ZodSuccess({
        type: "success",
        innerType
      });
    }
    const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    function _catch(innerType, catchValue) {
      return new ZodCatch({
        type: "catch",
        innerType,
        catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
      });
    }
    const ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType.init(inst, def);
    });
    function nan(params) {
      return _nan(ZodNaN, params);
    }
    const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
    });
    function pipe(in_, out) {
      return new ZodPipe({
        type: "pipe",
        in: in_,
        out
        // ...util.normalizeParams(params),
      });
    }
    const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType.init(inst, def);
    });
    function readonly(innerType) {
      return new ZodReadonly({
        type: "readonly",
        innerType
      });
    }
    const ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType.init(inst, def);
    });
    function templateLiteral(parts, params) {
      return new ZodTemplateLiteral({
        type: "template_literal",
        parts,
        ...normalizeParams(params)
      });
    }
    const ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
    });
    function lazy(getter) {
      return new ZodLazy({
        type: "lazy",
        getter
      });
    }
    const ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function promise(innerType) {
      return new ZodPromise({
        type: "promise",
        innerType
      });
    }
    const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType.init(inst, def);
    });
    function check(fn, params) {
      const ch = new $ZodCheck({
        check: "custom",
        ...normalizeParams(params)
      });
      ch._zod.check = fn;
      return ch;
    }
    function custom(fn, _params) {
      return _custom(ZodCustom, fn ?? (() => true), _params);
    }
    function refine(fn, _params = {}) {
      return _custom(ZodCustom, fn, _params);
    }
    function superRefine(fn, params) {
      const ch = check((payload) => {
        payload.addIssue = (issue$1) => {
          if (typeof issue$1 === "string") {
            payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
          } else {
            const _issue = issue$1;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = ch);
            _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
            payload.issues.push(issue(_issue));
          }
        };
        return fn(payload.value, payload);
      }, params);
      return ch;
    }
    function _instanceof(cls, params = {
      error: `Input not instance of ${cls.name}`
    }) {
      const inst = new ZodCustom({
        type: "custom",
        check: "custom",
        fn: (data2) => data2 instanceof cls,
        abort: true,
        ...normalizeParams(params)
      });
      inst._zod.bag.Class = cls;
      return inst;
    }
    const stringbool = /* @__PURE__ */ _stringbool.bind(null, {
      Pipe: ZodPipe,
      Boolean: ZodBoolean,
      Unknown: ZodUnknown
    });
    function json(params) {
      const jsonSchema2 = lazy(() => {
        return union$1([string(params), number(), boolean(), _null(), array$1(jsonSchema2), record(string(), jsonSchema2)]);
      });
      return jsonSchema2;
    }
    function preprocess(fn, schema) {
      return pipe(transform(fn), schema);
    }
    const ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    const INVALID = Object.freeze({
      status: "aborted"
    });
    const NEVER = INVALID;
    function setErrorMap(map2) {
      config({
        customError: map2
      });
    }
    function getErrorMap() {
      return config().customError;
    }
    config(en());
    const z = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      $brand,
      $input,
      $output,
      NEVER,
      ZodAny,
      ZodArray,
      ZodBase64,
      ZodBase64URL,
      ZodBigInt,
      ZodBigIntFormat,
      ZodBoolean,
      ZodCIDRv4,
      ZodCIDRv6,
      ZodCUID,
      ZodCUID2,
      ZodCatch,
      ZodCustom,
      ZodDate,
      ZodDefault,
      ZodDiscriminatedUnion,
      ZodE164,
      ZodEmail,
      ZodEmoji,
      ZodEnum,
      ZodError,
      ZodFile,
      ZodGUID,
      ZodIPv4,
      ZodIPv6,
      ZodIntersection,
      ZodIssueCode,
      ZodJWT,
      ZodKSUID,
      ZodLazy,
      ZodLiteral,
      ZodMap,
      ZodNaN,
      ZodNanoID,
      ZodNever,
      ZodNonOptional,
      ZodNull,
      ZodNullable,
      ZodNumber,
      ZodNumberFormat,
      ZodObject,
      ZodOptional,
      ZodPipe,
      ZodPrefault,
      ZodPromise,
      ZodReadonly,
      ZodRealError,
      ZodRecord,
      ZodSet,
      ZodString,
      ZodStringFormat,
      ZodSuccess,
      ZodSymbol,
      ZodTemplateLiteral,
      ZodTransform,
      ZodTuple,
      ZodType,
      ZodULID,
      ZodURL,
      ZodUUID,
      ZodUndefined,
      ZodUnion,
      ZodUnknown,
      ZodVoid,
      ZodXID,
      _ZodString,
      _default,
      any,
      array: array$1,
      base64,
      base64url,
      bigint,
      boolean,
      catch: _catch,
      check,
      cidrv4,
      cidrv6,
      clone,
      coerce,
      config,
      core: index,
      cuid,
      cuid2,
      custom,
      date,
      discriminatedUnion,
      e164,
      email,
      emoji,
      endsWith: _endsWith,
      enum: _enum,
      file,
      flattenError,
      float32,
      float64,
      formatError,
      function: _function,
      getErrorMap,
      globalRegistry,
      gt: _gt,
      gte: _gte,
      guid,
      includes: _includes,
      instanceof: _instanceof,
      int,
      int32,
      int64,
      intersection,
      ipv4,
      ipv6,
      iso,
      json,
      jwt,
      keyof,
      ksuid,
      lazy,
      length: _length,
      literal,
      locales: index$1,
      looseObject,
      lowercase: _lowercase,
      lt: _lt,
      lte: _lte,
      map,
      maxLength: _maxLength,
      maxSize: _maxSize,
      mime: _mime,
      minLength: _minLength,
      minSize: _minSize,
      multipleOf: _multipleOf,
      nan,
      nanoid,
      nativeEnum,
      negative: _negative,
      never,
      nonnegative: _nonnegative,
      nonoptional,
      nonpositive: _nonpositive,
      normalize: _normalize,
      null: _null,
      nullable,
      nullish,
      number,
      object,
      optional,
      overwrite: _overwrite,
      parse,
      parseAsync,
      partialRecord,
      pipe,
      positive: _positive,
      prefault,
      preprocess,
      prettifyError,
      promise,
      property: _property,
      readonly,
      record,
      refine,
      regex: _regex,
      regexes,
      registry,
      safeParse,
      safeParseAsync,
      set,
      setErrorMap,
      size: _size,
      startsWith: _startsWith,
      strictObject,
      string,
      stringbool,
      success,
      superRefine,
      symbol,
      templateLiteral,
      toJSONSchema,
      toLowerCase: _toLowerCase,
      toUpperCase: _toUpperCase,
      transform,
      treeifyError,
      trim: _trim,
      tuple: tuple$1,
      uint32,
      uint64,
      ulid,
      undefined: _undefined,
      union: union$1,
      unknown,
      uppercase: _uppercase,
      url,
      uuid,
      uuidv4,
      uuidv6,
      uuidv7,
      void: _void,
      xid
    }, Symbol.toStringTag, { value: "Module" }));
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    function base64URLtoBytes(base642) {
      base642 = base642.replace(/=/g, "");
      const n = base642.length;
      const rem = n % 4;
      const k = rem && rem - 1;
      const m = (n >> 2) * 3 + k;
      const encoded = new Uint8Array(n + 3);
      encoder.encodeInto(base642 + "===", encoded);
      for (let i = 0, j = 0; i < n; i += 4, j += 3) {
        const x = (lookup[encoded[i]] << 18) + (lookup[encoded[i + 1]] << 12) + (lookup[encoded[i + 2]] << 6) + lookup[encoded[i + 3]];
        encoded[j] = x >> 16;
        encoded[j + 1] = x >> 8 & 255;
        encoded[j + 2] = x & 255;
      }
      return new Uint8Array(encoded.buffer, 0, m);
    }
    function bytesToBase64url(bytes) {
      const m = bytes.length;
      const k = m % 3;
      const n = Math.floor(m / 3) * 4 + (k && k + 1);
      const N = Math.ceil(m / 3) * 4;
      const encoded = new Uint8Array(N);
      for (let i = 0, j = 0; j < m; i += 4, j += 3) {
        const y = (bytes[j] << 16) + (bytes[j + 1] << 8) + (bytes[j + 2] | 0);
        encoded[i] = encodeLookup[y >> 18];
        encoded[i + 1] = encodeLookup[y >> 12 & 63];
        encoded[i + 2] = encodeLookup[y >> 6 & 63];
        encoded[i + 3] = encodeLookup[y & 63];
      }
      let base642 = decoder.decode(new Uint8Array(encoded.buffer, 0, n));
      if (k === 1)
        base642 += "==";
      if (k === 2)
        base642 += "=";
      return base642;
    }
    const alphabet$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    const lookup = new Uint8Array(128);
    for (const [i, a] of Array.from(alphabet$2).entries()) {
      lookup[a.charCodeAt(0)] = i;
    }
    lookup["=".charCodeAt(0)] = 0;
    const encodeLookup = new Uint8Array(64);
    for (const [i, a] of Array.from(alphabet$2).entries()) {
      encodeLookup[i] = a.charCodeAt(0);
    }
    var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
    var VERSION = "1.9.0";
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
      var rejectedVersions = /* @__PURE__ */ new Set();
      var myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        return function() {
          return false;
        };
      }
      var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        };
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      return function isCompatible2(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          return _reject(globalVersion);
        }
        var globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      };
    }
    var isCompatible = _makeCompatibilityCheck(VERSION);
    var major = VERSION.split(".")[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    var _global = _globalThis;
    function registerGlobal(type, instance, diag, allowOverride) {
      var _a;
      if (allowOverride === void 0) {
        allowOverride = false;
      }
      var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: VERSION
      };
      if (!allowOverride && api[type]) {
        var err2 = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err2.stack || err2.message);
        return false;
      }
      if (api.version !== VERSION) {
        var err2 = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
        diag.error(err2.stack || err2.message);
        return false;
      }
      api[type] = instance;
      diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
      return true;
    }
    function getGlobal(type) {
      var _a, _b;
      var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!globalVersion || !isCompatible(globalVersion)) {
        return;
      }
      return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
    }
    function unregisterGlobal(type, diag) {
      diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
      var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type];
      }
    }
    var __read$1 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r2, ar2 = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar2.push(r2.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r2 && !r2.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar2;
    };
    var __spreadArray$1 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar2; i < l; i++) {
        if (ar2 || !(i in from)) {
          if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i);
          ar2[i] = from[i];
        }
      }
      return to.concat(ar2 || Array.prototype.slice.call(from));
    };
    var DiagComponentLogger = (
      /** @class */
      function() {
        function DiagComponentLogger2(props) {
          this._namespace = props.namespace || "DiagComponentLogger";
        }
        DiagComponentLogger2.prototype.debug = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return logProxy("debug", this._namespace, args);
        };
        DiagComponentLogger2.prototype.error = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return logProxy("error", this._namespace, args);
        };
        DiagComponentLogger2.prototype.info = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return logProxy("info", this._namespace, args);
        };
        DiagComponentLogger2.prototype.warn = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return logProxy("warn", this._namespace, args);
        };
        DiagComponentLogger2.prototype.verbose = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return logProxy("verbose", this._namespace, args);
        };
        return DiagComponentLogger2;
      }()
    );
    function logProxy(funcName, namespace, args) {
      var logger2 = getGlobal("diag");
      if (!logger2) {
        return;
      }
      args.unshift(namespace);
      return logger2[funcName].apply(logger2, __spreadArray$1([], __read$1(args), false));
    }
    var DiagLogLevel;
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
    function createLogLevelDiagLogger(maxLevel, logger2) {
      if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
      } else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
      }
      logger2 = logger2 || {};
      function _filterFunc(funcName, theLevel) {
        var theFunc = logger2[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
          return theFunc.bind(logger2);
        }
        return function() {
        };
      }
      return {
        error: _filterFunc("error", DiagLogLevel.ERROR),
        warn: _filterFunc("warn", DiagLogLevel.WARN),
        info: _filterFunc("info", DiagLogLevel.INFO),
        debug: _filterFunc("debug", DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
      };
    }
    var __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r2, ar2 = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar2.push(r2.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r2 && !r2.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar2;
    };
    var __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar2; i < l; i++) {
        if (ar2 || !(i in from)) {
          if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i);
          ar2[i] = from[i];
        }
      }
      return to.concat(ar2 || Array.prototype.slice.call(from));
    };
    var API_NAME$1 = "diag";
    var DiagAPI = (
      /** @class */
      function() {
        function DiagAPI2() {
          function _logProxy(funcName) {
            return function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var logger2 = getGlobal("diag");
              if (!logger2)
                return;
              return logger2[funcName].apply(logger2, __spreadArray([], __read(args), false));
            };
          }
          var self2 = this;
          var setLogger = function(logger2, optionsOrLogLevel) {
            var _a, _b, _c;
            if (optionsOrLogLevel === void 0) {
              optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
            }
            if (logger2 === self2) {
              var err2 = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
              self2.error((_a = err2.stack) !== null && _a !== void 0 ? _a : err2.message);
              return false;
            }
            if (typeof optionsOrLogLevel === "number") {
              optionsOrLogLevel = {
                logLevel: optionsOrLogLevel
              };
            }
            var oldLogger = getGlobal("diag");
            var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger2);
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
              var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
              oldLogger.warn("Current logger will be overwritten from " + stack);
              newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal("diag", newLogger, self2, true);
          };
          self2.setLogger = setLogger;
          self2.disable = function() {
            unregisterGlobal(API_NAME$1, self2);
          };
          self2.createComponentLogger = function(options) {
            return new DiagComponentLogger(options);
          };
          self2.verbose = _logProxy("verbose");
          self2.debug = _logProxy("debug");
          self2.info = _logProxy("info");
          self2.warn = _logProxy("warn");
          self2.error = _logProxy("error");
        }
        DiagAPI2.instance = function() {
          if (!this._instance) {
            this._instance = new DiagAPI2();
          }
          return this._instance;
        };
        return DiagAPI2;
      }()
    );
    var __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var NoopMeter = (
      /** @class */
      function() {
        function NoopMeter2() {
        }
        NoopMeter2.prototype.createGauge = function(_name, _options) {
          return NOOP_GAUGE_METRIC;
        };
        NoopMeter2.prototype.createHistogram = function(_name, _options) {
          return NOOP_HISTOGRAM_METRIC;
        };
        NoopMeter2.prototype.createCounter = function(_name, _options) {
          return NOOP_COUNTER_METRIC;
        };
        NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
          return NOOP_UP_DOWN_COUNTER_METRIC;
        };
        NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
          return NOOP_OBSERVABLE_GAUGE_METRIC;
        };
        NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
          return NOOP_OBSERVABLE_COUNTER_METRIC;
        };
        NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
          return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
        };
        NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
        };
        NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
        };
        return NoopMeter2;
      }()
    );
    var NoopMetric = (
      /** @class */
      /* @__PURE__ */ function() {
        function NoopMetric2() {
        }
        return NoopMetric2;
      }()
    );
    var NoopCounterMetric = (
      /** @class */
      function(_super) {
        __extends(NoopCounterMetric2, _super);
        function NoopCounterMetric2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NoopCounterMetric2.prototype.add = function(_value, _attributes) {
        };
        return NoopCounterMetric2;
      }(NoopMetric)
    );
    var NoopUpDownCounterMetric = (
      /** @class */
      function(_super) {
        __extends(NoopUpDownCounterMetric2, _super);
        function NoopUpDownCounterMetric2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
        };
        return NoopUpDownCounterMetric2;
      }(NoopMetric)
    );
    var NoopGaugeMetric = (
      /** @class */
      function(_super) {
        __extends(NoopGaugeMetric2, _super);
        function NoopGaugeMetric2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
        };
        return NoopGaugeMetric2;
      }(NoopMetric)
    );
    var NoopHistogramMetric = (
      /** @class */
      function(_super) {
        __extends(NoopHistogramMetric2, _super);
        function NoopHistogramMetric2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
        };
        return NoopHistogramMetric2;
      }(NoopMetric)
    );
    var NoopObservableMetric = (
      /** @class */
      function() {
        function NoopObservableMetric2() {
        }
        NoopObservableMetric2.prototype.addCallback = function(_callback) {
        };
        NoopObservableMetric2.prototype.removeCallback = function(_callback) {
        };
        return NoopObservableMetric2;
      }()
    );
    var NoopObservableCounterMetric = (
      /** @class */
      function(_super) {
        __extends(NoopObservableCounterMetric2, _super);
        function NoopObservableCounterMetric2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return NoopObservableCounterMetric2;
      }(NoopObservableMetric)
    );
    var NoopObservableGaugeMetric = (
      /** @class */
      function(_super) {
        __extends(NoopObservableGaugeMetric2, _super);
        function NoopObservableGaugeMetric2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return NoopObservableGaugeMetric2;
      }(NoopObservableMetric)
    );
    var NoopObservableUpDownCounterMetric = (
      /** @class */
      function(_super) {
        __extends(NoopObservableUpDownCounterMetric2, _super);
        function NoopObservableUpDownCounterMetric2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return NoopObservableUpDownCounterMetric2;
      }(NoopObservableMetric)
    );
    var NOOP_METER = new NoopMeter();
    var NOOP_COUNTER_METRIC = new NoopCounterMetric();
    var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
    var ValueType;
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
    var NoopMeterProvider = (
      /** @class */
      function() {
        function NoopMeterProvider2() {
        }
        NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
          return NOOP_METER;
        };
        return NoopMeterProvider2;
      }()
    );
    var NOOP_METER_PROVIDER = new NoopMeterProvider();
    var API_NAME = "metrics";
    var MetricsAPI = (
      /** @class */
      function() {
        function MetricsAPI2() {
        }
        MetricsAPI2.getInstance = function() {
          if (!this._instance) {
            this._instance = new MetricsAPI2();
          }
          return this._instance;
        };
        MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
          return registerGlobal(API_NAME, provider, DiagAPI.instance());
        };
        MetricsAPI2.prototype.getMeterProvider = function() {
          return getGlobal(API_NAME) || NOOP_METER_PROVIDER;
        };
        MetricsAPI2.prototype.getMeter = function(name, version2, options) {
          return this.getMeterProvider().getMeter(name, version2, options);
        };
        MetricsAPI2.prototype.disable = function() {
          unregisterGlobal(API_NAME, DiagAPI.instance());
        };
        return MetricsAPI2;
      }()
    );
    var metrics = MetricsAPI.getInstance();
    const defaultErrorConfig = {
      withStackTrace: false
    };
    const createNeverThrowError = (message, result, config2 = defaultErrorConfig) => {
      const data2 = result.isOk() ? { type: "Ok", value: result.value } : { type: "Err", value: result.error };
      const maybeStack = config2.withStackTrace ? new Error().stack : void 0;
      return {
        data: data2,
        message,
        stack: maybeStack
      };
    };
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, [])).next());
      });
    }
    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n]) i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }
    function __asyncDelegator(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
        } : f;
      }
    }
    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    }
    class ResultAsync {
      constructor(res) {
        this._promise = res;
      }
      static fromSafePromise(promise2) {
        const newPromise = promise2.then((value) => new Ok(value));
        return new ResultAsync(newPromise);
      }
      static fromPromise(promise2, errorFn) {
        const newPromise = promise2.then((value) => new Ok(value)).catch((e) => new Err(errorFn(e)));
        return new ResultAsync(newPromise);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static fromThrowable(fn, errorFn) {
        return (...args) => {
          return new ResultAsync((() => __awaiter(this, void 0, void 0, function* () {
            try {
              return new Ok(yield fn(...args));
            } catch (error2) {
              return new Err(errorFn ? errorFn(error2) : error2);
            }
          }))());
        };
      }
      static combine(asyncResultList) {
        return combineResultAsyncList(asyncResultList);
      }
      static combineWithAllErrors(asyncResultList) {
        return combineResultAsyncListWithAllErrors(asyncResultList);
      }
      map(f) {
        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
          if (res.isErr()) {
            return new Err(res.error);
          }
          return new Ok(yield f(res.value));
        })));
      }
      andThrough(f) {
        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
          if (res.isErr()) {
            return new Err(res.error);
          }
          const newRes = yield f(res.value);
          if (newRes.isErr()) {
            return new Err(newRes.error);
          }
          return new Ok(res.value);
        })));
      }
      andTee(f) {
        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
          if (res.isErr()) {
            return new Err(res.error);
          }
          try {
            yield f(res.value);
          } catch (e) {
          }
          return new Ok(res.value);
        })));
      }
      mapErr(f) {
        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
          if (res.isOk()) {
            return new Ok(res.value);
          }
          return new Err(yield f(res.error));
        })));
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      andThen(f) {
        return new ResultAsync(this._promise.then((res) => {
          if (res.isErr()) {
            return new Err(res.error);
          }
          const newValue = f(res.value);
          return newValue instanceof ResultAsync ? newValue._promise : newValue;
        }));
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      orElse(f) {
        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
          if (res.isErr()) {
            return f(res.error);
          }
          return new Ok(res.value);
        })));
      }
      match(ok2, _err) {
        return this._promise.then((res) => res.match(ok2, _err));
      }
      unwrapOr(t) {
        return this._promise.then((res) => res.unwrapOr(t));
      }
      /**
       * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.
       */
      safeUnwrap() {
        return __asyncGenerator(this, arguments, function* safeUnwrap_1() {
          return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));
        });
      }
      // Makes ResultAsync implement PromiseLike<Result>
      then(successCallback, failureCallback) {
        return this._promise.then(successCallback, failureCallback);
      }
    }
    const errAsync = (err2) => new ResultAsync(Promise.resolve(new Err(err2)));
    const combineResultList = (resultList) => {
      let acc = ok([]);
      for (const result of resultList) {
        if (result.isErr()) {
          acc = err(result.error);
          break;
        } else {
          acc.map((list) => list.push(result.value));
        }
      }
      return acc;
    };
    const combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);
    const combineResultListWithAllErrors = (resultList) => {
      let acc = ok([]);
      for (const result of resultList) {
        if (result.isErr() && acc.isErr()) {
          acc.error.push(result.error);
        } else if (result.isErr() && acc.isOk()) {
          acc = err([result.error]);
        } else if (result.isOk() && acc.isOk()) {
          acc.value.push(result.value);
        }
      }
      return acc;
    };
    const combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);
    var Result;
    (function(Result2) {
      function fromThrowable(fn, errorFn) {
        return (...args) => {
          try {
            const result = fn(...args);
            return ok(result);
          } catch (e) {
            return err(errorFn ? errorFn(e) : e);
          }
        };
      }
      Result2.fromThrowable = fromThrowable;
      function combine(resultList) {
        return combineResultList(resultList);
      }
      Result2.combine = combine;
      function combineWithAllErrors(resultList) {
        return combineResultListWithAllErrors(resultList);
      }
      Result2.combineWithAllErrors = combineWithAllErrors;
    })(Result || (Result = {}));
    const ok = (value) => new Ok(value);
    function err(err2) {
      return new Err(err2);
    }
    class Ok {
      constructor(value) {
        this.value = value;
      }
      isOk() {
        return true;
      }
      isErr() {
        return !this.isOk();
      }
      map(f) {
        return ok(f(this.value));
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      mapErr(_f) {
        return ok(this.value);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      andThen(f) {
        return f(this.value);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      andThrough(f) {
        return f(this.value).map((_value) => this.value);
      }
      andTee(f) {
        try {
          f(this.value);
        } catch (e) {
        }
        return ok(this.value);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      orElse(_f) {
        return ok(this.value);
      }
      asyncAndThen(f) {
        return f(this.value);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      asyncAndThrough(f) {
        return f(this.value).map(() => this.value);
      }
      asyncMap(f) {
        return ResultAsync.fromSafePromise(f(this.value));
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      unwrapOr(_v) {
        return this.value;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      match(ok2, _err) {
        return ok2(this.value);
      }
      safeUnwrap() {
        const value = this.value;
        return function* () {
          return value;
        }();
      }
      _unsafeUnwrap(_) {
        return this.value;
      }
      _unsafeUnwrapErr(config2) {
        throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, config2);
      }
    }
    class Err {
      constructor(error2) {
        this.error = error2;
      }
      isOk() {
        return false;
      }
      isErr() {
        return !this.isOk();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      map(_f) {
        return err(this.error);
      }
      mapErr(f) {
        return err(f(this.error));
      }
      andThrough(_f) {
        return err(this.error);
      }
      andTee(_f) {
        return err(this.error);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      andThen(_f) {
        return err(this.error);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      orElse(f) {
        return f(this.error);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      asyncAndThen(_f) {
        return errAsync(this.error);
      }
      asyncAndThrough(_f) {
        return errAsync(this.error);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      asyncMap(_f) {
        return errAsync(this.error);
      }
      unwrapOr(v) {
        return v;
      }
      match(_ok, err2) {
        return err2(this.error);
      }
      safeUnwrap() {
        const error2 = this.error;
        return function* () {
          yield err(error2);
          throw new Error("Do not use this generator out of `safeTry`");
        }();
      }
      _unsafeUnwrap(config2) {
        throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, config2);
      }
      _unsafeUnwrapErr(_) {
        return this.error;
      }
    }
    Result.fromThrowable;
    const MAX_RECOMMENDED_TX_SIZE = 100 * 1024;
    const CO_VALUE_LOADING_CONFIG = {
      MAX_RETRIES: 1,
      TIMEOUT: 3e4,
      RETRY_DELAY: 3e3
    };
    function setCoValueLoadingRetryDelay(delay) {
      CO_VALUE_LOADING_CONFIG.RETRY_DELAY = delay;
    }
    const SYNC_SCHEDULER_CONFIG = {
      INCOMING_MESSAGES_TIME_BUDGET: 50
    };
    function setIncomingMessagesTimeBudget(budget) {
      SYNC_SCHEDULER_CONFIG.INCOMING_MESSAGES_TIME_BUDGET = budget;
    }
    class RawUnknownCoValue {
      constructor(core) {
        this.totalValidTransactions = 0;
        this.id = core.id;
        this.core = core;
      }
      get type() {
        return this.core.verified.header.type;
      }
      get headerMeta() {
        return this.core.verified.header.meta;
      }
      /** @category 6. Meta */
      get group() {
        return this.core.getGroup();
      }
      toJSON() {
        return {};
      }
      atTime() {
        return this;
      }
      subscribe(listener) {
        return this.core.subscribe((core) => {
          listener(core.getCurrentContent());
        });
      }
    }
    function expectMap(content) {
      if (content.type !== "comap") {
        throw new Error("Expected map");
      }
      return content;
    }
    const LogLevel = {
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3
    };
    class ConsoleLogSystem {
      debug(message, attributes) {
        console.debug(message, attributes);
      }
      info(message, attributes) {
        console.info(message, attributes);
      }
      warn(message, attributes) {
        console.warn(message, attributes);
      }
      error(message, attributes) {
        console.error(message, attributes);
      }
    }
    class Logger {
      constructor(level = LogLevel.INFO, logSystem = new ConsoleLogSystem()) {
        this.level = level;
        this.logSystem = logSystem;
      }
      setLevel(level) {
        this.level = level;
      }
      setLogSystem(logSystem) {
        this.logSystem = logSystem;
      }
      debug(message, attributes) {
        if (this.level <= LogLevel.DEBUG) {
          this.logSystem.debug(message, attributes);
        }
      }
      info(message, attributes) {
        if (this.level <= LogLevel.INFO) {
          this.logSystem.info(message, attributes);
        }
      }
      warn(message, attributes) {
        if (this.level <= LogLevel.WARN) {
          this.logSystem.warn(message, attributes);
        }
      }
      error(message, attributes) {
        if (this.level <= LogLevel.ERROR) {
          this.logSystem.error(message, attributes);
        }
      }
    }
    const logger = new Logger();
    function accountOrAgentIDfromSessionID(sessionID) {
      const until = sessionID.indexOf("_session");
      return sessionID.slice(0, until);
    }
    class RawCoList {
      /** @internal */
      constructor(core) {
        this.type = "colist";
        this.totalValidTransactions = 0;
        this.knownTransactions = {};
        this.id = core.id;
        this.core = core;
        this.insertions = {};
        this.deletionsByInsertion = {};
        this.afterStart = [];
        this.beforeEnd = [];
        this.knownTransactions = {};
        this.processNewTransactions();
      }
      processNewTransactions() {
        var _a, _b, _c, _d;
        const transactions = this.core.getValidSortedTransactions({
          ignorePrivateTransactions: false,
          knownTransactions: this.knownTransactions
        });
        if (transactions.length === 0) {
          return;
        }
        this.totalValidTransactions += transactions.length;
        let lastValidTransaction = void 0;
        let oldestValidTransaction = void 0;
        this._cachedEntries = void 0;
        for (const { txID, changes, madeAt } of transactions) {
          lastValidTransaction = Math.max(lastValidTransaction ?? 0, madeAt);
          oldestValidTransaction = Math.min(oldestValidTransaction ?? Infinity, madeAt);
          this.knownTransactions[txID.sessionID] = Math.max(this.knownTransactions[txID.sessionID] ?? 0, txID.txIndex);
          for (const [changeIdx, changeUntyped] of changes.entries()) {
            const change = changeUntyped;
            if (change.op === "pre" || change.op === "app") {
              let sessionEntry = this.insertions[txID.sessionID];
              if (!sessionEntry) {
                sessionEntry = {};
                this.insertions[txID.sessionID] = sessionEntry;
              }
              let txEntry = sessionEntry[txID.txIndex];
              if (!txEntry) {
                txEntry = {};
                sessionEntry[txID.txIndex] = txEntry;
              }
              txEntry[changeIdx] = {
                madeAt,
                predecessors: [],
                successors: [],
                ...change
              };
              if (change.op === "pre") {
                if (change.before === "end") {
                  this.beforeEnd.push({
                    ...txID,
                    changeIdx
                  });
                } else {
                  const beforeEntry = (_b = (_a = this.insertions[change.before.sessionID]) == null ? void 0 : _a[change.before.txIndex]) == null ? void 0 : _b[change.before.changeIdx];
                  if (!beforeEntry) {
                    continue;
                  }
                  beforeEntry.predecessors.splice(0, 0, {
                    ...txID,
                    changeIdx
                  });
                }
              } else {
                if (change.after === "start") {
                  this.afterStart.push({
                    ...txID,
                    changeIdx
                  });
                } else {
                  const afterEntry = (_d = (_c = this.insertions[change.after.sessionID]) == null ? void 0 : _c[change.after.txIndex]) == null ? void 0 : _d[change.after.changeIdx];
                  if (!afterEntry) {
                    continue;
                  }
                  afterEntry.successors.push({
                    ...txID,
                    changeIdx
                  });
                }
              }
            } else if (change.op === "del") {
              let sessionEntry = this.deletionsByInsertion[change.insertion.sessionID];
              if (!sessionEntry) {
                sessionEntry = {};
                this.deletionsByInsertion[change.insertion.sessionID] = sessionEntry;
              }
              let txEntry = sessionEntry[change.insertion.txIndex];
              if (!txEntry) {
                txEntry = {};
                sessionEntry[change.insertion.txIndex] = txEntry;
              }
              let changeEntry = txEntry[change.insertion.changeIdx];
              if (!changeEntry) {
                changeEntry = [];
                txEntry[change.insertion.changeIdx] = changeEntry;
              }
              changeEntry.push({
                madeAt,
                deletionID: {
                  ...txID,
                  changeIdx
                },
                ...change
              });
            } else {
              throw new Error("Unknown list operation " + change.op);
            }
          }
        }
        if (this.lastValidTransaction && oldestValidTransaction && oldestValidTransaction < this.lastValidTransaction) {
          this.rebuildFromCore();
        } else {
          this.lastValidTransaction = lastValidTransaction;
        }
      }
      /** @category 6. Meta */
      get headerMeta() {
        return this.core.verified.header.meta;
      }
      /** @category 6. Meta */
      get group() {
        return this.core.getGroup();
      }
      /**
       * Not yet implemented
       *
       * @category 4. Time travel
       */
      atTime(_time) {
        throw new Error("Not yet implemented");
      }
      /**
       * Get the item currently at `idx`.
       *
       * @category 1. Reading
       */
      get(idx) {
        const entry = this.entries()[idx];
        if (!entry) {
          return void 0;
        }
        return entry.value;
      }
      /**
       * Returns the current items in the CoList as an array.
       *
       * @category 1. Reading
       **/
      asArray() {
        return this.entries().map((entry) => entry.value);
      }
      /** @internal */
      entries() {
        if (this._cachedEntries) {
          return this._cachedEntries;
        }
        const arr = this.entriesUncached();
        this._cachedEntries = arr;
        return arr;
      }
      /** @internal */
      entriesUncached() {
        const arr = [];
        for (const opID of this.afterStart) {
          this.fillArrayFromOpID(opID, arr);
        }
        for (const opID of this.beforeEnd) {
          this.fillArrayFromOpID(opID, arr);
        }
        return arr;
      }
      /** @internal */
      fillArrayFromOpID(opID, arr) {
        var _a, _b, _c, _d, _e;
        const todo = [opID];
        const predecessorsVisited = /* @__PURE__ */ new Set();
        while (todo.length > 0) {
          const currentOpID = todo[todo.length - 1];
          const entry = (_b = (_a = this.insertions[currentOpID.sessionID]) == null ? void 0 : _a[currentOpID.txIndex]) == null ? void 0 : _b[currentOpID.changeIdx];
          if (!entry) {
            throw new Error("Missing op " + currentOpID);
          }
          const shouldTraversePredecessors = entry.predecessors.length > 0 && !predecessorsVisited.has(currentOpID);
          if (shouldTraversePredecessors) {
            for (let i = entry.predecessors.length - 1; i >= 0; i--) {
              todo.push(entry.predecessors[i]);
            }
            predecessorsVisited.add(currentOpID);
          } else {
            todo.pop();
            const deleted = (((_e = (_d = (_c = this.deletionsByInsertion[currentOpID.sessionID]) == null ? void 0 : _c[currentOpID.txIndex]) == null ? void 0 : _d[currentOpID.changeIdx]) == null ? void 0 : _e.length) || 0) > 0;
            if (!deleted) {
              arr.push({
                value: entry.value,
                madeAt: entry.madeAt,
                opID: currentOpID
              });
            }
            for (const successor of entry.successors) {
              todo.push(successor);
            }
          }
        }
      }
      /**
       * Returns the current items in the CoList as an array. (alias of `asArray`)
       *
       * @category 1. Reading
       */
      toJSON() {
        return this.asArray();
      }
      /** @category 5. Edit history */
      editAt(idx) {
        const entry = this.entries()[idx];
        if (!entry) {
          return void 0;
        }
        const madeAt = new Date(entry.madeAt);
        const by = accountOrAgentIDfromSessionID(entry.opID.sessionID);
        const value = entry.value;
        return {
          by,
          tx: {
            sessionID: entry.opID.sessionID,
            txIndex: entry.opID.txIndex
          },
          at: madeAt,
          value
        };
      }
      /** @category 5. Edit history */
      deletionEdits() {
        const edits = [];
        for (const sessionID in this.deletionsByInsertion) {
          const sessionEntry = this.deletionsByInsertion[sessionID];
          for (const txIdx in sessionEntry) {
            const txEntry = sessionEntry[Number(txIdx)];
            for (const changeIdx in txEntry) {
              const changeEntry = txEntry[Number(changeIdx)];
              for (const deletion of changeEntry || []) {
                const madeAt = new Date(deletion.madeAt);
                const by = accountOrAgentIDfromSessionID(deletion.deletionID.sessionID);
                edits.push({
                  by,
                  tx: deletion.deletionID,
                  at: madeAt
                });
              }
            }
          }
        }
        return edits;
      }
      /** @category 3. Subscription */
      subscribe(listener) {
        return this.core.subscribe((core) => {
          listener(core.getCurrentContent());
        });
      }
      /** Appends `item` after the item currently at index `after`.
       *
       * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
       *
       * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
       *
       * @category 2. Editing
       **/
      append(item, after, privacy = "private") {
        this.appendItems([item], after, privacy);
      }
      /**
       * Appends `items` to the list at index `after`. If `after` is negative, it is treated as `0`.
       *
       * If `privacy` is `"private"` **(default)**, `items` are encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
       *
       * If `privacy` is `"trusting"`, `items` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
       *
       * @category 2. Editing
       */
      appendItems(items, after, privacy = "private") {
        const entries = this.entries();
        after = after === void 0 ? entries.length > 0 ? entries.length - 1 : 0 : Math.max(0, after);
        let opIDBefore;
        if (entries.length > 0) {
          const entryBefore = entries[after];
          if (!entryBefore) {
            throw new Error("Invalid index " + after);
          }
          opIDBefore = entryBefore.opID;
        } else {
          if (after !== 0) {
            throw new Error("Invalid index " + after);
          }
          opIDBefore = "start";
        }
        const changes = items.map((item) => ({
          op: "app",
          value: isCoValue(item) ? item.id : item,
          after: opIDBefore
        }));
        if (opIDBefore !== "start") {
          changes.reverse();
        }
        this.core.makeTransaction(changes, privacy);
        this.processNewTransactions();
      }
      /**
       * Prepends `item` before the item currently at index `before`.
       *
       * If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
       *
       * If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
       *
       * @category 2. Editing
       */
      prepend(item, before, privacy = "private") {
        const entries = this.entries();
        before = before === void 0 ? 0 : before;
        let opIDAfter;
        if (entries.length > 0) {
          const entryAfter = entries[before];
          if (entryAfter) {
            opIDAfter = entryAfter.opID;
          } else {
            if (before !== entries.length) {
              throw new Error("Invalid index " + before);
            }
            opIDAfter = "end";
          }
        } else {
          if (before !== 0) {
            throw new Error("Invalid index " + before);
          }
          opIDAfter = "end";
        }
        this.core.makeTransaction([
          {
            op: "pre",
            value: isCoValue(item) ? item.id : item,
            before: opIDAfter
          }
        ], privacy);
        this.processNewTransactions();
      }
      /** Deletes the item at index `at`.
       *
       * If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.
       *
       * If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
       *
       * @category 2. Editing
       **/
      delete(at, privacy = "private") {
        const entries = this.entries();
        const entry = entries[at];
        if (!entry) {
          throw new Error("Invalid index " + at);
        }
        this.core.makeTransaction([
          {
            op: "del",
            insertion: entry.opID
          }
        ], privacy);
        this.processNewTransactions();
      }
      replace(at, newItem, privacy = "private") {
        const entries = this.entries();
        const entry = entries[at];
        if (!entry) {
          throw new Error("Invalid index " + at);
        }
        this.core.makeTransaction([
          {
            op: "app",
            value: isCoValue(newItem) ? newItem.id : newItem,
            after: entry.opID
          },
          {
            op: "del",
            insertion: entry.opID
          }
        ], privacy);
        this.processNewTransactions();
      }
      /** @internal */
      rebuildFromCore() {
        const listAfter = new RawCoList(this.core);
        this.afterStart = listAfter.afterStart;
        this.beforeEnd = listAfter.beforeEnd;
        this.insertions = listAfter.insertions;
        this.totalValidTransactions = listAfter.totalValidTransactions;
        this.lastValidTransaction = listAfter.lastValidTransaction;
        this.knownTransactions = listAfter.knownTransactions;
        this.deletionsByInsertion = listAfter.deletionsByInsertion;
        this._cachedEntries = void 0;
      }
    }
    function isAccountID$1(id2) {
      return id2.startsWith("co_");
    }
    class RawCoStreamView {
      constructor(core) {
        this.type = "costream";
        this.totalValidTransactions = 0;
        this.id = core.id;
        this.core = core;
        this.items = {};
        this.knownTransactions = {};
        this.processNewTransactions();
      }
      get headerMeta() {
        return this.core.verified.header.meta;
      }
      get group() {
        return this.core.getGroup();
      }
      /** Not yet implemented */
      atTime(_time) {
        throw new Error("Not yet implemented");
      }
      /** @internal */
      compareStreamItems(a, b) {
        return a.madeAt - b.madeAt || (a.tx.sessionID === b.tx.sessionID ? 0 : a.tx.sessionID < b.tx.sessionID ? -1 : 1) || a.tx.txIndex - b.tx.txIndex;
      }
      /** @internal */
      processNewTransactions() {
        const changeEntries = /* @__PURE__ */ new Set();
        const newValidTransactions = this.core.getValidTransactions({
          ignorePrivateTransactions: false,
          knownTransactions: this.knownTransactions
        });
        if (newValidTransactions.length === 0) {
          return;
        }
        for (const { txID, madeAt, changes } of newValidTransactions) {
          this.totalValidTransactions++;
          for (const changeUntyped of changes) {
            const change = changeUntyped;
            let entries = this.items[txID.sessionID];
            if (!entries) {
              entries = [];
              this.items[txID.sessionID] = entries;
            }
            entries.push({ value: change, madeAt, tx: txID });
            changeEntries.add(entries);
          }
          this.knownTransactions[txID.sessionID] = Math.max(this.knownTransactions[txID.sessionID] ?? 0, txID.txIndex);
        }
        for (const entries of changeEntries) {
          entries.sort(this.compareStreamItems);
        }
      }
      getSingleStream() {
        const streams = Object.values(this.items);
        const firstStream = streams[0];
        if (!firstStream) {
          return void 0;
        }
        if (streams.length > 1) {
          throw new Error("CoStream.getSingleStream() can only be called when there is exactly one stream");
        }
        return firstStream.map((item) => item.value);
      }
      sessions() {
        return Object.keys(this.items);
      }
      accounts() {
        return new Set(this.sessions().map(accountOrAgentIDfromSessionID).filter(isAccountID$1));
      }
      nthItemIn(sessionID, n) {
        const items = this.items[sessionID];
        if (!items)
          return;
        const item = items[n];
        if (!item)
          return;
        return {
          by: accountOrAgentIDfromSessionID(sessionID),
          tx: item.tx,
          at: new Date(item.madeAt),
          value: item.value
        };
      }
      lastItemIn(sessionID) {
        const items = this.items[sessionID];
        if (!items)
          return;
        return this.nthItemIn(sessionID, items.length - 1);
      }
      *itemsIn(sessionID) {
        const items = this.items[sessionID];
        if (!items)
          return;
        for (const item of items) {
          yield {
            by: accountOrAgentIDfromSessionID(sessionID),
            tx: item.tx,
            at: new Date(item.madeAt),
            value: item.value
          };
        }
      }
      lastItemBy(account) {
        let latestItem;
        for (const sessionID of Object.keys(this.items)) {
          if (sessionID.startsWith(account)) {
            const item = this.lastItemIn(sessionID);
            if (!item)
              continue;
            if (!latestItem || item.at > latestItem.at) {
              latestItem = {
                by: item.by,
                tx: item.tx,
                at: item.at,
                value: item.value
              };
            }
          }
        }
        return latestItem;
      }
      *itemsBy(account) {
        const items = [
          ...Object.keys(this.items).flatMap((sessionID) => sessionID.startsWith(account) ? [...this.itemsIn(sessionID)].map((item) => ({
            in: sessionID,
            ...item
          })) : [])
        ];
        items.sort((a, b) => a.at.getTime() - b.at.getTime());
        for (const item of items) {
          yield item;
        }
      }
      toJSON() {
        return Object.fromEntries(Object.entries(this.items).map(([sessionID, items]) => [
          sessionID,
          items.map((item) => item.value)
        ]));
      }
      subscribe(listener) {
        return this.core.subscribe((core) => {
          listener(core.getCurrentContent());
        });
      }
    }
    class RawCoStream extends RawCoStreamView {
      push(item, privacy = "private") {
        this.core.makeTransaction([isCoValue(item) ? item.id : item], privacy);
        this.processNewTransactions();
      }
    }
    const binary_U_prefixLength = 8;
    class RawBinaryCoStreamView extends RawCoStreamView {
      isBinaryStreamEnded() {
        const items = this.getSingleStream();
        if (!items || items.length === 0) {
          return false;
        }
        const lastItem = items[items.length - 1];
        return (lastItem == null ? void 0 : lastItem.type) === "end";
      }
      getBinaryStreamInfo() {
        const items = this.getSingleStream();
        if (!items)
          return;
        const start = items[0];
        if ((start == null ? void 0 : start.type) !== "start") {
          logger.error("Invalid binary stream start", start);
          return;
        }
        return {
          mimeType: start.mimeType,
          fileName: start.fileName,
          totalSizeBytes: start.totalSizeBytes
        };
      }
      getBinaryChunks(allowUnfinished) {
        const items = this.getSingleStream();
        if (!items)
          return;
        const info = this.getBinaryStreamInfo();
        if (!info)
          return;
        const end = items[items.length - 1];
        if ((end == null ? void 0 : end.type) !== "end" && !allowUnfinished)
          return;
        const chunks = [];
        let finished = false;
        for (const item of items.slice(1)) {
          if (item.type === "end") {
            finished = true;
            break;
          }
          if (item.type !== "chunk") {
            logger.error("Invalid binary stream chunk", item);
            return void 0;
          }
          const chunk = base64URLtoBytes(item.chunk.slice(binary_U_prefixLength));
          chunks.push(chunk);
        }
        return {
          ...info,
          chunks,
          finished
        };
      }
    }
    class RawBinaryCoStream extends RawBinaryCoStreamView {
      /** @internal */
      push(item, privacy = "private", updateView = true) {
        this.core.makeTransaction([item], privacy);
        if (updateView) {
          this.processNewTransactions();
        }
      }
      startBinaryStream(settings, privacy = "private") {
        this.push({
          type: "start",
          ...settings
        }, privacy, false);
      }
      pushBinaryStreamChunk(chunk, privacy = "private") {
        this.push({
          type: "chunk",
          chunk: `binary_U${bytesToBase64url(chunk)}`
        }, privacy, false);
      }
      endBinaryStream(privacy = "private") {
        this.push({
          type: "end"
        }, privacy, true);
      }
    }
    function isCoValue(value) {
      return value instanceof RawCoMap || value instanceof RawCoList || value instanceof RawCoStream || value instanceof RawBinaryCoStream;
    }
    class RawCoMapView {
      /** @internal */
      constructor(core, options) {
        this.type = "comap";
        this.atTimeFilter = void 0;
        this.totalValidTransactions = 0;
        this.id = core.id;
        this.core = core;
        this.latestTxMadeAt = 0;
        this.earliestTxMadeAt = null;
        this.ignorePrivateTransactions = (options == null ? void 0 : options.ignorePrivateTransactions) ?? false;
        this.ops = {};
        this.latest = {};
        this.knownTransactions = {};
        this.processNewTransactions();
      }
      processNewTransactions() {
        if (this.isTimeTravelEntity()) {
          throw new Error("Cannot process transactions on a time travel entity");
        }
        const newValidTransactions = this.core.getValidTransactions({
          ignorePrivateTransactions: this.ignorePrivateTransactions,
          knownTransactions: this.knownTransactions
        });
        if (newValidTransactions.length === 0) {
          return;
        }
        if (this.earliestTxMadeAt === null && newValidTransactions[0]) {
          this.earliestTxMadeAt = newValidTransactions[0].madeAt;
        }
        const { ops } = this;
        const changedEntries = /* @__PURE__ */ new Map();
        for (const { txID, changes, madeAt } of newValidTransactions) {
          if (madeAt > this.latestTxMadeAt) {
            this.latestTxMadeAt = madeAt;
          }
          for (let changeIdx = 0; changeIdx < changes.length; changeIdx++) {
            const change = changes[changeIdx];
            const entry = {
              txID,
              madeAt,
              changeIdx,
              change
            };
            const entries = ops[change.key];
            if (!entries) {
              const entries2 = [entry];
              ops[change.key] = entries2;
              changedEntries.set(change.key, entries2);
            } else {
              entries.push(entry);
              changedEntries.set(change.key, entries);
            }
            this.knownTransactions[txID.sessionID] = Math.max(this.knownTransactions[txID.sessionID] ?? 0, txID.txIndex);
          }
        }
        this.totalValidTransactions += newValidTransactions.length;
        for (const entries of changedEntries.values()) {
          entries.sort(this.core.compareTransactions);
        }
        for (const [key, entries] of changedEntries.entries()) {
          this.latest[key] = entries[entries.length - 1];
        }
      }
      isTimeTravelEntity() {
        return Boolean(this.atTimeFilter);
      }
      /** @category 6. Meta */
      get headerMeta() {
        return this.core.verified.header.meta;
      }
      /** @category 6. Meta */
      get group() {
        return this.core.getGroup();
      }
      /** @category 4. Time travel */
      atTime(time2) {
        if (time2 >= this.latestTxMadeAt) {
          return this;
        } else {
          const clone2 = Object.create(this);
          clone2.atTimeFilter = time2;
          clone2.latest = {};
          return clone2;
        }
      }
      /** @internal */
      timeFilteredOps(key) {
        var _a;
        if (key === "constructor") {
          return void 0;
        }
        const atTimeFilter = this.atTimeFilter;
        if (atTimeFilter) {
          return (_a = this.ops[key]) == null ? void 0 : _a.filter((op) => op.madeAt <= atTimeFilter);
        } else {
          return this.ops[key];
        }
      }
      /**
       * Get all keys currently in the map.
       *
       * @category 1. Reading */
      keys() {
        return Object.keys(this.ops).filter((key) => {
          const entry = this.getRaw(key);
          if (entry === void 0) {
            return false;
          }
          if (entry.change.op === "del") {
            return false;
          }
          return true;
        });
      }
      getRaw(key) {
        let latestChange = this.latest[key];
        if (latestChange === void 0) {
          const entries = this.ops[key];
          if (entries && !(key in this.latest)) {
            const atTimeFilter = this.atTimeFilter;
            if (!atTimeFilter) {
              latestChange = entries[entries.length - 1];
            } else {
              latestChange = entries.findLast((op) => op.madeAt <= atTimeFilter);
            }
            this.latest[key] = latestChange;
          }
          if (latestChange === void 0) {
            return void 0;
          }
        }
        return latestChange;
      }
      /**
       * Returns the current value for the given key.
       *
       * @category 1. Reading
       **/
      get(key) {
        const entry = this.getRaw(key);
        if ((entry == null ? void 0 : entry.change) === void 0) {
          return void 0;
        }
        if (entry.change.op === "del") {
          return void 0;
        } else {
          return entry.change.value;
        }
      }
      /** @category 1. Reading */
      asObject() {
        const object2 = {};
        for (const key of Object.keys(this.ops)) {
          const value = this.get(key);
          if (value !== void 0) {
            object2[key] = value;
          }
        }
        return object2;
      }
      /** @category 1. Reading */
      toJSON() {
        return this.asObject();
      }
      /** @category 5. Edit history */
      nthEditAt(key, n) {
        const ops = this.ops[key];
        const atTimeFilter = this.atTimeFilter;
        const entry = ops == null ? void 0 : ops[n];
        if (!entry) {
          return void 0;
        }
        if (atTimeFilter && entry.madeAt > atTimeFilter) {
          return void 0;
        }
        return operationToEditEntry(entry);
      }
      /** @category 5. Edit history */
      lastEditAt(key) {
        const entry = this.getRaw(key);
        if (!entry) {
          return void 0;
        }
        return operationToEditEntry(entry);
      }
      /** @category 5. Edit history */
      *editsAt(key) {
        const entries = this.ops[key];
        if (!entries) {
          return;
        }
        const atTimeFilter = this.atTimeFilter;
        for (const entry of entries) {
          if (atTimeFilter && entry.madeAt > atTimeFilter) {
            return;
          }
          yield operationToEditEntry(entry);
        }
      }
      /** @category 3. Subscription */
      subscribe(listener) {
        return this.core.subscribe((core) => {
          listener(core.getCurrentContent());
        });
      }
    }
    class RawCoMap extends RawCoMapView {
      /** Set a new value for the given key.
       *
       * If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
       *
       * If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
       *
       * @category 2. Editing
       **/
      set(key, value, privacy = "private") {
        if (this.isTimeTravelEntity()) {
          throw new Error("Cannot set value on a time travel entity");
        }
        this.core.makeTransaction([
          {
            op: "set",
            key,
            value: isCoValue(value) ? value.id : value
          }
        ], privacy);
        this.processNewTransactions();
      }
      assign(entries, privacy = "private") {
        if (this.isTimeTravelEntity()) {
          throw new Error("Cannot set value on a time travel entity");
        }
        this.core.makeTransaction(Object.entries(entries).map(([key, value]) => ({
          op: "set",
          key,
          value: isCoValue(value) ? value.id : value
        })), privacy);
        this.processNewTransactions();
      }
      /** Delete the given key (setting it to undefined).
       *
       * If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.
       *
       * If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.
       *
       * @category 2. Editing
       **/
      delete(key, privacy = "private") {
        if (this.isTimeTravelEntity()) {
          throw new Error("Cannot delete value on a time travel entity");
        }
        this.core.makeTransaction([
          {
            op: "del",
            key
          }
        ], privacy);
        this.processNewTransactions();
      }
    }
    function operationToEditEntry(op) {
      return {
        by: accountOrAgentIDfromSessionID(op.txID.sessionID),
        tx: op.txID,
        at: new Date(op.madeAt),
        value: op.change.op === "del" ? void 0 : op.change.value
      };
    }
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    function isBytes$3(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function isArrayOf$1(isString, arr) {
      if (!Array.isArray(arr))
        return false;
      if (arr.length === 0)
        return true;
      if (isString) {
        return arr.every((item) => typeof item === "string");
      } else {
        return arr.every((item) => Number.isSafeInteger(item));
      }
    }
    function astr$1(label, input) {
      if (typeof input !== "string")
        throw new Error(`${label}: string expected`);
      return true;
    }
    function anumber$3(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`invalid integer: ${n}`);
    }
    function aArr$1(input) {
      if (!Array.isArray(input))
        throw new Error("array expected");
    }
    function astrArr$1(label, input) {
      if (!isArrayOf$1(true, input))
        throw new Error(`${label}: array of strings expected`);
    }
    function anumArr$1(label, input) {
      if (!isArrayOf$1(false, input))
        throw new Error(`${label}: array of numbers expected`);
    }
    // @__NO_SIDE_EFFECTS__
    function chain$1(...args) {
      const id2 = (a) => a;
      const wrap = (a, b) => (c) => a(b(c));
      const encode = args.map((x) => x.encode).reduceRight(wrap, id2);
      const decode = args.map((x) => x.decode).reduce(wrap, id2);
      return { encode, decode };
    }
    // @__NO_SIDE_EFFECTS__
    function alphabet$1(letters) {
      const lettersA = typeof letters === "string" ? letters.split("") : letters;
      const len = lettersA.length;
      astrArr$1("alphabet", lettersA);
      const indexes = new Map(lettersA.map((l, i) => [l, i]));
      return {
        encode: (digits) => {
          aArr$1(digits);
          return digits.map((i) => {
            if (!Number.isSafeInteger(i) || i < 0 || i >= len)
              throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
            return lettersA[i];
          });
        },
        decode: (input) => {
          aArr$1(input);
          return input.map((letter) => {
            astr$1("alphabet.decode", letter);
            const i = indexes.get(letter);
            if (i === void 0)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
            return i;
          });
        }
      };
    }
    // @__NO_SIDE_EFFECTS__
    function join$1(separator = "") {
      astr$1("join", separator);
      return {
        encode: (from) => {
          astrArr$1("join.decode", from);
          return from.join(separator);
        },
        decode: (to) => {
          astr$1("join.decode", to);
          return to.split(separator);
        }
      };
    }
    function convertRadix$1(data2, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
      aArr$1(data2);
      if (!data2.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data2, (d) => {
        anumber$3(d);
        if (d < 0 || d >= from)
          throw new Error(`invalid integer: ${d}`);
        return d;
      });
      const dlen = digits.length;
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < dlen; i++) {
          const digit = digits[i];
          const fromCarry = from * carry;
          const digitBase = fromCarry + digit;
          if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
            throw new Error("convertRadix: carry overflow");
          }
          const div = digitBase / to;
          carry = digitBase % to;
          const rounded = Math.floor(div);
          digits[i] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i = 0; i < data2.length - 1 && data2[i] === 0; i++)
        res.push(0);
      return res.reverse();
    }
    // @__NO_SIDE_EFFECTS__
    function radix$1(num) {
      anumber$3(num);
      const _256 = 2 ** 8;
      return {
        encode: (bytes) => {
          if (!isBytes$3(bytes))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix$1(Array.from(bytes), _256, num);
        },
        decode: (digits) => {
          anumArr$1("radix.decode", digits);
          return Uint8Array.from(convertRadix$1(digits, num, _256));
        }
      };
    }
    const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain$1(/* @__PURE__ */ radix$1(58), /* @__PURE__ */ alphabet$1(abc), /* @__PURE__ */ join$1(""));
    const base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    function stableStringify(data2) {
      const seen = [];
      let node = data2;
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === void 0)
        return;
      if (typeof node == "number")
        return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object") {
        if (typeof node === "string" && (node.startsWith("encrypted_U") || node.startsWith("binary_U"))) {
          return `"${node}"`;
        }
        return JSON.stringify(node);
      }
      let i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0; i < node.length; i++) {
          if (i)
            out += ",";
          out += stableStringify(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null)
        return "null";
      if (seen.indexOf(node) !== -1) {
        throw new TypeError("Converting circular structure to JSON");
      }
      const seenIndex = seen.push(node) - 1;
      const keys = Object.keys(node).sort();
      out = "";
      for (i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = stableStringify(node[key]);
        if (!value)
          continue;
        if (out)
          out += ",";
        out += JSON.stringify(key) + ":" + value;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }
    function parseJSON(json2) {
      return JSON.parse(json2);
    }
    function randomBytes$1(bytesLength = 32) {
      return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();
    class CryptoProvider {
      randomBytes(length) {
        return randomBytes$1(length);
      }
      newRandomSigner() {
        return `signerSecret_z${base58.encode(this.newEd25519SigningKey())}`;
      }
      signerSecretToBytes(secret) {
        return base58.decode(secret.substring("signerSecret_z".length));
      }
      signerSecretFromBytes(bytes) {
        return `signerSecret_z${base58.encode(bytes)}`;
      }
      newRandomSealer() {
        return `sealerSecret_z${base58.encode(this.newX25519StaticSecret())}`;
      }
      sealerSecretToBytes(secret) {
        return base58.decode(secret.substring("sealerSecret_z".length));
      }
      sealerSecretFromBytes(bytes) {
        return `sealerSecret_z${base58.encode(bytes)}`;
      }
      newRandomAgentSecret() {
        return `${this.newRandomSealer()}/${this.newRandomSigner()}`;
      }
      agentSecretToBytes(secret) {
        const [sealerSecret, signerSecret] = secret.split("/");
        return new Uint8Array([
          ...this.sealerSecretToBytes(sealerSecret),
          ...this.signerSecretToBytes(signerSecret)
        ]);
      }
      agentSecretFromBytes(bytes) {
        const sealerSecret = this.sealerSecretFromBytes(bytes.slice(0, 32));
        const signerSecret = this.signerSecretFromBytes(bytes.slice(32));
        return `${sealerSecret}/${signerSecret}`;
      }
      getAgentID(secret) {
        const [sealerSecret, signerSecret] = secret.split("/");
        return `${this.getSealerID(sealerSecret)}/${this.getSignerID(signerSecret)}`;
      }
      getAgentSignerID(agentId) {
        return agentId.split("/")[1];
      }
      getAgentSignerSecret(agentSecret) {
        return agentSecret.split("/")[1];
      }
      getAgentSealerID(agentId) {
        return agentId.split("/")[0];
      }
      getAgentSealerSecret(agentSecret) {
        return agentSecret.split("/")[0];
      }
      secureHash(value) {
        return `hash_z${base58.encode(this.blake3HashOnce(textEncoder.encode(stableStringify(value))))}`;
      }
      shortHash(value) {
        return `shortHash_z${base58.encode(this.blake3HashOnce(textEncoder.encode(stableStringify(value))).slice(0, shortHashLength))}`;
      }
      encryptForTransaction(value, keySecret, nOnceMaterial) {
        return this.encrypt(value, keySecret, nOnceMaterial);
      }
      decrypt(encrypted, keySecret, nOnceMaterial) {
        try {
          return parseJSON(this.decryptRaw(encrypted, keySecret, nOnceMaterial));
        } catch (e) {
          logger.error("Decryption error", { err: e });
          return void 0;
        }
      }
      newRandomKeySecret() {
        return {
          secret: `keySecret_z${base58.encode(this.randomBytes(32))}`,
          id: `key_z${base58.encode(this.randomBytes(12))}`
        };
      }
      decryptRawForTransaction(encrypted, keySecret, nOnceMaterial) {
        return this.decryptRaw(encrypted, keySecret, nOnceMaterial);
      }
      decryptForTransaction(encrypted, keySecret, nOnceMaterial) {
        return this.decrypt(encrypted, keySecret, nOnceMaterial);
      }
      encryptKeySecret(keys) {
        const nOnceMaterial = {
          encryptedID: keys.toEncrypt.id,
          encryptingID: keys.encrypting.id
        };
        return {
          encryptedID: keys.toEncrypt.id,
          encryptingID: keys.encrypting.id,
          encrypted: this.encrypt(keys.toEncrypt.secret, keys.encrypting.secret, nOnceMaterial)
        };
      }
      decryptKeySecret(encryptedInfo, sealingSecret) {
        const nOnceMaterial = {
          encryptedID: encryptedInfo.encryptedID,
          encryptingID: encryptedInfo.encryptingID
        };
        return this.decrypt(encryptedInfo.encrypted, sealingSecret, nOnceMaterial);
      }
      uniquenessForHeader() {
        return `z${base58.encode(this.randomBytes(12))}`;
      }
      createdNowUnique() {
        const createdAt = (/* @__PURE__ */ new Date()).toISOString();
        return {
          createdAt,
          uniqueness: this.uniquenessForHeader()
        };
      }
      newRandomSecretSeed() {
        return this.randomBytes(secretSeedLength);
      }
      agentSecretFromSecretSeed(secretSeed) {
        if (secretSeed.length !== secretSeedLength) {
          throw new Error(`Secret seed needs to be ${secretSeedLength} bytes long`);
        }
        return `sealerSecret_z${base58.encode(this.blake3HashOnceWithContext(secretSeed, {
          context: textEncoder.encode("seal")
        }))}/signerSecret_z${base58.encode(this.blake3HashOnceWithContext(secretSeed, {
          context: textEncoder.encode("sign")
        }))}`;
      }
      newRandomSessionID(accountID) {
        return `${accountID}_session_z${base58.encode(this.randomBytes(8))}`;
      }
    }
    class StreamingHash {
      constructor(crypto2, fromClone) {
        this.state = fromClone || crypto2.emptyBlake3State();
        this.crypto = crypto2;
      }
      update(value) {
        const encoded = textEncoder.encode(stableStringify(value));
        this.state = this.crypto.blake3IncrementalUpdate(this.state, encoded);
        return encoded;
      }
      digest() {
        const hash = this.crypto.blake3DigestForState(this.state);
        return `hash_z${base58.encode(hash)}`;
      }
      clone() {
        return new StreamingHash(this.crypto, this.crypto.cloneBlake3State(this.state));
      }
    }
    const shortHashLength = 19;
    const secretSeedLength = 32;
    function rawCoIDtoBytes(id2) {
      return base58.decode(id2.substring("co_z".length));
    }
    function rawCoIDfromBytes(bytes) {
      return `co_z${base58.encode(bytes.slice(0, shortHashLength))}`;
    }
    function isAgentID(id2) {
      return typeof id2 === "string" && id2.startsWith("sealer_") && id2.includes("/signer_");
    }
    function isParentGroupReference(key) {
      return key.startsWith("parent_");
    }
    function getParentGroupId(key) {
      return key.slice("parent_".length);
    }
    function isChildGroupReference(key) {
      return key.startsWith("child_");
    }
    function getChildGroupId(key) {
      return key.slice("child_".length);
    }
    function getGroupDependentKey(key) {
      if (typeof key !== "string")
        return void 0;
      if (isParentGroupReference(key)) {
        return getParentGroupId(key);
      } else if (key.startsWith("co_")) {
        return key;
      }
      return void 0;
    }
    function getGroupDependentKeyList(keys) {
      const groupDependentKeys = [];
      for (const key of keys) {
        const value = getGroupDependentKey(key);
        if (value) {
          groupDependentKeys.push(value);
        }
      }
      return groupDependentKeys;
    }
    function expectGroup(content) {
      const map2 = expectMap(content);
      if (map2.core.verified.header.ruleset.type !== "group") {
        throw new Error("Expected group ruleset in group");
      }
      if (!(map2 instanceof RawGroup)) {
        throw new Error("Expected group");
      }
      return map2;
    }
    const EVERYONE = "everyone";
    class RawGroup extends RawCoMap {
      constructor(core, options) {
        super(core, options);
        this.crypto = core.node.crypto;
      }
      /**
       * Returns the current role of a given account.
       *
       * @category 1. Role reading
       */
      roleOf(accountID) {
        return this.roleOfInternal(accountID);
      }
      /**
       *  This is a performance-critical function, micro-optimizing it is important
       *
       *  Avoid to add objects/array allocations in this function
       */
      /** @internal */
      roleOfInternal(accountID) {
        let roleHere = this.get(accountID);
        if (roleHere === "revoked") {
          roleHere = void 0;
        }
        let roleInfo = roleHere;
        for (const key of Object.keys(this.ops)) {
          if (!isParentGroupReference(key))
            continue;
          const group = this.getParentGroupFromKey(key, this.atTimeFilter);
          if (!group)
            continue;
          const role = this.get(key) ?? "extend";
          const parentRole = group.roleOfInternal(accountID);
          if (!isInheritableRole(parentRole)) {
            continue;
          }
          const roleToInherit = role !== "extend" ? role : parentRole;
          if (isMorePermissiveAndShouldInherit(roleToInherit, roleInfo)) {
            roleInfo = roleToInherit;
          }
        }
        if (!roleInfo && accountID !== "everyone") {
          const everyoneRole = this.get("everyone");
          if (everyoneRole && everyoneRole !== "revoked")
            return everyoneRole;
        }
        return roleInfo;
      }
      getParentGroupFromKey(key, atTime) {
        if (this.get(key) === "revoked") {
          return null;
        }
        const parent = this.core.node.expectCoValueLoaded(getParentGroupId(key), "Expected parent group to be loaded");
        const group = expectGroup(parent.getCurrentContent());
        if (atTime) {
          return group.atTime(atTime);
        } else {
          return group;
        }
      }
      getParentGroups(atTime) {
        const groups = [];
        for (const key of Object.keys(this.ops)) {
          if (!isParentGroupReference(key))
            continue;
          const group = this.getParentGroupFromKey(key, atTime);
          if (group) {
            if (atTime) {
              groups.push(group.atTime(atTime));
            } else {
              groups.push(group);
            }
          }
        }
        return groups;
      }
      loadAllChildGroups() {
        const requests = [];
        const peers = this.core.node.syncManager.getServerPeers();
        for (const key of this.keys()) {
          if (!isChildGroupReference(key)) {
            continue;
          }
          const id2 = getChildGroupId(key);
          const child = this.core.node.getCoValue(id2);
          if (child.loadingState === "unknown" || child.loadingState === "unavailable") {
            child.load(peers);
          }
          requests.push(child.waitForAvailableOrUnavailable().then((coValue) => {
            if (!coValue.isAvailable()) {
              throw new Error(`Child group ${child.id} is unavailable`);
            }
            return expectGroup(coValue.getCurrentContent()).loadAllChildGroups();
          }));
        }
        return Promise.all(requests);
      }
      getChildGroups() {
        const groups = [];
        for (const key of this.keys()) {
          if (isChildGroupReference(key)) {
            if (this.get(key) === "revoked") {
              continue;
            }
            const child = this.core.node.expectCoValueLoaded(getChildGroupId(key), "Expected child group to be loaded");
            groups.push(expectGroup(child.getCurrentContent()));
          }
        }
        return groups;
      }
      /**
       * Returns the role of the current account in the group.
       *
       * @category 1. Role reading
       */
      myRole() {
        return this.roleOfInternal(this.core.node.getCurrentAgent().id);
      }
      /**
       * Directly grants a new member a role in the group. The current account must be an
       * admin to be able to do so. Throws otherwise.
       *
       * @category 2. Role changing
       */
      addMember(account, role) {
        this.addMemberInternal(account, role);
      }
      /** @internal */
      addMemberInternal(account, role) {
        if (account === EVERYONE) {
          if (!(role === "reader" || role === "writer" || role === "writeOnly")) {
            throw new Error("Can't make everyone something other than reader, writer or writeOnly");
          }
          const currentReadKey = this.core.getCurrentReadKey();
          if (!currentReadKey.secret) {
            throw new Error("Can't add member without read key secret");
          }
          const previousRole = this.get(account);
          this.set(account, role, "trusting");
          if (this.get(account) !== role) {
            const myRole = this.myRole();
            throw new Error(myRole === "admin" ? this.get(account) === "admin" ? "Administrators cannot demote other administrators in a group" : "Failed to set role" : `Failed to set role due to insufficient permissions (role of current account is ${myRole})`);
          }
          if (role === "writeOnly") {
            if (previousRole === "reader" || previousRole === "writer") {
              this.rotateReadKey();
            }
            this.delete(`${currentReadKey.id}_for_${EVERYONE}`);
          } else {
            this.set(`${currentReadKey.id}_for_${EVERYONE}`, currentReadKey.secret, "trusting");
          }
          return;
        }
        const memberKey = typeof account === "string" ? account : account.id;
        const agent = typeof account === "string" ? account : account.currentAgentID();
        if (role === "writeOnly" || role === "writeOnlyInvite") {
          const previousRole = this.get(memberKey);
          this.set(memberKey, role, "trusting");
          if (previousRole === "reader" || previousRole === "writer" || previousRole === "admin") {
            this.rotateReadKey();
          }
          this.internalCreateWriteOnlyKeyForMember(memberKey, agent);
        } else {
          const currentReadKey = this.core.getCurrentReadKey();
          if (!currentReadKey.secret) {
            throw new Error("Can't add member without read key secret");
          }
          this.set(memberKey, role, "trusting");
          if (this.get(memberKey) !== role) {
            const myRole = this.myRole();
            throw new Error(myRole === "admin" ? this.get(memberKey) === "admin" ? "Administrators cannot demote other administrators in a group" : "Failed to set role" : `Failed to set role due to insufficient permissions (role of current account is ${myRole})`);
          }
          this.storeKeyRevelationForMember(memberKey, agent, currentReadKey.id, currentReadKey.secret);
          for (const keyID of this.getWriteOnlyKeys()) {
            const secret = this.core.getReadKey(keyID);
            if (!secret) {
              logger.error("Can't find key " + keyID);
              continue;
            }
            this.storeKeyRevelationForMember(memberKey, agent, keyID, secret);
          }
        }
      }
      internalCreateWriteOnlyKeyForMember(memberKey, agent) {
        const writeKeyForNewMember = this.crypto.newRandomKeySecret();
        this.set(`writeKeyFor_${memberKey}`, writeKeyForNewMember.id, "trusting");
        this.storeKeyRevelationForMember(memberKey, agent, writeKeyForNewMember.id, writeKeyForNewMember.secret);
        for (const otherMemberKey of this.getMemberKeys()) {
          const memberRole = this.get(otherMemberKey);
          if (memberRole === "reader" || memberRole === "writer" || memberRole === "admin" || memberRole === "readerInvite" || memberRole === "writerInvite" || memberRole === "adminInvite") {
            const otherMemberAgent = this.core.node.resolveAccountAgent(otherMemberKey, "Expected member agent to be loaded")._unsafeUnwrap({ withStackTrace: true });
            this.storeKeyRevelationForMember(otherMemberKey, otherMemberAgent, writeKeyForNewMember.id, writeKeyForNewMember.secret);
          }
        }
      }
      storeKeyRevelationForMember(memberKey, agent, keyID, secret) {
        this.set(`${keyID}_for_${memberKey}`, this.crypto.seal({
          message: secret,
          from: this.core.node.getCurrentAgent().currentSealerSecret(),
          to: this.crypto.getAgentSealerID(agent),
          nOnceMaterial: {
            in: this.id,
            tx: this.core.nextTransactionID()
          }
        }), "trusting");
      }
      getWriteOnlyKeys() {
        const keys = [];
        for (const key of this.keys()) {
          if (key.startsWith("writeKeyFor_")) {
            keys.push(this.get(key));
          }
        }
        return keys;
      }
      getCurrentReadKeyId() {
        const myRole = this.myRole();
        if (myRole === "writeOnly") {
          const accountId = this.core.node.getCurrentAgent().id;
          const key = this.get(`writeKeyFor_${accountId}`);
          if (!key && this.get("everyone") === "writeOnly") {
            this.internalCreateWriteOnlyKeyForMember(accountId, this.core.node.getCurrentAgent().currentAgentID());
            return this.get(`writeKeyFor_${accountId}`);
          }
          return key;
        }
        if (!myRole) {
          const accountId = this.core.node.getCurrentAgent().id;
          const key = this.get(`writeKeyFor_${accountId}`);
          if (key) {
            return key;
          }
        }
        return this.get("readKey");
      }
      getMemberKeys() {
        return this.keys().filter((key) => {
          return key.startsWith("co_") || isAgentID(key);
        });
      }
      getAllMemberKeysSet() {
        const memberKeys = new Set(this.getMemberKeys());
        for (const group of this.getParentGroups()) {
          for (const key of group.getAllMemberKeysSet()) {
            memberKeys.add(key);
          }
        }
        return memberKeys;
      }
      /** @internal */
      rotateReadKey(removedMemberKey) {
        const memberKeys = this.getMemberKeys().filter((key) => key !== removedMemberKey);
        const currentlyPermittedReaders = memberKeys.filter((key) => {
          const role = this.get(key);
          return role === "admin" || role === "writer" || role === "reader" || role === "adminInvite" || role === "writerInvite" || role === "readerInvite";
        });
        const writeOnlyMembers = memberKeys.filter((key) => {
          const role = this.get(key);
          return role === "writeOnly" || role === "writeOnlyInvite";
        });
        const parentGroups = this.getParentGroups();
        const childGroups = this.getChildGroups();
        const maybeCurrentReadKey = this.core.getCurrentReadKey();
        if (!maybeCurrentReadKey.secret) {
          throw new Error("Can't rotate read key secret we don't have access to");
        }
        const currentReadKey = {
          id: maybeCurrentReadKey.id,
          secret: maybeCurrentReadKey.secret
        };
        const newReadKey = this.crypto.newRandomKeySecret();
        for (const readerID of currentlyPermittedReaders) {
          const agent = this.core.node.resolveAccountAgent(readerID, "Expected to know currently permitted reader")._unsafeUnwrap({ withStackTrace: true });
          this.storeKeyRevelationForMember(readerID, agent, newReadKey.id, newReadKey.secret);
        }
        for (const writeOnlyMemberID of writeOnlyMembers) {
          const agent = this.core.node.resolveAccountAgent(writeOnlyMemberID, "Expected to know writeOnly member")._unsafeUnwrap({ withStackTrace: true });
          const writeOnlyKey = this.crypto.newRandomKeySecret();
          this.storeKeyRevelationForMember(writeOnlyMemberID, agent, writeOnlyKey.id, writeOnlyKey.secret);
          this.set(`writeKeyFor_${writeOnlyMemberID}`, writeOnlyKey.id, "trusting");
          for (const readerID of currentlyPermittedReaders) {
            const agent2 = this.core.node.resolveAccountAgent(readerID, "Expected to know currently permitted reader")._unsafeUnwrap({ withStackTrace: true });
            this.storeKeyRevelationForMember(readerID, agent2, writeOnlyKey.id, writeOnlyKey.secret);
          }
        }
        this.set(`${currentReadKey.id}_for_${newReadKey.id}`, this.crypto.encryptKeySecret({
          encrypting: newReadKey,
          toEncrypt: currentReadKey
        }).encrypted, "trusting");
        this.set("readKey", newReadKey.id, "trusting");
        for (const parent of parentGroups) {
          const { id: parentReadKeyID, secret: parentReadKeySecret } = parent.core.getCurrentReadKey();
          if (!parentReadKeySecret) {
            logger.warn("Can't reveal new child key to parent where we don't have access to the parent read key");
            continue;
          }
          this.set(`${newReadKey.id}_for_${parentReadKeyID}`, this.crypto.encryptKeySecret({
            encrypting: {
              id: parentReadKeyID,
              secret: parentReadKeySecret
            },
            toEncrypt: newReadKey
          }).encrypted, "trusting");
        }
        for (const child of childGroups) {
          if (child.isSelfExtension(this)) {
            continue;
          }
          child.rotateReadKey(removedMemberKey);
        }
      }
      /** Detect circular references in group inheritance */
      isSelfExtension(parent) {
        if (parent.id === this.id) {
          return true;
        }
        const childGroups = this.getChildGroups();
        for (const child of childGroups) {
          if (child.isSelfExtension(parent)) {
            return true;
          }
        }
        return false;
      }
      extend(parent, role = "inherit") {
        if (this.isSelfExtension(parent)) {
          return;
        }
        if (this.myRole() !== "admin") {
          throw new Error("To extend a group, the current account must be an admin in the child group");
        }
        const value = role === "inherit" ? "extend" : role;
        this.set(`parent_${parent.id}`, value, "trusting");
        parent.set(`child_${this.id}`, "extend", "trusting");
        if (parent.myRole() !== "admin" && parent.myRole() !== "writer" && parent.myRole() !== "reader" && parent.myRole() !== "writeOnly") {
          parent.internalCreateWriteOnlyKeyForMember(this.core.node.getCurrentAgent().id, this.core.node.getCurrentAgent().currentAgentID());
        }
        const { id: parentReadKeyID, secret: parentReadKeySecret } = parent.core.getCurrentReadKey();
        if (!parentReadKeySecret) {
          throw new Error("Can't extend group without parent read key secret");
        }
        const { id: childReadKeyID, secret: childReadKeySecret } = this.core.getCurrentReadKey();
        if (!childReadKeySecret) {
          throw new Error("Can't extend group without child read key secret");
        }
        this.set(`${childReadKeyID}_for_${parentReadKeyID}`, this.crypto.encryptKeySecret({
          encrypting: {
            id: parentReadKeyID,
            secret: parentReadKeySecret
          },
          toEncrypt: {
            id: childReadKeyID,
            secret: childReadKeySecret
          }
        }).encrypted, "trusting");
      }
      async revokeExtend(parent) {
        if (this.myRole() !== "admin") {
          throw new Error("To unextend a group, the current account must be an admin in the child group");
        }
        if (parent.myRole() !== "admin" && parent.myRole() !== "writer" && parent.myRole() !== "reader" && parent.myRole() !== "writeOnly") {
          throw new Error("To unextend a group, the current account must be a member of the parent group");
        }
        if (!this.get(`parent_${parent.id}`) || this.get(`parent_${parent.id}`) === "revoked") {
          return;
        }
        this.set(`parent_${parent.id}`, "revoked", "trusting");
        parent.set(`child_${this.id}`, "revoked", "trusting");
        await this.loadAllChildGroups();
        this.rotateReadKey();
      }
      /**
       * Strips the specified member of all roles (preventing future writes in
       *  the group and owned values) and rotates the read encryption key for that group
       * (preventing reads of new content in the group and owned values)
       *
       * @category 2. Role changing
       */
      async removeMember(account) {
        await this.loadAllChildGroups();
        this.removeMemberInternal(account);
      }
      /** @internal */
      removeMemberInternal(account) {
        const memberKey = typeof account === "string" ? account : account.id;
        if (this.myRole() === "admin") {
          this.rotateReadKey(memberKey);
        }
        this.set(memberKey, "revoked", "trusting");
      }
      /**
       * Creates an invite for new members to indirectly join the group,
       * allowing them to grant themselves the specified role with the InviteSecret
       * (a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.
       *
       * @category 2. Role changing
       */
      createInvite(role) {
        const secretSeed = this.crypto.newRandomSecretSeed();
        const inviteSecret = this.crypto.agentSecretFromSecretSeed(secretSeed);
        const inviteID = this.crypto.getAgentID(inviteSecret);
        this.addMemberInternal(inviteID, `${role}Invite`);
        return inviteSecretFromSecretSeed(secretSeed);
      }
      /**
       * Creates a new `CoMap` within this group, with the specified specialized
       * `CoMap` type `M` and optional static metadata.
       *
       * @category 3. Value creation
       */
      createMap(init, meta, initPrivacy = "private", uniqueness = this.crypto.createdNowUnique()) {
        const map2 = this.core.node.createCoValue({
          type: "comap",
          ruleset: {
            type: "ownedByGroup",
            group: this.id
          },
          meta: meta || null,
          ...uniqueness
        }).getCurrentContent();
        if (init) {
          map2.assign(init, initPrivacy);
        }
        return map2;
      }
      /**
       * Creates a new `CoList` within this group, with the specified specialized
       * `CoList` type `L` and optional static metadata.
       *
       * @category 3. Value creation
       */
      createList(init, meta, initPrivacy = "private", uniqueness = this.crypto.createdNowUnique()) {
        const list = this.core.node.createCoValue({
          type: "colist",
          ruleset: {
            type: "ownedByGroup",
            group: this.id
          },
          meta: meta || null,
          ...uniqueness
        }).getCurrentContent();
        if (init == null ? void 0 : init.length) {
          list.appendItems(init, void 0, initPrivacy);
        }
        return list;
      }
      /**
       * Creates a new `CoPlainText` within this group, with the specified specialized
       * `CoPlainText` type `T` and optional static metadata.
       *
       * @category 3. Value creation
       */
      createPlainText(init, meta, initPrivacy = "private") {
        const text = this.core.node.createCoValue({
          type: "coplaintext",
          ruleset: {
            type: "ownedByGroup",
            group: this.id
          },
          meta: meta || null,
          ...this.crypto.createdNowUnique()
        }).getCurrentContent();
        if (init) {
          text.insertAfter(0, init, initPrivacy);
        }
        return text;
      }
      /** @category 3. Value creation */
      createStream(meta, uniqueness = this.crypto.createdNowUnique()) {
        return this.core.node.createCoValue({
          type: "costream",
          ruleset: {
            type: "ownedByGroup",
            group: this.id
          },
          meta: meta || null,
          ...uniqueness
        }).getCurrentContent();
      }
      /** @category 3. Value creation */
      createBinaryStream(meta = { type: "binary" }, uniqueness = this.crypto.createdNowUnique()) {
        return this.core.node.createCoValue({
          type: "costream",
          ruleset: {
            type: "ownedByGroup",
            group: this.id
          },
          meta,
          ...uniqueness
        }).getCurrentContent();
      }
    }
    function isInheritableRole(roleInParent) {
      return roleInParent === "revoked" || roleInParent === "admin" || roleInParent === "writer" || roleInParent === "reader";
    }
    function isMorePermissiveAndShouldInherit(roleInParent, roleInChild) {
      if (roleInParent === "revoked") {
        return true;
      }
      if (roleInParent === "admin") {
        return !roleInChild || roleInChild !== "admin";
      }
      if (roleInParent === "writer") {
        return !roleInChild || roleInChild === "reader" || roleInChild === "writeOnly";
      }
      if (roleInParent === "reader") {
        return !roleInChild;
      }
      if (roleInParent === "writeOnly") {
        return false;
      }
      return false;
    }
    function inviteSecretFromSecretSeed(secretSeed) {
      return `inviteSecret_z${base58.encode(secretSeed)}`;
    }
    function secretSeedFromInviteSecret(inviteSecret) {
      if (!inviteSecret.startsWith("inviteSecret_z")) {
        throw new Error("Invalid invite secret");
      }
      return base58.decode(inviteSecret.slice("inviteSecret_z".length));
    }
    function accountHeaderForInitialAgentSecret(agentSecret, crypto2) {
      const agent = crypto2.getAgentID(agentSecret);
      return {
        type: "comap",
        ruleset: { type: "group", initialAdmin: agent },
        meta: {
          type: "account"
        },
        createdAt: null,
        uniqueness: null
      };
    }
    class RawAccount extends RawGroup {
      currentAgentID() {
        if (this._cachedCurrentAgentID) {
          return this._cachedCurrentAgentID;
        }
        const agents = this.keys().filter((k) => k.startsWith("sealer_")).sort((a, b) => {
          var _a, _b;
          return (((_a = this.lastEditAt(a)) == null ? void 0 : _a.at.getTime()) || 0) - (((_b = this.lastEditAt(b)) == null ? void 0 : _b.at.getTime()) || 0);
        });
        if (agents.length !== 1) {
          logger.warn("Account has " + agents.length + " agents", { id: this.id });
        }
        this._cachedCurrentAgentID = agents[0];
        return agents[0];
      }
      createInvite(_) {
        throw new Error("Cannot create invite from an account");
      }
    }
    class ControlledAccount {
      constructor(account, agentSecret) {
        this.account = account;
        this.agentSecret = agentSecret;
        this.crypto = account.core.node.crypto;
      }
      get id() {
        return this.account.id;
      }
      currentAgentID() {
        if (this._cachedCurrentAgentID) {
          return this._cachedCurrentAgentID;
        }
        const agentID = this.crypto.getAgentID(this.agentSecret);
        this._cachedCurrentAgentID = agentID;
        return agentID;
      }
      currentSignerID() {
        return this.crypto.getAgentSignerID(this.currentAgentID());
      }
      currentSignerSecret() {
        return this.crypto.getAgentSignerSecret(this.agentSecret);
      }
      currentSealerID() {
        return this.crypto.getAgentSealerID(this.currentAgentID());
      }
      currentSealerSecret() {
        return this.crypto.getAgentSealerSecret(this.agentSecret);
      }
    }
    class ControlledAgent {
      constructor(agentSecret, crypto2) {
        this.agentSecret = agentSecret;
        this.crypto = crypto2;
      }
      get id() {
        return this.crypto.getAgentID(this.agentSecret);
      }
      currentAgentID() {
        return this.crypto.getAgentID(this.agentSecret);
      }
      currentSignerID() {
        return this.crypto.getAgentSignerID(this.currentAgentID());
      }
      currentSignerSecret() {
        return this.crypto.getAgentSignerSecret(this.agentSecret);
      }
      currentSealerID() {
        return this.crypto.getAgentSealerID(this.currentAgentID());
      }
      currentSealerSecret() {
        return this.crypto.getAgentSealerSecret(this.agentSecret);
      }
    }
    function expectAccount(content) {
      if (!(content instanceof RawAccount)) {
        throw new Error("Expected an account");
      }
      return content;
    }
    function decodeUnicodeData(data2, cats = "") {
      let buf = (
        /** @type {Array<CategorizedUnicodeRange<T>>} */
        []
      ), nums = data2.split(",").map((s) => s ? parseInt(s, 36) : 0), n = 0;
      for (let i = 0; i < nums.length; i++)
        i % 2 ? buf.push([
          n,
          n + nums[i],
          /** @type {T} */
          cats ? parseInt(cats[i >> 1], 36) : 0
        ]) : n = nums[i];
      return buf;
    }
    function findUnicodeRangeIndex(cp, ranges) {
      let lo = 0, hi = ranges.length - 1;
      while (lo <= hi) {
        let mid = lo + hi >> 1, range = ranges[mid], l = range[0], h = range[1];
        if (l <= cp && cp <= h) return mid;
        else if (cp > h) lo = mid + 1;
        else hi = mid - 1;
      }
      return -1;
    }
    function isBMP(c) {
      return c <= 65535;
    }
    const grapheme_ranges = decodeUnicodeData(
      /** @type {UnicodeDataEncoding} */
      ",9,a,,b,1,d,,e,h,3j,w,4p,,4t,,4u,,lc,33,w3,6,13l,18,14v,,14x,1,150,1,153,,16o,5,174,a,17g,,18r,k,19s,,1cm,6,1ct,,1cv,5,1d3,1,1d6,3,1e7,,1e9,,1f4,q,1ie,a,1kb,8,1kt,,1li,3,1ln,8,1lx,2,1m1,4,1nd,2,1ow,1,1p3,8,1qi,n,1r6,,1r7,v,1s3,,1tm,,1tn,,1to,,1tq,2,1tt,7,1u1,3,1u5,,1u6,1,1u9,6,1uq,1,1vl,,1vm,1,1x8,,1xa,,1xb,1,1xd,3,1xj,1,1xn,1,1xp,,1xz,,1ya,1,1z2,,1z5,1,1z7,,20s,,20u,2,20x,1,213,1,217,2,21d,,228,1,22d,,22p,1,22r,,24c,,24e,2,24h,4,24n,1,24p,,24r,1,24t,,25e,1,262,5,269,,26a,1,27w,,27y,1,280,,281,3,287,1,28b,1,28d,,28l,2,28y,1,29u,,2bi,,2bj,,2bk,,2bl,1,2bq,2,2bu,2,2bx,,2c7,,2dc,,2dd,2,2dg,,2f0,,2f2,2,2f5,3,2fa,2,2fe,3,2fp,1,2g2,1,2gx,,2gy,1,2ik,,2im,,2in,1,2ip,,2iq,,2ir,1,2iu,2,2iy,3,2j9,1,2jm,1,2k3,,2kg,1,2ki,1,2m3,1,2m6,,2m7,1,2m9,3,2me,2,2mi,2,2ml,,2mm,,2mv,,2n6,1,2o1,,2o2,1,2q2,,2q7,,2q8,1,2qa,2,2qe,,2qg,6,2qn,,2r6,1,2sx,,2sz,,2t0,6,2tj,7,2wh,,2wj,,2wk,8,2x4,6,2zc,1,305,,307,,309,,30e,1,31t,d,327,,328,4,32e,1,32l,a,32x,z,346,,371,3,375,,376,5,37d,1,37f,1,37h,1,386,1,388,1,38e,2,38x,3,39e,,39g,,39h,1,39p,,3a5,,3cw,2n,3fk,1z,3hk,2f,3tp,2,4k2,3,4ky,2,4lu,1,4mq,1,4ok,1,4om,,4on,6,4ou,7,4p2,,4p3,1,4p5,a,4pp,,4qz,2,4r2,,4r3,,4ud,1,4vd,,4yo,2,4yr,3,4yv,1,4yx,2,4z4,1,4z6,,4z7,5,4zd,2,55j,1,55l,1,55n,,579,,57a,,57b,,57c,6,57k,,57m,,57p,7,57x,5,583,9,58f,,59s,u,5c0,3,5c4,,5dg,9,5dq,3,5du,2,5ez,8,5fk,1,5fm,,5gh,,5gi,3,5gm,1,5go,5,5ie,,5if,,5ig,1,5ii,2,5il,,5im,,5in,4,5k4,7,5kc,7,5kk,1,5km,1,5ow,2,5p0,c,5pd,,5pe,6,5pp,,5pw,,5pz,,5q0,1,5vk,1r,6bv,,6bw,,6bx,,6by,1,6co,6,6d8,,6dl,,6e8,f,6hc,w,6jm,,6k9,,6ms,5,6nd,1,6xm,1,6y0,,70o,,72n,,73d,a,73s,2,79e,,7fu,1,7g6,,7gg,,7i3,3,7i8,5,7if,b,7is,35,7m8,39,7pk,a,7pw,,7py,,7q5,,7q9,,7qg,,7qr,1,7r8,,7rb,,7rg,,7ri,,7rn,2,7rr,,7s3,4,7th,2,7tt,,7u8,,7un,,850,1,8hx,2,8ij,1,8k0,,8k5,,8vj,2,8zj,,928,v,9ii,5,9io,,9j1,,9ll,1,9zr,,9zt,,wvj,3,wvo,9,wwu,1,wz4,1,x6q,,x6u,,x6z,,x7n,1,x7p,1,x7r,,x7w,,xa8,1,xbo,f,xc4,1,xcw,h,xdr,,xeu,7,xfr,a,xg2,,xg3,,xgg,s,xhc,2,xhf,,xir,,xis,1,xiu,3,xiy,1,xj0,1,xj2,1,xj4,,xk5,,xm1,5,xm7,1,xm9,1,xmb,1,xmd,1,xmr,,xn0,,xn1,,xoc,,xps,,xpu,2,xpz,1,xq6,1,xq9,,xrf,,xrg,1,xri,1,xrp,,xrq,,xyb,1,xyd,,xye,1,xyg,,xyh,1,xyk,,xyl,,xz4,,xz5,q,xzw,,xzx,q,y0o,,y0p,q,y1g,,y1h,q,y28,,y29,q,y30,,y31,q,y3s,,y3t,q,y4k,,y4l,q,y5c,,y5d,q,y64,,y65,q,y6w,,y6x,q,y7o,,y7p,q,y8g,,y8h,q,y98,,y99,q,ya0,,ya1,q,yas,,yat,q,ybk,,ybl,q,ycc,,ycd,q,yd4,,yd5,q,ydw,,ydx,q,yeo,,yep,q,yfg,,yfh,q,yg8,,yg9,q,yh0,,yh1,q,yhs,,yht,q,yik,,yil,q,yjc,,yjd,q,yk4,,yk5,q,ykw,,ykx,q,ylo,,ylp,q,ymg,,ymh,q,yn8,,yn9,q,yo0,,yo1,q,yos,,yot,q,ypk,,ypl,q,yqc,,yqd,q,yr4,,yr5,q,yrw,,yrx,q,yso,,ysp,q,ytg,,yth,q,yu8,,yu9,q,yv0,,yv1,q,yvs,,yvt,q,ywk,,ywl,q,yxc,,yxd,q,yy4,,yy5,q,yyw,,yyx,q,yzo,,yzp,q,z0g,,z0h,q,z18,,z19,q,z20,,z21,q,z2s,,z2t,q,z3k,,z3l,q,z4c,,z4d,q,z54,,z55,q,z5w,,z5x,q,z6o,,z6p,q,z7g,,z7h,q,z88,,z89,q,z90,,z91,q,z9s,,z9t,q,zak,,zal,q,zbc,,zbd,q,zc4,,zc5,q,zcw,,zcx,q,zdo,,zdp,q,zeg,,zeh,q,zf8,,zf9,q,zg0,,zg1,q,zgs,,zgt,q,zhk,,zhl,q,zic,,zid,q,zj4,,zj5,q,zjw,,zjx,q,zko,,zkp,q,zlg,,zlh,q,zm8,,zm9,q,zn0,,zn1,q,zns,,znt,q,zok,,zol,q,zpc,,zpd,q,zq4,,zq5,q,zqw,,zqx,q,zro,,zrp,q,zsg,,zsh,q,zt8,,zt9,q,zu0,,zu1,q,zus,,zut,q,zvk,,zvl,q,zwc,,zwd,q,zx4,,zx5,q,zxw,,zxx,q,zyo,,zyp,q,zzg,,zzh,q,1008,,1009,q,1010,,1011,q,101s,,101t,q,102k,,102l,q,103c,,103d,q,1044,,1045,q,104w,,104x,q,105o,,105p,q,106g,,106h,q,1078,,1079,q,1080,,1081,q,108s,,108t,q,109k,,109l,q,10ac,,10ad,q,10b4,,10b5,q,10bw,,10bx,q,10co,,10cp,q,10dg,,10dh,q,10e8,,10e9,q,10f0,,10f1,q,10fs,,10ft,q,10gk,,10gl,q,10hc,,10hd,q,10i4,,10i5,q,10iw,,10ix,q,10jo,,10jp,q,10kg,,10kh,q,10l8,,10l9,q,10m0,,10m1,q,10ms,,10mt,q,10nk,,10nl,q,10oc,,10od,q,10p4,,10p5,q,10pw,,10px,q,10qo,,10qp,q,10rg,,10rh,q,10s8,,10s9,q,10t0,,10t1,q,10ts,,10tt,q,10uk,,10ul,q,10vc,,10vd,q,10w4,,10w5,q,10ww,,10wx,q,10xo,,10xp,q,10yg,,10yh,q,10z8,,10z9,q,1100,,1101,q,110s,,110t,q,111k,,111l,q,112c,,112d,q,1134,,1135,q,113w,,113x,q,114o,,114p,q,115g,,115h,q,1168,,1169,q,1170,,1171,q,117s,,117t,q,118k,,118l,q,119c,,119d,q,11a4,,11a5,q,11aw,,11ax,q,11bo,,11bp,q,11cg,,11ch,q,11d8,,11d9,q,11e0,,11e1,q,11es,,11et,q,11fk,,11fl,q,11gc,,11gd,q,11h4,,11h5,q,11hw,,11hx,q,11io,,11ip,q,11jg,,11jh,q,11k8,,11k9,q,11l0,,11l1,q,11ls,,11lt,q,11mk,,11ml,q,11nc,,11nd,q,11o4,,11o5,q,11ow,,11ox,q,11po,,11pp,q,11qg,,11qh,q,11r8,,11r9,q,11s0,,11s1,q,11ss,,11st,q,11tk,,11tl,q,11uc,,11ud,q,11v4,,11v5,q,11vw,,11vx,q,11wo,,11wp,q,11xg,,11xh,q,11y8,,11y9,q,11z0,,11z1,q,11zs,,11zt,q,120k,,120l,q,121c,,121d,q,1224,,1225,q,122w,,122x,q,123o,,123p,q,124g,,124h,q,1258,,1259,q,1260,,1261,q,126s,,126t,q,127k,,127l,q,128c,,128d,q,1294,,1295,q,129w,,129x,q,12ao,,12ap,q,12bg,,12bh,q,12c8,,12c9,q,12d0,,12d1,q,12ds,,12dt,q,12ek,,12el,q,12fc,,12fd,q,12g4,,12g5,q,12gw,,12gx,q,12ho,,12hp,q,12ig,,12ih,q,12j8,,12j9,q,12k0,,12k1,q,12ks,,12kt,q,12lk,,12ll,q,12mc,,12md,q,12n4,,12n5,q,12nw,,12nx,q,12oo,,12op,q,12pg,,12ph,q,12q8,,12q9,q,12r0,,12r1,q,12rs,,12rt,q,12sk,,12sl,q,12tc,,12td,q,12u4,,12u5,q,12uw,,12ux,q,12vo,,12vp,q,12wg,,12wh,q,12x8,,12x9,q,12y0,,12y1,q,12ys,,12yt,q,12zk,,12zl,q,130c,,130d,q,1314,,1315,q,131w,,131x,q,132o,,132p,q,133g,,133h,q,1348,,1349,q,1350,,1351,q,135s,,135t,q,136k,,136l,q,137c,,137d,q,1384,,1385,q,138w,,138x,q,139o,,139p,q,13ag,,13ah,q,13b8,,13b9,q,13c0,,13c1,q,13cs,,13ct,q,13dk,,13dl,q,13ec,,13ed,q,13f4,,13f5,q,13fw,,13fx,q,13go,,13gp,q,13hg,,13hh,q,13i8,,13i9,q,13j0,,13j1,q,13js,,13jt,q,13kk,,13kl,q,13lc,,13ld,q,13m4,,13m5,q,13mw,,13mx,q,13no,,13np,q,13og,,13oh,q,13p8,,13p9,q,13q0,,13q1,q,13qs,,13qt,q,13rk,,13rl,q,13sc,,13sd,q,13t4,,13t5,q,13tw,,13tx,q,13uo,,13up,q,13vg,,13vh,q,13w8,,13w9,q,13x0,,13x1,q,13xs,,13xt,q,13yk,,13yl,q,13zc,,13zd,q,1404,,1405,q,140w,,140x,q,141o,,141p,q,142g,,142h,q,1438,,1439,q,1440,,1441,q,144s,,144t,q,145k,,145l,q,146c,,146d,q,1474,,1475,q,147w,,147x,q,148o,,148p,q,149g,,149h,q,14a8,,14a9,q,14b0,,14b1,q,14bs,,14bt,q,14ck,,14cl,q,14dc,,14dd,q,14e4,,14e5,q,14ew,,14ex,q,14fo,,14fp,q,14gg,,14gh,q,14h8,,14h9,q,14i0,,14i1,q,14is,,14it,q,14jk,,14jl,q,14kc,,14kd,q,14l4,,14l5,q,14lw,,14lx,q,14mo,,14mp,q,14ng,,14nh,q,14o8,,14o9,q,14p0,,14p1,q,14ps,,14pt,q,14qk,,14ql,q,14rc,,14rd,q,14s4,,14s5,q,14sw,,14sx,q,14to,,14tp,q,14ug,,14uh,q,14v8,,14v9,q,14w0,,14w1,q,14ws,,14wt,q,14xk,,14xl,q,14yc,,14yd,q,14z4,,14z5,q,14zw,,14zx,q,150o,,150p,q,151g,,151h,q,1528,,1529,q,1530,,1531,q,153s,,153t,q,154k,,154l,q,155c,,155d,q,1564,,1565,q,156w,,156x,q,157o,,157p,q,158g,,158h,q,1598,,1599,q,15a0,,15a1,q,15as,,15at,q,15bk,,15bl,q,15cc,,15cd,q,15d4,,15d5,q,15dw,,15dx,q,15eo,,15ep,q,15fg,,15fh,q,15g8,,15g9,q,15h0,,15h1,q,15hs,,15ht,q,15ik,,15il,q,15jc,,15jd,q,15k4,,15k5,q,15kw,,15kx,q,15lo,,15lp,q,15mg,,15mh,q,15n8,,15n9,q,15o0,,15o1,q,15os,,15ot,q,15pk,,15pl,q,15qc,,15qd,q,15r4,,15r5,q,15rw,,15rx,q,15so,,15sp,q,15tg,,15th,q,15u8,,15u9,q,15v0,,15v1,q,15vs,,15vt,q,15wk,,15wl,q,15xc,,15xd,q,15y4,,15y5,q,15yw,,15yx,q,15zo,,15zp,q,160g,,160h,q,1618,,1619,q,1620,,1621,q,162s,,162t,q,163k,,163l,q,164c,,164d,q,1654,,1655,q,165w,,165x,q,166o,,166p,q,167g,,167h,q,1688,,1689,q,1690,,1691,q,169s,,169t,q,16ak,,16al,q,16bc,,16bd,q,16c4,,16c5,q,16cw,,16cx,q,16do,,16dp,q,16eg,,16eh,q,16f8,,16f9,q,16g0,,16g1,q,16gs,,16gt,q,16hk,,16hl,q,16ic,,16id,q,16j4,,16j5,q,16jw,,16jx,q,16ko,,16kp,q,16ls,m,16mj,1c,1dlq,,1e68,f,1e74,f,1edb,,1ehq,1,1ek0,b,1eyl,,1f4w,,1f92,4,1gjl,2,1gjp,1,1gjw,3,1gl4,2,1glb,,1gpx,1,1h5w,3,1h7t,4,1hgr,1,1hj0,3,1hl2,a,1hmq,3,1hq8,,1hq9,,1hqa,,1hrs,e,1htc,,1htf,1,1htr,2,1htu,,1hv4,2,1hv7,3,1hvb,1,1hvd,1,1hvh,,1hvm,,1hvx,,1hxc,2,1hyf,4,1hyk,,1hyl,7,1hz9,1,1i0j,,1i0w,1,1i0y,,1i2b,2,1i2e,8,1i2n,,1i2o,,1i2q,1,1i2x,3,1i32,,1i33,,1i5o,2,1i5r,2,1i5u,1,1i5w,3,1i66,,1i69,,1ian,,1iao,2,1iar,7,1ibk,1,1ibm,1,1id7,1,1ida,,1idb,,1idc,,1idd,3,1idj,1,1idn,1,1idp,,1idz,,1iea,1,1iee,6,1ieo,4,1igo,,1igp,1,1igr,5,1igy,,1ih1,,1ih3,2,1ih6,,1ih8,1,1iha,2,1ihd,,1ihe,,1iht,1,1ik5,2,1ik8,7,1ikg,1,1iki,2,1ikl,,1ikm,,1ila,,1ink,,1inl,1,1inn,5,1int,,1inu,,1inv,1,1inx,,1iny,,1inz,1,1io1,,1io2,1,1iun,,1iuo,1,1iuq,3,1iuw,3,1iv0,1,1iv2,,1iv3,1,1ivw,1,1iy8,2,1iyb,7,1iyj,1,1iyl,,1iym,,1iyn,1,1j1n,,1j1o,,1j1p,,1j1q,1,1j1s,7,1j4t,,1j4u,,1j4v,,1j4y,3,1j52,,1j53,4,1jcc,2,1jcf,8,1jco,,1jcp,1,1jjk,,1jjl,4,1jjr,1,1jjv,3,1jjz,,1jk0,,1jk1,,1jk2,,1jk3,,1jo1,2,1jo4,3,1joa,1,1joc,3,1jog,,1jok,,1jpd,9,1jqr,5,1jqx,,1jqy,,1jqz,3,1jrb,,1jrl,5,1jrr,1,1jrt,2,1jt0,5,1jt6,c,1jtj,,1jtk,1,1k4v,,1k4w,6,1k54,5,1k5a,,1k5b,,1k7m,l,1k89,,1k8a,6,1k8h,,1k8i,1,1k8k,,1k8l,1,1kc1,5,1kca,,1kcc,1,1kcf,6,1kcm,,1kcn,,1kei,4,1keo,1,1ker,1,1ket,,1keu,,1kev,,1koj,1,1kol,1,1kow,1,1koy,,1koz,,1kqc,1,1kqe,4,1kqm,1,1kqo,2,1kre,,1ovk,f,1ow0,,1ow7,e,1xr2,b,1xre,2,1xrh,2,1zow,4,1zqo,6,206b,,206f,3,20jz,,20k1,1i,20lr,3,20o4,,20og,1,2ftp,1,2fts,3,2jgg,19,2jhs,m,2jxh,4,2jxp,5,2jxv,7,2jy3,7,2jyd,6,2jze,3,2k3m,2,2lmo,1i,2lob,1d,2lpx,,2lqc,,2lqz,4,2lr5,e,2mtc,6,2mtk,g,2mu3,6,2mub,1,2mue,4,2mxb,,2n1s,6,2nce,,2ne4,3,2nsc,3,2nzi,1,2ok0,6,2on8,6,2pz4,73,2q6l,2,2q7j,,2q98,5,2q9q,1,2qa6,,2qa9,9,2qb1,1k,2qcm,p,2qdd,e,2qe2,,2qen,,2qeq,8,2qf0,3,2qfd,c1,2qrf,4,2qrk,8t,2r0m,7d,2r9c,3j,2rg4,b,2rit,16,2rkc,3,2rm0,7,2rmi,5,2rns,7,2rou,29,2rrg,1a,2rss,9,2rt3,c8,2scg,sd,jny8,v,jnz4,2n,jo1s,3j,jo5c,6n,joc0,2rz",
      "262122424333333393233393339333333333393393b3b3b3b3b333b33b3bb33333b3b3333333b3b33bb3333b33b3bb33333b3bbb333b333b33333b3b3b3b3333b3b33b3bb39333b33b33b3b3b333b333333b3b333333b33b3b3333b3335dc333333b3b3b33323333b3bb3b33b3b3b3333b3333b3b333bb3b33b3b3b3b3b333b333b3323e2244234444444444444444444444444444444444444444443333443443333333b3b3bb33333b353b3b3b3b333b3b333b333333b3bb3b3b3bb3787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878dc333232333333333333333b3b3333bb3b393933b3b33bb3b393b3b3b3333b33b33b3bbb33b333b3333bb3933b3b3b333b3b3b3b3b33b3b3b33b3b3b33b3b33b33b3b3b33bb39b9b3b33b3b33b9333b393b3b33b33b3b3b3333393b3b3b33b39bb3b332333b333dd3b33332333323333333333333333333333344444444a44444434444444444444423232"
    );
    const consonant_ranges = decodeUnicodeData(
      /** @type {UnicodeDataEncoding} */
      "1sl,10,1ug,7,1vc,7,1w5,j,1wq,6,1wy,,1x2,3,1y4,1,1y7,,1yo,1,239,j,23u,6,242,1,245,4,261,,26t,j,27e,6,27m,1,27p,4,28s,1,28v,,29d,,2dx,j,2ei,f,2fs,2,2l1,11"
    );
    function* graphemeSegments(input) {
      if (input === "") {
        return;
      }
      let cursor = 0;
      let len = input.length;
      let catBefore = null;
      let catAfter = null;
      let catBegin = null;
      let cache = [
        0,
        0,
        2
        /* GC_Control */
      ];
      let risCount = 0;
      let emoji2 = false;
      let consonant = false;
      let linker = false;
      let incb = false;
      let cp = (
        /** @type number */
        input.codePointAt(cursor)
      );
      let index2 = 0;
      let segment = "";
      while (true) {
        segment += input[cursor++];
        if (!isBMP(cp)) {
          segment += input[cursor++];
        }
        catBefore = catAfter;
        if (catBefore === null) {
          catBefore = cat(cp, cache);
          catBegin = catBefore;
        }
        if (!consonant && catBefore === 0) {
          consonant = isIndicConjunctCosonant(cp);
        } else if (catBefore === 3) {
          linker = isIndicConjunctLinker(cp);
        }
        if (cursor < len) {
          cp = /** @type {number} */
          input.codePointAt(cursor);
          catAfter = cat(cp, cache);
        } else {
          yield {
            segment,
            index: index2,
            input,
            _catBegin: (
              /** @type {typeof catBefore} */
              catBegin
            ),
            _catEnd: catBefore
          };
          return;
        }
        if (catBefore === 10) {
          risCount += 1;
        } else {
          risCount = 0;
          if (catAfter === 14 && (catBefore === 3 || catBefore === 4)) {
            emoji2 = true;
          } else if (catAfter === 0) {
            incb = consonant && linker && (consonant = isIndicConjunctCosonant(cp));
            linker = linker && !consonant;
          }
        }
        if (isBoundary(catBefore, catAfter, risCount, emoji2, incb)) {
          yield {
            segment,
            index: index2,
            input,
            _catBegin: (
              /** @type {typeof catBefore} */
              catBegin
            ),
            _catEnd: catBefore
          };
          index2 = cursor;
          segment = "";
          emoji2 = false;
          incb = false;
          catBegin = catAfter;
        }
      }
    }
    function* splitGraphemes(text) {
      for (let s of graphemeSegments(text)) yield s.segment;
    }
    function cat(cp, cache) {
      if (cp < 127) {
        if (cp >= 32) {
          return 0;
        } else if (cp === 10) {
          return 6;
        } else if (cp === 13) {
          return 1;
        } else {
          return 2;
        }
      } else {
        if (cp < cache[0] || cp > cache[1]) {
          let index2 = findUnicodeRangeIndex(cp, grapheme_ranges);
          if (index2 < 0) {
            return 0;
          }
          let range = grapheme_ranges[index2];
          cache[0] = range[0];
          cache[1] = range[1];
          cache[2] = range[2];
        }
        return cache[2];
      }
    }
    function isIndicConjunctCosonant(cp) {
      return findUnicodeRangeIndex(cp, consonant_ranges) >= 0;
    }
    function isIndicConjunctLinker(cp) {
      return cp === 2381 || cp === 2509 || cp === 2765 || cp === 2893 || cp === 3149 || cp === 3405;
    }
    function isBoundary(catBefore, catAfter, risCount, emoji2, incb) {
      if (catBefore === 1 && catAfter === 6) {
        return false;
      }
      if (catBefore === 1 || catBefore === 2 || catBefore === 6) {
        return true;
      }
      if (catAfter === 1 || catAfter === 2 || catAfter === 6) {
        return true;
      }
      if (catBefore === 5 && (catAfter === 5 || catAfter === 7 || catAfter === 8 || catAfter === 13)) {
        return false;
      }
      if ((catBefore === 7 || catBefore === 13) && (catAfter === 12 || catAfter === 13)) {
        return false;
      }
      if (catAfter === 12 && (catBefore === 8 || catBefore === 12)) {
        return false;
      }
      if (catAfter === 3 || catAfter === 14) {
        return false;
      }
      if (catAfter === 11) {
        return false;
      }
      if (catBefore === 9) {
        return false;
      }
      if (catAfter === 0 && incb) {
        return false;
      }
      if (catBefore === 14 && catAfter === 4) {
        return !emoji2;
      }
      if (catBefore === 10 && catAfter === 10) {
        return risCount % 2 === 0;
      }
      return true;
    }
    function stringifyOpID(opID) {
      return `${opID.sessionID}:${opID.txIndex}:${opID.changeIdx}`;
    }
    class RawCoPlainText extends RawCoList {
      constructor(core) {
        super(core);
        this.type = "coplaintext";
        this._cachedMapping = /* @__PURE__ */ new WeakMap();
      }
      get mapping() {
        const entries = this.entries();
        let mapping = this._cachedMapping.get(entries);
        if (mapping) {
          return mapping;
        }
        mapping = {
          opIDbeforeIdx: [],
          opIDafterIdx: [],
          idxAfterOpID: {},
          idxBeforeOpID: {}
        };
        let idxBefore = 0;
        for (const entry of entries) {
          const idxAfter = idxBefore + 1;
          mapping.opIDafterIdx[idxBefore] = entry.opID;
          mapping.opIDbeforeIdx[idxAfter] = entry.opID;
          mapping.idxAfterOpID[stringifyOpID(entry.opID)] = idxAfter;
          mapping.idxBeforeOpID[stringifyOpID(entry.opID)] = idxBefore;
          idxBefore = idxAfter;
        }
        this._cachedMapping.set(entries, mapping);
        return mapping;
      }
      toString() {
        return this.entries().map((entry) => entry.value).join("");
      }
      /**
       * Inserts `text` before the character at index `idx`.
       * If idx is 0, inserts at the start of the text.
       *
       * @param idx - The index of the character to insert before
       * @param text - The text to insert
       * @param privacy - Whether the operation should be private or trusting
       * @category 2. Editing
       */
      insertBefore(idx, text, privacy = "private") {
        const graphemes = [...splitGraphemes(text)];
        if (idx === 0) {
          for (const grapheme of graphemes.reverse()) {
            this.prepend(grapheme, 0, privacy);
          }
        } else {
          this.appendItems(graphemes, idx - 1, privacy);
        }
      }
      /**
       * Inserts `text` after the character at index `idx`.
       *
       * @param idx - The index of the character to insert after
       * @param text - The text to insert
       * @param privacy - Whether the operation should be private or trusting
       * @category 2. Editing
       */
      insertAfter(idx, text, privacy = "private") {
        const graphemes = [...splitGraphemes(text)];
        if (idx >= this.entries().length) {
          this.appendItems(graphemes, idx - 1, privacy);
        } else {
          this.appendItems(graphemes, idx, privacy);
        }
      }
      deleteRange({ from, to }, privacy = "private") {
        const ops = [];
        for (let idx = from; idx < to; ) {
          const insertion = this.mapping.opIDafterIdx[idx];
          if (!insertion) {
            throw new Error("Invalid idx to delete " + idx);
          }
          ops.push({
            op: "del",
            insertion
          });
          let nextIdx = idx + 1;
          while (!this.mapping.opIDbeforeIdx[nextIdx] && nextIdx < to) {
            nextIdx++;
          }
          idx = nextIdx;
        }
        this.core.makeTransaction(ops, privacy);
        this.processNewTransactions();
      }
      /** @internal Helper method to split text into graphemes */
      toGraphemes(text) {
        return [...splitGraphemes(text)];
      }
      /** @internal Helper method to join graphemes into a string */
      fromGraphemes(graphemes) {
        return graphemes.join("");
      }
    }
    function coreToCoValue(core, options) {
      var _a;
      if (core.verified.header.type === "comap") {
        if (core.verified.header.ruleset.type === "group") {
          if (((_a = core.verified.header.meta) == null ? void 0 : _a.type) === "account" && !(options == null ? void 0 : options.ignorePrivateTransactions)) {
            return new RawAccount(core);
          } else {
            return new RawGroup(core, options);
          }
        } else {
          return new RawCoMap(core);
        }
      } else if (core.verified.header.type === "coplaintext") {
        return new RawCoPlainText(core);
      } else if (core.verified.header.type === "colist") {
        return new RawCoList(core);
      } else if (core.verified.header.type === "costream") {
        if (core.verified.header.meta && core.verified.header.meta.type === "binary") {
          return new RawBinaryCoStream(core);
        } else {
          return new RawCoStream(core);
        }
      } else {
        return new RawUnknownCoValue(core);
      }
    }
    let logPermissionErrors = true;
    function disablePermissionErrors() {
      logPermissionErrors = false;
    }
    function logPermissionError(message, attributes) {
      if (logPermissionErrors === false) {
        return;
      }
      logger.debug("Permission error: " + message, attributes);
    }
    function determineValidTransactions(coValue, knownTransactions) {
      if (!coValue.isAvailable()) {
        throw new Error("determineValidTransactions CoValue is not available");
      }
      if (coValue.verified.header.ruleset.type === "group") {
        const initialAdmin = coValue.verified.header.ruleset.initialAdmin;
        if (!initialAdmin) {
          throw new Error("Group must have initialAdmin");
        }
        return determineValidTransactionsForGroup(coValue, initialAdmin).validTransactions;
      } else if (coValue.verified.header.ruleset.type === "ownedByGroup") {
        const groupContent = expectGroup(coValue.node.expectCoValueLoaded(coValue.verified.header.ruleset.group, "Determining valid transaction in owned object but its group wasn't loaded").getCurrentContent());
        if (groupContent.type !== "comap") {
          throw new Error("Group must be a map");
        }
        const validTransactions = [];
        for (const [sessionID, sessionLog] of coValue.verified.sessions.entries()) {
          const transactor = accountOrAgentIDfromSessionID(sessionID);
          const knownTransactionsForSession = (knownTransactions == null ? void 0 : knownTransactions[sessionID]) ?? -1;
          sessionLog.transactions.forEach((tx, txIndex) => {
            if (knownTransactionsForSession >= txIndex) {
              return;
            }
            const groupAtTime = groupContent.atTime(tx.madeAt);
            const effectiveTransactor = agentInAccountOrMemberInGroup(transactor, groupAtTime);
            if (!effectiveTransactor) {
              return;
            }
            const transactorRoleAtTxTime = groupAtTime.roleOfInternal(effectiveTransactor);
            if (transactorRoleAtTxTime !== "admin" && transactorRoleAtTxTime !== "writer" && transactorRoleAtTxTime !== "writeOnly") {
              return;
            }
            validTransactions.push({ txID: { sessionID, txIndex }, tx });
          });
        }
        return validTransactions;
      } else if (coValue.verified.header.ruleset.type === "unsafeAllowAll") {
        const validTransactions = [];
        for (const [sessionID, sessionLog] of coValue.verified.sessions.entries()) {
          const knownTransactionsForSession = (knownTransactions == null ? void 0 : knownTransactions[sessionID]) ?? -1;
          sessionLog.transactions.forEach((tx, txIndex) => {
            if (knownTransactionsForSession >= txIndex) {
              return;
            }
            validTransactions.push({ txID: { sessionID, txIndex }, tx });
          });
        }
        return validTransactions;
      } else {
        throw new Error("Unknown ruleset type " + coValue.verified.header.ruleset.type);
      }
    }
    function isHigherRole(a, b) {
      if (a === void 0 || a === "revoked")
        return false;
      if (b === void 0 || b === "revoked")
        return true;
      if (b === "admin")
        return false;
      if (a === "admin")
        return true;
      return a === "writer" && b === "reader";
    }
    function resolveMemberStateFromParentReference(coValue, memberState, parentReference, roleMapping, extendChain) {
      const parentGroup = coValue.node.expectCoValueLoaded(getParentGroupId(parentReference), "Expected parent group to be loaded");
      if (parentGroup.verified.header.ruleset.type !== "group") {
        return;
      }
      if (extendChain.has(parentGroup.id)) {
        return;
      }
      const initialAdmin = parentGroup.verified.header.ruleset.initialAdmin;
      if (!initialAdmin) {
        throw new Error("Group must have initialAdmin");
      }
      extendChain.add(parentGroup.id);
      const { memberState: parentGroupMemberState } = determineValidTransactionsForGroup(parentGroup, initialAdmin, extendChain);
      for (const agent of Object.keys(parentGroupMemberState)) {
        const parentRole = parentGroupMemberState[agent];
        const currentRole = memberState[agent];
        if (isInheritableRole(parentRole)) {
          if (roleMapping !== "extend" && isHigherRole(roleMapping, currentRole)) {
            memberState[agent] = roleMapping;
          } else if (isHigherRole(parentRole, currentRole)) {
            memberState[agent] = parentRole;
          }
        }
      }
    }
    function determineValidTransactionsForGroup(coValue, initialAdmin, extendChain) {
      var _a;
      const allTransactionsSorted = [];
      for (const [sessionID, sessionLog] of ((_a = coValue.verified) == null ? void 0 : _a.sessions.entries()) ?? []) {
        sessionLog.transactions.forEach((tx, txIndex) => {
          allTransactionsSorted.push({ sessionID, txIndex, tx });
        });
      }
      allTransactionsSorted.sort((a, b) => {
        return a.tx.madeAt - b.tx.madeAt;
      });
      const memberState = {};
      const writeOnlyKeys = {};
      const validTransactions = [];
      const writeKeys = /* @__PURE__ */ new Set();
      for (const { sessionID, txIndex, tx } of allTransactionsSorted) {
        const transactor = accountOrAgentIDfromSessionID(sessionID);
        if (tx.privacy === "private") {
          if (memberState[transactor] === "admin") {
            validTransactions.push({
              txID: { sessionID, txIndex },
              tx
            });
            continue;
          } else {
            logPermissionError("Only admins can make private transactions in groups");
            continue;
          }
        }
        let changes;
        try {
          changes = parseJSON(tx.changes);
        } catch (e) {
          logPermissionError("Invalid JSON in transaction", {
            id: coValue.id,
            tx
          });
          continue;
        }
        const change = changes[0];
        if (changes.length !== 1) {
          logPermissionError("Group transaction must have exactly one change");
          continue;
        }
        if (change.op !== "set") {
          logPermissionError("Group transaction must set a role or readKey");
          continue;
        }
        if (change.key === "readKey") {
          if (memberState[transactor] !== "admin") {
            logPermissionError("Only admins can set readKeys");
            continue;
          }
          validTransactions.push({ txID: { sessionID, txIndex }, tx });
          continue;
        } else if (change.key === "profile") {
          if (memberState[transactor] !== "admin") {
            logPermissionError("Only admins can set profile");
            continue;
          }
          validTransactions.push({ txID: { sessionID, txIndex }, tx });
          continue;
        } else if (isKeyForKeyField(change.key) || isKeyForAccountField(change.key)) {
          if (memberState[transactor] !== "admin" && memberState[transactor] !== "adminInvite" && memberState[transactor] !== "writerInvite" && memberState[transactor] !== "readerInvite" && memberState[transactor] !== "writeOnlyInvite" && !isOwnWriteKeyRevelation(change.key, transactor, writeOnlyKeys)) {
            logPermissionError("Only admins can reveal keys");
            continue;
          }
          validTransactions.push({ txID: { sessionID, txIndex }, tx });
          continue;
        } else if (isParentExtension(change.key)) {
          if (memberState[transactor] !== "admin") {
            logPermissionError("Only admins can set parent extensions");
            continue;
          }
          extendChain = extendChain ?? /* @__PURE__ */ new Set([]);
          resolveMemberStateFromParentReference(coValue, memberState, change.key, change.value, extendChain);
          if (extendChain.has(coValue.id)) {
            logPermissionError("Circular extend detected, dropping the transaction");
            continue;
          }
          validTransactions.push({ txID: { sessionID, txIndex }, tx });
          continue;
        } else if (isChildExtension(change.key)) {
          validTransactions.push({ txID: { sessionID, txIndex }, tx });
          continue;
        } else if (isWriteKeyForMember(change.key)) {
          const memberKey = getAccountOrAgentFromWriteKeyForMember(change.key);
          if (memberState[transactor] !== "admin" && memberState[transactor] !== "writeOnlyInvite" && memberKey !== transactor) {
            logPermissionError("Only admins can set writeKeys");
            continue;
          }
          writeOnlyKeys[memberKey] = change.value;
          if (writeKeys.has(change.key) && memberState[transactor] !== "admin") {
            logPermissionError("Write key already exists and can't be overridden by invite");
            continue;
          }
          writeKeys.add(change.key);
          validTransactions.push({ txID: { sessionID, txIndex }, tx });
          continue;
        }
        const affectedMember = change.key;
        const assignedRole = change.value;
        if (change.value !== "admin" && change.value !== "writer" && change.value !== "reader" && change.value !== "writeOnly" && change.value !== "revoked" && change.value !== "adminInvite" && change.value !== "writerInvite" && change.value !== "readerInvite" && change.value !== "writeOnlyInvite") {
          logPermissionError("Group transaction must set a valid role");
          continue;
        }
        if (affectedMember === EVERYONE && !(change.value === "reader" || change.value === "writer" || change.value === "writeOnly" || change.value === "revoked")) {
          logPermissionError("Everyone can only be set to reader, writer, writeOnly or revoked");
          continue;
        }
        const isFirstSelfAppointment = !memberState[transactor] && transactor === initialAdmin && change.op === "set" && change.key === transactor && change.value === "admin";
        const currentAccountId = coValue.node.getCurrentAccountOrAgentID();
        const isSelfRevoke = currentAccountId === change.key && change.value === "revoked";
        if (!isFirstSelfAppointment && !isSelfRevoke) {
          if (memberState[transactor] === "admin") {
            if (memberState[affectedMember] === "admin" && affectedMember !== transactor && assignedRole !== "admin") {
              logPermissionError("Admins can only demote themselves.");
              continue;
            }
          } else if (memberState[transactor] === "adminInvite") {
            if (change.value !== "admin") {
              logPermissionError("AdminInvites can only create admins.");
              continue;
            }
          } else if (memberState[transactor] === "writerInvite") {
            if (change.value !== "writer") {
              logPermissionError("WriterInvites can only create writers.");
              continue;
            }
          } else if (memberState[transactor] === "readerInvite") {
            if (change.value !== "reader") {
              logPermissionError("ReaderInvites can only create reader.");
              continue;
            }
          } else if (memberState[transactor] === "writeOnlyInvite") {
            if (change.value !== "writeOnly") {
              logPermissionError("WriteOnlyInvites can only create writeOnly.");
              continue;
            }
          } else {
            logPermissionError("Group transaction must be made by current admin or invite");
            continue;
          }
        }
        memberState[affectedMember] = change.value;
        validTransactions.push({ txID: { sessionID, txIndex }, tx });
      }
      return { validTransactions, memberState };
    }
    function agentInAccountOrMemberInGroup(transactor, groupAtTime) {
      if (transactor === groupAtTime.id && groupAtTime instanceof RawAccount) {
        return groupAtTime.currentAgentID();
      }
      return transactor;
    }
    function isWriteKeyForMember(co) {
      return co.startsWith("writeKeyFor_");
    }
    function getAccountOrAgentFromWriteKeyForMember(co) {
      return co.slice("writeKeyFor_".length);
    }
    function isKeyForKeyField(co) {
      return co.startsWith("key_") && co.includes("_for_key");
    }
    function isKeyForAccountField(co) {
      return co.startsWith("key_") && (co.includes("_for_sealer") || co.includes("_for_co")) || co.includes("_for_everyone");
    }
    function isParentExtension(key) {
      return key.startsWith("parent_");
    }
    function isChildExtension(key) {
      return key.startsWith("child_");
    }
    function isOwnWriteKeyRevelation(key, memberKey, writeOnlyKeys) {
      if (Object.keys(writeOnlyKeys).length === 0) {
        return false;
      }
      const keyID = key.slice(0, key.indexOf("_for_"));
      return writeOnlyKeys[memberKey] === keyID;
    }
    const CO_VALUE_PRIORITY$1 = {
      HIGH: 0,
      MEDIUM: 3,
      LOW: 6
    };
    function getPriorityFromHeader(header) {
      var _a, _b;
      if (typeof header === "boolean" || !header) {
        return CO_VALUE_PRIORITY$1.MEDIUM;
      }
      if (((_a = header.meta) == null ? void 0 : _a.type) === "account") {
        return CO_VALUE_PRIORITY$1.HIGH;
      }
      if (header.ruleset.type === "group") {
        return CO_VALUE_PRIORITY$1.HIGH;
      }
      if (header.type === "costream" && ((_b = header.meta) == null ? void 0 : _b.type) === "binary") {
        return CO_VALUE_PRIORITY$1.LOW;
      }
      return CO_VALUE_PRIORITY$1.MEDIUM;
    }
    class LinkedList {
      constructor(meter) {
        this.meter = meter;
        this.head = void 0;
        this.tail = void 0;
        this.length = 0;
      }
      push(value) {
        var _a;
        const node = { value, next: void 0 };
        if (this.head === void 0) {
          this.head = node;
          this.tail = node;
        } else if (this.tail) {
          this.tail.next = node;
          this.tail = node;
        } else {
          throw new Error("LinkedList is corrupted");
        }
        this.length++;
        (_a = this.meter) == null ? void 0 : _a.push();
      }
      shift() {
        var _a;
        if (!this.head) {
          return void 0;
        }
        const node = this.head;
        const value = node.value;
        this.head = node.next;
        node.next = void 0;
        if (this.head === void 0) {
          this.tail = void 0;
        }
        this.length--;
        (_a = this.meter) == null ? void 0 : _a.pull();
        return value;
      }
      isEmpty() {
        return this.head === void 0;
      }
    }
    class QueueMeter {
      constructor(prefix, attrs) {
        this.attrs = attrs;
        this.pullCounter = metrics.getMeter("cojson").createCounter(`${prefix}.pulled`, {
          description: "Number of messages pulled from the queue",
          valueType: ValueType.INT,
          unit: "1"
        });
        this.pushCounter = metrics.getMeter("cojson").createCounter(`${prefix}.pushed`, {
          description: "Number of messages pushed to the queue",
          valueType: ValueType.INT,
          unit: "1"
        });
        this.pullCounter.add(0, this.attrs);
        this.pushCounter.add(0, this.attrs);
      }
      pull() {
        this.pullCounter.add(1, this.attrs);
      }
      push() {
        this.pushCounter.add(1, this.attrs);
      }
    }
    function meteredList(type, attrs) {
      return new LinkedList(new QueueMeter("jazz.messagequeue." + type, attrs));
    }
    const PRIORITY_TO_QUEUE_INDEX = {
      [CO_VALUE_PRIORITY$1.HIGH]: 0,
      [CO_VALUE_PRIORITY$1.MEDIUM]: 1,
      [CO_VALUE_PRIORITY$1.LOW]: 2
    };
    class PriorityBasedMessageQueue {
      constructor(defaultPriority, type, attrs) {
        this.defaultPriority = defaultPriority;
        this.queues = [
          meteredList(type, { priority: CO_VALUE_PRIORITY$1.HIGH, ...attrs }),
          meteredList(type, { priority: CO_VALUE_PRIORITY$1.MEDIUM, ...attrs }),
          meteredList(type, { priority: CO_VALUE_PRIORITY$1.LOW, ...attrs })
        ];
      }
      getQueue(priority) {
        return this.queues[PRIORITY_TO_QUEUE_INDEX[priority]];
      }
      push(msg) {
        const priority = "priority" in msg ? msg.priority : this.defaultPriority;
        this.getQueue(priority).push(msg);
      }
      pull() {
        var _a;
        const priority = this.queues.findIndex((queue) => queue.length > 0);
        return (_a = this.queues[priority]) == null ? void 0 : _a.shift();
      }
    }
    class IncomingMessagesQueue {
      constructor() {
        this.currentQueue = 0;
        this.processing = false;
        this.pullCounter = metrics.getMeter("cojson").createCounter(`jazz.messagequeue.incoming.pulled`, {
          description: "Number of messages pulled from the queue",
          valueType: ValueType.INT,
          unit: "1"
        });
        this.pushCounter = metrics.getMeter("cojson").createCounter(`jazz.messagequeue.incoming.pushed`, {
          description: "Number of messages pushed to the queue",
          valueType: ValueType.INT,
          unit: "1"
        });
        this.pullCounter.add(0, {
          peerRole: "client"
        });
        this.pushCounter.add(0, {
          peerRole: "client"
        });
        this.pullCounter.add(0, {
          peerRole: "server"
        });
        this.pushCounter.add(0, {
          peerRole: "server"
        });
        this.queues = [];
        this.peerToQueue = /* @__PURE__ */ new WeakMap();
      }
      push(msg, peer) {
        const queue = this.peerToQueue.get(peer);
        if (!queue) {
          const newQueue = new LinkedList();
          this.peerToQueue.set(peer, newQueue);
          this.queues.push([newQueue, peer]);
          newQueue.push(msg);
        } else {
          queue.push(msg);
        }
        this.pushCounter.add(1, {
          peerRole: peer.role
        });
      }
      pull() {
        const entry = this.queues[this.currentQueue];
        if (!entry) {
          return void 0;
        }
        const [queue, peer] = entry;
        const msg = queue.shift();
        if (queue.isEmpty()) {
          this.queues.splice(this.currentQueue, 1);
          this.peerToQueue.delete(peer);
        } else {
          this.currentQueue++;
        }
        if (this.currentQueue >= this.queues.length) {
          this.currentQueue = 0;
        }
        if (msg) {
          this.pullCounter.add(1, {
            peerRole: peer.role
          });
          return { msg, peer };
        }
        return void 0;
      }
      async processQueue(callback) {
        this.processing = true;
        let entry;
        let lastTimer = performance.now();
        while (entry = this.pull()) {
          const { msg, peer } = entry;
          try {
            callback(msg, peer);
          } catch (err2) {
            logger.error("Error processing message", { err: err2 });
          }
          const currentTimer = performance.now();
          if (currentTimer - lastTimer > SYNC_SCHEDULER_CONFIG.INCOMING_MESSAGES_TIME_BUDGET) {
            await new Promise((resolve) => setTimeout(resolve, 0));
          }
        }
        this.processing = false;
      }
    }
    class PeerKnownStates {
      constructor() {
        this.coValues = /* @__PURE__ */ new Map();
        this.listeners = /* @__PURE__ */ new Set();
      }
      updateHeader(id2, header) {
        const knownState = this.coValues.get(id2) ?? emptyKnownState(id2);
        knownState.header = header;
        this.coValues.set(id2, knownState);
        this.triggerUpdate(id2);
      }
      combineWith(id2, value) {
        const knownState = this.coValues.get(id2) ?? emptyKnownState(id2);
        this.coValues.set(id2, combinedKnownStates(knownState, value));
        this.triggerUpdate(id2);
      }
      updateSessionCounter(id2, sessionId, value) {
        const knownState = this.coValues.get(id2) ?? emptyKnownState(id2);
        const currentValue = knownState.sessions[sessionId] || 0;
        knownState.sessions[sessionId] = Math.max(currentValue, value);
        this.coValues.set(id2, knownState);
        this.triggerUpdate(id2);
      }
      set(id2, knownState) {
        this.coValues.set(id2, knownState === "empty" ? emptyKnownState(id2) : knownState);
        this.triggerUpdate(id2);
      }
      get(id2) {
        return this.coValues.get(id2);
      }
      has(id2) {
        return this.coValues.has(id2);
      }
      clone() {
        const clone2 = new PeerKnownStates();
        clone2.coValues = new Map(this.coValues);
        return clone2;
      }
      triggerUpdate(id2) {
        this.trigger(id2, this.coValues.get(id2) ?? emptyKnownState(id2));
      }
      trigger(id2, knownState) {
        for (const listener of this.listeners) {
          listener(id2, knownState);
        }
      }
      subscribe(listener) {
        this.listeners.add(listener);
        return () => {
          this.listeners.delete(listener);
        };
      }
    }
    class PeerState {
      constructor(peer, knownStates) {
        this.peer = peer;
        this.toldKnownState = /* @__PURE__ */ new Set();
        this.loadRequestSent = /* @__PURE__ */ new Set();
        this.closed = false;
        this.closeListeners = /* @__PURE__ */ new Set();
        this._knownStates = (knownStates == null ? void 0 : knownStates.clone()) ?? new PeerKnownStates();
        this._optimisticKnownStates = (knownStates == null ? void 0 : knownStates.clone()) ?? new PeerKnownStates();
      }
      get knownStates() {
        return this._knownStates;
      }
      get optimisticKnownStates() {
        return this._optimisticKnownStates;
      }
      trackLoadRequestSent(id2) {
        this.toldKnownState.add(id2);
        this.loadRequestSent.add(id2);
      }
      trackToldKnownState(id2) {
        this.toldKnownState.add(id2);
      }
      updateHeader(id2, header) {
        this._knownStates.updateHeader(id2, header);
        this._optimisticKnownStates.updateHeader(id2, header);
      }
      combineWith(id2, value) {
        this._knownStates.combineWith(id2, value);
        this._optimisticKnownStates.combineWith(id2, value);
      }
      combineOptimisticWith(id2, value) {
        this._optimisticKnownStates.combineWith(id2, value);
      }
      updateSessionCounter(id2, sessionId, value) {
        this._knownStates.updateSessionCounter(id2, sessionId, value);
        this._optimisticKnownStates.updateSessionCounter(id2, sessionId, value);
      }
      setKnownState(id2, knownState) {
        this._knownStates.set(id2, knownState);
        this._optimisticKnownStates.set(id2, knownState);
      }
      setOptimisticKnownState(id2, knownState) {
        this._optimisticKnownStates.set(id2, knownState);
      }
      get id() {
        return this.peer.id;
      }
      get role() {
        return this.peer.role;
      }
      get priority() {
        return this.peer.priority;
      }
      get incoming() {
        return this.peer.incoming;
      }
      pushOutgoingMessage(msg) {
        this.peer.outgoing.push(msg);
      }
      addCloseListener(listener) {
        if (this.closed) {
          listener();
          return () => {
          };
        }
        this.closeListeners.add(listener);
        return () => {
          this.closeListeners.delete(listener);
        };
      }
      emitClose() {
        for (const listener of this.closeListeners) {
          listener();
        }
        this.closeListeners.clear();
      }
      gracefulShutdown() {
        if (this.closed) {
          return;
        }
        logger.debug("Gracefully closing", {
          peerId: this.id,
          peerRole: this.role
        });
        this.closed = true;
        this.peer.outgoing.push("Disconnected");
        this.peer.outgoing.close();
        this.peer.incoming.close();
        this.emitClose();
      }
    }
    class SyncStateManager {
      constructor(syncManager) {
        this.syncManager = syncManager;
        this.listeners = /* @__PURE__ */ new Set();
        this.listenersByPeers = /* @__PURE__ */ new Map();
      }
      subscribeToUpdates(listener) {
        this.listeners.add(listener);
        return () => {
          this.listeners.delete(listener);
        };
      }
      subscribeToPeerUpdates(peerId, listener) {
        const listeners2 = this.listenersByPeers.get(peerId) ?? /* @__PURE__ */ new Set();
        if (listeners2.size === 0) {
          this.listenersByPeers.set(peerId, listeners2);
        }
        listeners2.add(listener);
        return () => {
          listeners2.delete(listener);
        };
      }
      getCurrentSyncState(peerId, id2) {
        const syncState = {};
        const getIsUploaded2 = () => this.getIsCoValueFullyUploadedIntoPeer(peerId, id2);
        Object.defineProperties(syncState, {
          uploaded: {
            enumerable: true,
            get: getIsUploaded2
          }
        });
        return syncState;
      }
      triggerUpdate(peerId, id2) {
        const peer = this.syncManager.peers[peerId];
        if (!peer) {
          return;
        }
        const peerListeners = this.listenersByPeers.get(peer.id);
        if (!(peerListeners == null ? void 0 : peerListeners.size) && !this.listeners.size) {
          return;
        }
        const knownState = peer.knownStates.get(id2) ?? emptyKnownState(id2);
        const syncState = this.getCurrentSyncState(peerId, id2);
        for (const listener of this.listeners) {
          listener(peerId, knownState, syncState);
        }
        if (!peerListeners)
          return;
        for (const listener of peerListeners) {
          listener(knownState, syncState);
        }
      }
      getKnownStateSessions(peerId, id2) {
        var _a;
        const peer = this.syncManager.peers[peerId];
        if (!peer) {
          return void 0;
        }
        const peerSessions = (_a = peer.knownStates.get(id2)) == null ? void 0 : _a.sessions;
        if (!peerSessions) {
          return void 0;
        }
        const entry = this.syncManager.local.getCoValue(id2);
        if (!entry.isAvailable()) {
          return void 0;
        }
        const coValueSessions = entry.knownState().sessions;
        return {
          peer: peerSessions,
          coValue: coValueSessions
        };
      }
      getIsCoValueFullyUploadedIntoPeer(peerId, id2) {
        const sessions = this.getKnownStateSessions(peerId, id2);
        if (!sessions) {
          return false;
        }
        return getIsUploaded(sessions.coValue, sessions.peer);
      }
    }
    function getIsUploaded(from, to) {
      for (const sessionId of Object.keys(from)) {
        if (from[sessionId] !== to[sessionId]) {
          return false;
        }
      }
      return true;
    }
    function getDependedOnCoValuesFromRawData(id2, header, sessions, transactions) {
      const deps = /* @__PURE__ */ new Set();
      for (const session of sessions) {
        const accountId = accountOrAgentIDfromSessionID(session);
        if (isAccountID$1(accountId) && accountId !== id2) {
          deps.add(accountId);
        }
      }
      if (header.ruleset.type === "group") {
        for (const txs of transactions) {
          for (const tx of txs) {
            if (tx.privacy !== "trusting")
              continue;
            const changes = safeParseChanges(tx.changes);
            for (const change of changes) {
              if (change && typeof change === "object" && "op" in change && change.op === "set" && "key" in change && change.key) {
                const key = getGroupDependentKey(change.key);
                if (key && key !== id2) {
                  deps.add(key);
                }
              }
            }
          }
        }
      }
      if (header.ruleset.type === "ownedByGroup") {
        deps.add(header.ruleset.group);
      }
      return deps;
    }
    function safeParseChanges(value) {
      try {
        return parseJSON(value);
      } catch (e) {
        return [];
      }
    }
    function emptyKnownState(id2) {
      return {
        id: id2,
        header: false,
        sessions: {}
      };
    }
    function combinedKnownStates(stateA, stateB) {
      const sessionStates = {};
      const allSessions = /* @__PURE__ */ new Set([
        ...Object.keys(stateA.sessions),
        ...Object.keys(stateB.sessions)
      ]);
      for (const sessionID of allSessions) {
        const stateAValue = stateA.sessions[sessionID];
        const stateBValue = stateB.sessions[sessionID];
        sessionStates[sessionID] = Math.max(stateAValue || 0, stateBValue || 0);
      }
      return {
        id: stateA.id,
        header: stateA.header || stateB.header,
        sessions: sessionStates
      };
    }
    class SyncManager {
      constructor(local) {
        this.peers = {};
        this.peersCounter = metrics.getMeter("cojson").createUpDownCounter("jazz.peers", {
          description: "Amount of connected peers",
          valueType: ValueType.INT,
          unit: "peer"
        });
        this.messagesQueue = new IncomingMessagesQueue();
        this.requestedSyncs = /* @__PURE__ */ new Set();
        this.local = local;
        this.syncState = new SyncStateManager(this);
        this.transactionsSizeHistogram = metrics.getMeter("cojson").createHistogram("jazz.transactions.size", {
          description: "The size of transactions in a covalue",
          unit: "bytes",
          valueType: ValueType.INT
        });
      }
      peersInPriorityOrder() {
        return Object.values(this.peers).sort((a, b) => {
          const aPriority = a.priority || 0;
          const bPriority = b.priority || 0;
          return bPriority - aPriority;
        });
      }
      getPeers() {
        return Object.values(this.peers);
      }
      getServerPeers(excludePeerId) {
        return this.getPeers().filter((peer) => peer.role === "server" && peer.id !== excludePeerId && !peer.closed);
      }
      handleSyncMessage(msg, peer) {
        if (msg.id === void 0 || msg.id === null) {
          logger.warn("Received sync message with undefined id", {
            msg
          });
          return;
        } else if (!msg.id.startsWith("co_z")) {
          logger.warn("Received sync message with invalid id", {
            msg
          });
          return;
        } else if (this.local.getCoValue(msg.id).isErroredInPeer(peer.id)) {
          logger.warn(`Skipping message ${msg.action} on errored coValue ${msg.id} from peer ${peer.id}`);
          return;
        }
        switch (msg.action) {
          case "load":
            return this.handleLoad(msg, peer);
          case "known":
            if (msg.isCorrection) {
              return this.handleCorrection(msg, peer);
            } else {
              return this.handleKnownState(msg, peer);
            }
          case "content":
            return this.handleNewContent(msg, peer);
          case "done":
            return;
          default:
            throw new Error(`Unknown message type ${msg.action}`);
        }
      }
      sendNewContentIncludingDependencies(id2, peer, seen = /* @__PURE__ */ new Set()) {
        if (seen.has(id2)) {
          return;
        }
        seen.add(id2);
        const coValue = this.local.getCoValue(id2);
        if (!coValue.isAvailable()) {
          return;
        }
        for (const dependency of coValue.getDependedOnCoValues()) {
          this.sendNewContentIncludingDependencies(dependency, peer, seen);
        }
        const newContentPieces = coValue.verified.newContentSince(peer.optimisticKnownStates.get(id2));
        if (newContentPieces) {
          for (const piece of newContentPieces) {
            this.trySendToPeer(peer, piece);
          }
          peer.combineOptimisticWith(id2, coValue.knownState());
        } else if (!peer.toldKnownState.has(id2)) {
          this.trySendToPeer(peer, {
            action: "known",
            ...coValue.knownStateWithStreaming()
          });
        }
        peer.trackToldKnownState(id2);
      }
      startPeerReconciliation(peer) {
        const coValuesOrderedByDependency = [];
        const gathered = /* @__PURE__ */ new Set();
        const buildOrderedCoValueList = (coValue) => {
          if (gathered.has(coValue.id)) {
            return;
          }
          gathered.add(coValue.id);
          for (const id2 of coValue.getDependedOnCoValues()) {
            const coValue2 = this.local.getCoValue(id2);
            if (coValue2.isAvailable()) {
              buildOrderedCoValueList(coValue2);
            }
          }
          coValuesOrderedByDependency.push(coValue);
        };
        for (const coValue of this.local.allCoValues()) {
          if (!coValue.isAvailable()) {
            if (!peer.loadRequestSent.has(coValue.id)) {
              peer.trackLoadRequestSent(coValue.id);
              this.trySendToPeer(peer, {
                action: "load",
                header: false,
                id: coValue.id,
                sessions: {}
              });
            }
          } else {
            buildOrderedCoValueList(coValue);
          }
          if (!peer.optimisticKnownStates.has(coValue.id)) {
            peer.setOptimisticKnownState(coValue.id, "empty");
          }
        }
        for (const coValue of coValuesOrderedByDependency) {
          peer.trackLoadRequestSent(coValue.id);
          this.trySendToPeer(peer, {
            action: "load",
            ...coValue.knownState()
          });
        }
      }
      pushMessage(incoming, peer) {
        this.messagesQueue.push(incoming, peer);
        if (this.messagesQueue.processing) {
          return;
        }
        this.messagesQueue.processQueue((msg, peer2) => {
          this.handleSyncMessage(msg, peer2);
        });
      }
      addPeer(peer) {
        const prevPeer = this.peers[peer.id];
        if (prevPeer && !prevPeer.closed) {
          prevPeer.gracefulShutdown();
        }
        const peerState = new PeerState(peer, prevPeer == null ? void 0 : prevPeer.knownStates);
        this.peers[peer.id] = peerState;
        this.peersCounter.add(1, { role: peer.role });
        const unsubscribeFromKnownStatesUpdates = peerState.knownStates.subscribe((id2) => {
          this.syncState.triggerUpdate(peer.id, id2);
        });
        if (peerState.role === "server") {
          void this.startPeerReconciliation(peerState);
        }
        peerState.incoming.onMessage((msg) => {
          if (msg === "Disconnected") {
            peerState.gracefulShutdown();
            return;
          }
          this.pushMessage(msg, peerState);
        });
        peerState.addCloseListener(() => {
          unsubscribeFromKnownStatesUpdates();
          this.peersCounter.add(-1, { role: peer.role });
          if (peer.deletePeerStateOnClose && this.peers[peer.id] === peerState) {
            delete this.peers[peer.id];
          }
        });
      }
      trySendToPeer(peer, msg) {
        return peer.pushOutgoingMessage(msg);
      }
      /**
       * Handles the load message from a peer.
       *
       * Differences with the known state message:
       * - The load message triggers the CoValue loading process on the other peer
       * - The peer known state is stored as-is instead of being merged
       * - The load message always replies with a known state message
       */
      handleLoad(msg, peer) {
        peer.setKnownState(msg.id, knownStateIn(msg));
        const coValue = this.local.getCoValue(msg.id);
        if (coValue.isAvailable()) {
          this.sendNewContentIncludingDependencies(msg.id, peer);
          return;
        }
        const peers = this.getServerPeers(peer.id);
        coValue.load(peers);
        const handleLoadResult = () => {
          if (coValue.isAvailable()) {
            this.sendNewContentIncludingDependencies(msg.id, peer);
            return;
          }
          peer.trackToldKnownState(msg.id);
          this.trySendToPeer(peer, {
            action: "known",
            id: msg.id,
            header: false,
            sessions: {}
          });
        };
        if (peers.length > 0 || this.local.storage) {
          coValue.waitForAvailableOrUnavailable().then(handleLoadResult);
        } else {
          handleLoadResult();
        }
      }
      handleKnownState(msg, peer) {
        var _a;
        const coValue = this.local.getCoValue(msg.id);
        peer.combineWith(msg.id, knownStateIn(msg));
        const availableOnPeer = (_a = peer.optimisticKnownStates.get(msg.id)) == null ? void 0 : _a.header;
        if (!availableOnPeer) {
          coValue.markNotFoundInPeer(peer.id);
        }
        if (coValue.isAvailable()) {
          this.sendNewContentIncludingDependencies(msg.id, peer);
        }
      }
      recordTransactionsSize(newTransactions, source) {
        for (const tx of newTransactions) {
          const txLength = tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length;
          this.transactionsSizeHistogram.record(txLength, {
            source
          });
        }
      }
      handleNewContent(msg, from) {
        var _a, _b;
        const coValue = this.local.getCoValue(msg.id);
        const peer = from === "storage" ? void 0 : from;
        if (!coValue.hasVerifiedContent()) {
          if (!msg.header) {
            if (peer) {
              this.trySendToPeer(peer, {
                action: "known",
                isCorrection: true,
                id: msg.id,
                header: false,
                sessions: {}
              });
            } else {
              logger.error("Received new content with no header on a missing CoValue", {
                id: msg.id
              });
            }
            return;
          }
          const sessionIDs = Object.keys(msg.new);
          const transactions = Object.values(msg.new).map((content) => content.newTransactions);
          for (const dependency of getDependedOnCoValuesFromRawData(msg.id, msg.header, sessionIDs, transactions)) {
            const dependencyCoValue = this.local.getCoValue(dependency);
            if (!dependencyCoValue.hasVerifiedContent()) {
              coValue.markMissingDependency(dependency);
              const peers = this.getServerPeers();
              if ((peer == null ? void 0 : peer.role) === "client") {
                peers.push(peer);
              }
              dependencyCoValue.load(peers);
            } else if (!dependencyCoValue.isAvailable()) {
              coValue.markMissingDependency(dependency);
            }
          }
          peer == null ? void 0 : peer.updateHeader(msg.id, true);
          coValue.provideHeader(msg.header, (peer == null ? void 0 : peer.id) ?? "storage", msg.expectContentUntil);
          if (msg.expectContentUntil) {
            peer == null ? void 0 : peer.combineWith(msg.id, {
              id: msg.id,
              header: true,
              sessions: msg.expectContentUntil
            });
          }
        }
        if (!coValue.hasVerifiedContent()) {
          throw new Error("Unreachable: CoValue should always have a verified state at this point");
        }
        let invalidStateAssumed = false;
        for (const [sessionID, newContentForSession] of Object.entries(msg.new)) {
          const ourKnownTxIdx = (_a = coValue.verified.sessions.get(sessionID)) == null ? void 0 : _a.transactions.length;
          const theirFirstNewTxIdx = newContentForSession.after;
          if ((ourKnownTxIdx || 0) < theirFirstNewTxIdx) {
            invalidStateAssumed = true;
            continue;
          }
          const alreadyKnownOffset = ourKnownTxIdx ? ourKnownTxIdx - theirFirstNewTxIdx : 0;
          const newTransactions = newContentForSession.newTransactions.slice(alreadyKnownOffset);
          if (newTransactions.length === 0) {
            continue;
          }
          const accountId = accountOrAgentIDfromSessionID(sessionID);
          if (isAccountID$1(accountId)) {
            const account = this.local.getCoValue(accountId);
            if (!account.isAvailable()) {
              if (!coValue.missingDependencies.has(accountId)) {
                const peers = this.getServerPeers();
                if ((peer == null ? void 0 : peer.role) === "client") {
                  peers.push(peer);
                }
                account.load(peers);
              }
              void account.waitForAvailable().then(() => {
                this.handleNewContent({
                  action: "content",
                  id: coValue.id,
                  new: {
                    [sessionID]: newContentForSession
                  },
                  priority: msg.priority
                }, from);
              });
              continue;
            }
          }
          const result = coValue.tryAddTransactions(sessionID, newTransactions, void 0, newContentForSession.lastSignature, "immediate");
          if (result.isErr()) {
            if (peer) {
              logger.error("Failed to add transactions", {
                peerId: peer.id,
                peerRole: peer.role,
                id: msg.id,
                err: result.error
              });
              coValue.markErrored(peer.id, result.error);
            } else {
              logger.error("Failed to add transactions from storage", {
                id: msg.id,
                err: result.error
              });
            }
            continue;
          }
          this.recordTransactionsSize(newTransactions, (peer == null ? void 0 : peer.role) ?? "storage");
          peer == null ? void 0 : peer.updateSessionCounter(msg.id, sessionID, newContentForSession.after + newContentForSession.newTransactions.length);
        }
        if (invalidStateAssumed) {
          if (peer) {
            this.trySendToPeer(peer, {
              action: "known",
              isCorrection: true,
              ...coValue.knownState()
            });
            peer.trackToldKnownState(msg.id);
          } else {
            logger.error("Invalid state assumed when handling new content from storage", {
              id: msg.id
            });
          }
        } else if (peer) {
          this.trySendToPeer(peer, {
            action: "known",
            ...coValue.knownState()
          });
          peer.trackToldKnownState(msg.id);
        }
        const syncedPeers = [];
        if (from !== "storage") {
          this.storeCoValue(coValue, [msg]);
        }
        for (const peer2 of this.peersInPriorityOrder()) {
          if (peer2.closed)
            continue;
          if (coValue.isErroredInPeer(peer2.id))
            continue;
          if (peer2.optimisticKnownStates.has(coValue.id)) {
            this.sendNewContentIncludingDependencies(coValue.id, peer2);
            syncedPeers.push(peer2);
          } else if (peer2.role === "server" && !peer2.loadRequestSent.has(coValue.id)) {
            const state = (_b = coValue.getStateForPeer(peer2.id)) == null ? void 0 : _b.type;
            if (state === "unknown" || state === void 0) {
              this.trySendToPeer(peer2, {
                action: "load",
                ...coValue.knownStateWithStreaming()
              });
              peer2.trackLoadRequestSent(coValue.id);
              syncedPeers.push(peer2);
            }
          }
        }
        for (const peer2 of syncedPeers) {
          this.syncState.triggerUpdate(peer2.id, coValue.id);
        }
      }
      handleCorrection(msg, peer) {
        peer.setKnownState(msg.id, knownStateIn(msg));
        return this.sendNewContentIncludingDependencies(msg.id, peer);
      }
      requestCoValueSync(coValue) {
        if (this.requestedSyncs.has(coValue.id)) {
          return;
        }
        queueMicrotask(() => {
          if (this.requestedSyncs.has(coValue.id)) {
            this.syncCoValue(coValue);
          }
        });
        this.requestedSyncs.add(coValue.id);
      }
      storeCoValue(coValue, data2) {
        const storage = this.local.storage;
        if (!storage || !data2)
          return;
        storage.store(data2, (correction) => {
          if (!coValue.hasVerifiedContent())
            return;
          const newContentPieces = coValue.verified.newContentSince(correction);
          if (!newContentPieces)
            return;
          storage.store(newContentPieces, (response) => {
            logger.error("Correction requested by storage after sending a correction content", {
              response,
              knownState: coValue.knownState()
            });
          });
        });
      }
      syncCoValue(coValue) {
        this.requestedSyncs.delete(coValue.id);
        if (this.local.storage && coValue.hasVerifiedContent()) {
          const knownState = this.local.storage.getKnownState(coValue.id);
          const newContentPieces = coValue.verified.newContentSince(knownState);
          this.storeCoValue(coValue, newContentPieces);
        }
        for (const peer of this.peersInPriorityOrder()) {
          if (peer.closed)
            continue;
          if (coValue.isErroredInPeer(peer.id))
            continue;
          if (peer.role === "client" && !peer.optimisticKnownStates.has(coValue.id)) {
            continue;
          }
          this.sendNewContentIncludingDependencies(coValue.id, peer);
        }
        for (const peer of this.getPeers()) {
          this.syncState.triggerUpdate(peer.id, coValue.id);
        }
      }
      waitForSyncWithPeer(peerId, id2, timeout) {
        const { syncState } = this;
        const currentSyncState = syncState.getCurrentSyncState(peerId, id2);
        const isTheConditionAlreadyMet = currentSyncState.uploaded;
        if (isTheConditionAlreadyMet) {
          return;
        }
        const peerState = this.peers[peerId];
        if (!peerState || peerState.closed) {
          return;
        }
        if (peerState.role === "client" && !peerState.optimisticKnownStates.has(id2)) {
          return;
        }
        return new Promise((resolve, reject) => {
          const unsubscribe = this.syncState.subscribeToPeerUpdates(peerId, (knownState, syncState2) => {
            if (syncState2.uploaded && knownState.id === id2) {
              resolve(true);
              unsubscribe == null ? void 0 : unsubscribe();
              clearTimeout(timeoutId);
            }
          });
          const timeoutId = setTimeout(() => {
            reject(new Error(`Timeout waiting for sync on ${peerId}/${id2}`));
            unsubscribe == null ? void 0 : unsubscribe();
          }, timeout);
        });
      }
      waitForStorageSync(id2) {
        var _a;
        return (_a = this.local.storage) == null ? void 0 : _a.waitForSync(id2, this.local.getCoValue(id2));
      }
      waitForSync(id2, timeout = 3e4) {
        const peers = this.getPeers();
        return Promise.all(peers.map((peer) => this.waitForSyncWithPeer(peer.id, id2, timeout)).concat(this.waitForStorageSync(id2)));
      }
      waitForAllCoValuesSync(timeout = 6e4) {
        const coValues = this.local.allCoValues();
        const validCoValues = Array.from(coValues).filter((coValue) => coValue.loadingState === "available" || coValue.loadingState === "loading");
        return Promise.all(validCoValues.map((coValue) => this.waitForSync(coValue.id, timeout)));
      }
      gracefulShutdown() {
        for (const peer of Object.values(this.peers)) {
          peer.gracefulShutdown();
        }
      }
    }
    function knownStateIn(msg) {
      return {
        id: msg.id,
        header: msg.header,
        sessions: msg.sessions
      };
    }
    class VerifiedState {
      constructor(id2, crypto2, header, sessions, streamingKnownState) {
        this.id = id2;
        this.crypto = crypto2;
        this.header = header;
        this.sessions = sessions;
        this.streamingKnownState = streamingKnownState ? { ...streamingKnownState } : void 0;
      }
      clone() {
        var _a;
        const clonedSessions = /* @__PURE__ */ new Map();
        for (let [sessionID, sessionLog] of this.sessions) {
          clonedSessions.set(sessionID, {
            lastSignature: sessionLog.lastSignature,
            streamingHash: (_a = sessionLog.streamingHash) == null ? void 0 : _a.clone(),
            signatureAfter: { ...sessionLog.signatureAfter },
            transactions: sessionLog.transactions.slice()
          });
        }
        return new VerifiedState(this.id, this.crypto, this.header, clonedSessions, this.streamingKnownState);
      }
      tryAddTransactions(sessionID, signerID, newTransactions, givenExpectedNewHash, newSignature, skipVerify = false, givenNewStreamingHash) {
        if (skipVerify === true) {
          this.doAddTransactions(sessionID, newTransactions, newSignature, givenNewStreamingHash);
        } else {
          const { expectedNewHash, newStreamingHash } = this.expectedNewHashAfter(sessionID, newTransactions);
          if (givenExpectedNewHash && givenExpectedNewHash !== expectedNewHash) {
            return err({
              type: "InvalidHash",
              id: this.id,
              expectedNewHash,
              givenExpectedNewHash
            });
          }
          if (!this.crypto.verify(newSignature, expectedNewHash, signerID)) {
            return err({
              type: "InvalidSignature",
              id: this.id,
              newSignature,
              sessionID,
              signerID
            });
          }
          this.doAddTransactions(sessionID, newTransactions, newSignature, newStreamingHash);
        }
        return ok(true);
      }
      doAddTransactions(sessionID, newTransactions, newSignature, newStreamingHash) {
        const sessionLog = this.sessions.get(sessionID);
        const transactions = (sessionLog == null ? void 0 : sessionLog.transactions) ?? [];
        for (const tx of newTransactions) {
          transactions.push(tx);
        }
        const signatureAfter = (sessionLog == null ? void 0 : sessionLog.signatureAfter) ?? {};
        const lastInbetweenSignatureIdx = Object.keys(signatureAfter).reduce((max, idx) => parseInt(idx) > max ? parseInt(idx) : max, -1);
        const sizeOfTxsSinceLastInbetweenSignature = transactions.slice(lastInbetweenSignatureIdx + 1).reduce((sum, tx) => sum + (tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length), 0);
        if (sizeOfTxsSinceLastInbetweenSignature > MAX_RECOMMENDED_TX_SIZE) {
          signatureAfter[transactions.length - 1] = newSignature;
        }
        this.sessions.set(sessionID, {
          transactions,
          streamingHash: newStreamingHash,
          lastSignature: newSignature,
          signatureAfter
        });
        this._cachedNewContentSinceEmpty = void 0;
        this._cachedKnownState = void 0;
      }
      expectedNewHashAfter(sessionID, newTransactions) {
        const sessionLog = this.sessions.get(sessionID);
        if (!(sessionLog == null ? void 0 : sessionLog.streamingHash)) {
          const streamingHash2 = new StreamingHash(this.crypto);
          const oldTransactions = (sessionLog == null ? void 0 : sessionLog.transactions) ?? [];
          for (const transaction of oldTransactions) {
            streamingHash2.update(transaction);
          }
          for (const transaction of newTransactions) {
            streamingHash2.update(transaction);
          }
          return {
            expectedNewHash: streamingHash2.digest(),
            newStreamingHash: streamingHash2
          };
        }
        const streamingHash = sessionLog.streamingHash.clone();
        for (const transaction of newTransactions) {
          streamingHash.update(transaction);
        }
        return {
          expectedNewHash: streamingHash.digest(),
          newStreamingHash: streamingHash
        };
      }
      newContentSince(knownState) {
        const isKnownStateEmpty = !(knownState == null ? void 0 : knownState.header) && !(knownState == null ? void 0 : knownState.sessions);
        if (isKnownStateEmpty && this._cachedNewContentSinceEmpty) {
          return this._cachedNewContentSinceEmpty;
        }
        let currentPiece = {
          action: "content",
          id: this.id,
          header: (knownState == null ? void 0 : knownState.header) ? void 0 : this.header,
          priority: getPriorityFromHeader(this.header),
          new: {}
        };
        const pieces = [currentPiece];
        const sentState = {};
        let pieceSize = 0;
        let sessionsTodoAgain = "first";
        while (sessionsTodoAgain === "first" || (sessionsTodoAgain == null ? void 0 : sessionsTodoAgain.size) || 0 > 0) {
          if (sessionsTodoAgain === "first") {
            sessionsTodoAgain = void 0;
          }
          const sessionsTodo = sessionsTodoAgain ?? this.sessions.keys();
          for (const sessionIDKey of sessionsTodo) {
            const sessionID = sessionIDKey;
            const log = this.sessions.get(sessionID);
            const knownStateForSessionID = knownState == null ? void 0 : knownState.sessions[sessionID];
            const sentStateForSessionID = sentState[sessionID];
            const nextKnownSignatureIdx = getNextKnownSignatureIdx(log, knownStateForSessionID, sentStateForSessionID);
            const firstNewTxIdx = sentStateForSessionID ?? knownStateForSessionID ?? 0;
            const afterLastNewTxIdx = nextKnownSignatureIdx === void 0 ? log.transactions.length : nextKnownSignatureIdx + 1;
            const nNewTx = Math.max(0, afterLastNewTxIdx - firstNewTxIdx);
            if (nNewTx === 0) {
              sessionsTodoAgain == null ? void 0 : sessionsTodoAgain.delete(sessionID);
              continue;
            }
            if (afterLastNewTxIdx < log.transactions.length) {
              if (!sessionsTodoAgain) {
                sessionsTodoAgain = /* @__PURE__ */ new Set();
              }
              sessionsTodoAgain.add(sessionID);
            }
            const oldPieceSize = pieceSize;
            for (let txIdx = firstNewTxIdx; txIdx < afterLastNewTxIdx; txIdx++) {
              const tx = log.transactions[txIdx];
              pieceSize += tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length;
            }
            if (pieceSize >= MAX_RECOMMENDED_TX_SIZE) {
              if (!currentPiece.expectContentUntil && pieces.length === 1) {
                currentPiece.expectContentUntil = this.knownStateWithStreaming().sessions;
              }
              currentPiece = {
                action: "content",
                id: this.id,
                header: void 0,
                new: {},
                priority: getPriorityFromHeader(this.header)
              };
              pieces.push(currentPiece);
              pieceSize = pieceSize - oldPieceSize;
            }
            let sessionEntry = currentPiece.new[sessionID];
            if (!sessionEntry) {
              sessionEntry = {
                after: sentStateForSessionID ?? knownStateForSessionID ?? 0,
                newTransactions: [],
                lastSignature: "WILL_BE_REPLACED"
              };
              currentPiece.new[sessionID] = sessionEntry;
            }
            for (let txIdx = firstNewTxIdx; txIdx < afterLastNewTxIdx; txIdx++) {
              const tx = log.transactions[txIdx];
              sessionEntry.newTransactions.push(tx);
            }
            sessionEntry.lastSignature = nextKnownSignatureIdx === void 0 ? log.lastSignature : log.signatureAfter[nextKnownSignatureIdx];
            sentState[sessionID] = (sentStateForSessionID ?? knownStateForSessionID ?? 0) + nNewTx;
          }
        }
        const piecesWithContent = pieces.filter((piece) => Object.keys(piece.new).length > 0 || piece.header);
        if (piecesWithContent.length === 0) {
          return void 0;
        }
        if (isKnownStateEmpty) {
          this._cachedNewContentSinceEmpty = piecesWithContent;
        }
        return piecesWithContent;
      }
      /**
       * Returns the known state considering the known state of the streaming source
       *
       * Used to correctly manage the content & subscriptions during the content streaming process
       */
      knownStateWithStreaming() {
        const knownState = this.knownState();
        if (this.streamingKnownState) {
          const newSessions = {};
          const entries = Object.entries(this.streamingKnownState);
          for (const [sessionID, txs] of entries) {
            newSessions[sessionID] = txs;
            if ((knownState.sessions[sessionID] ?? 0) < txs) {
              newSessions[sessionID] = txs;
            } else {
              newSessions[sessionID] = txs;
              delete this.streamingKnownState[sessionID];
            }
          }
          if (Object.keys(this.streamingKnownState).length === 0) {
            this.streamingKnownState = void 0;
            return knownState;
          } else {
            return {
              id: knownState.id,
              header: knownState.header,
              sessions: newSessions
            };
          }
        }
        return knownState;
      }
      isStreaming() {
        this.knownStateWithStreaming();
        return this.streamingKnownState !== void 0;
      }
      knownState() {
        if (this._cachedKnownState) {
          return this._cachedKnownState;
        } else {
          const knownState = this.knownStateUncached();
          this._cachedKnownState = knownState;
          return knownState;
        }
      }
      /** @internal */
      knownStateUncached() {
        const sessions = {};
        for (const [sessionID, sessionLog] of this.sessions.entries()) {
          sessions[sessionID] = sessionLog.transactions.length;
        }
        return {
          id: this.id,
          header: true,
          sessions
        };
      }
    }
    function getNextKnownSignatureIdx(log, knownStateForSessionID, sentStateForSessionID) {
      return Object.keys(log.signatureAfter).map(Number).sort((a, b) => a - b).find((idx) => idx >= (sentStateForSessionID ?? knownStateForSessionID ?? -1));
    }
    function idforHeader(header, crypto2) {
      const hash = crypto2.shortHash(header);
      return `co_z${hash.slice("shortHash_z".length)}`;
    }
    const readKeyCache = /* @__PURE__ */ new WeakMap();
    class CoValueCore {
      /** Holds the fundamental syncable content of a CoValue,
       * consisting of the header (verified by hash -> RawCoID)
       * and the sessions (verified by signature).
       *
       * It does not do any *validation* or *decryption* and as such doesn't
       * depend on other CoValues or the LocalNode.
       *
       * `CoValueCore.verified` may be null when a CoValue is requested to be
       * loaded but no content has been received from storage or peers yet.
       * In this case, it acts as a centralised entry to keep track of peer loading
       * state and to subscribe to its content when it does become available. */
      get verified() {
        return this._verified;
      }
      constructor(init, node) {
        this.peers = /* @__PURE__ */ new Map();
        this.listeners = /* @__PURE__ */ new Set();
        this._decryptionCache = {};
        this.missingDependencies = /* @__PURE__ */ new Set();
        this.deferredUpdates = 0;
        this.crypto = node.crypto;
        if ("header" in init) {
          this.id = idforHeader(init.header, node.crypto);
          this._verified = new VerifiedState(this.id, node.crypto, init.header, /* @__PURE__ */ new Map());
        } else {
          this.id = init.id;
          this._verified = null;
        }
        this.node = node;
        this.counter = metrics.getMeter("cojson").createUpDownCounter("jazz.covalues.loaded", {
          description: "The number of covalues in the system",
          unit: "covalue",
          valueType: ValueType.INT
        });
        this.updateCounter(null);
      }
      static fromID(id2, node) {
        return new CoValueCore({ id: id2 }, node);
      }
      static fromHeader(header, node) {
        return new CoValueCore({ header }, node);
      }
      get loadingState() {
        if (this.verified) {
          return "available";
        } else if (this.peers.size === 0) {
          return "unknown";
        }
        for (const peer of this.peers.values()) {
          if (peer.type === "pending") {
            return "loading";
          } else if (peer.type === "unknown") {
            return "unknown";
          }
        }
        return "unavailable";
      }
      isAvailable() {
        return this.hasVerifiedContent() && this.missingDependencies.size === 0;
      }
      hasVerifiedContent() {
        return !!this.verified;
      }
      isErroredInPeer(peerId) {
        var _a;
        return ((_a = this.peers.get(peerId)) == null ? void 0 : _a.type) === "errored";
      }
      waitForAvailableOrUnavailable() {
        return new Promise((resolve) => {
          const listener = (core) => {
            if (core.isAvailable() || core.loadingState === "unavailable") {
              resolve(core);
              this.listeners.delete(listener);
            }
          };
          this.listeners.add(listener);
          listener(this);
        });
      }
      waitForAvailable() {
        return new Promise((resolve) => {
          const listener = (core) => {
            if (core.isAvailable()) {
              resolve(core);
              this.listeners.delete(listener);
            }
          };
          this.listeners.add(listener);
          listener(this);
        });
      }
      getStateForPeer(peerId) {
        return this.peers.get(peerId);
      }
      updateCounter(previousState) {
        const newState = this.loadingState;
        if (previousState !== newState) {
          if (previousState) {
            this.counter.add(-1, { state: previousState });
          }
          this.counter.add(1, { state: newState });
        }
      }
      markNotFoundInPeer(peerId) {
        const previousState = this.loadingState;
        this.peers.set(peerId, { type: "unavailable" });
        this.updateCounter(previousState);
        this.notifyUpdate("immediate");
      }
      // Checks if the current CoValueCore is already a missing dependency of the given CoValueCore
      checkCircularDependencies(dependency) {
        const visited = /* @__PURE__ */ new Set();
        const stack = [dependency];
        while (stack.length > 0) {
          const current = stack.pop();
          if (!current) {
            return true;
          }
          visited.add(current.id);
          for (const dependency2 of current.missingDependencies) {
            if (dependency2 === this.id) {
              return false;
            }
            if (!visited.has(dependency2)) {
              stack.push(this.node.getCoValue(dependency2));
            }
          }
        }
        return true;
      }
      markMissingDependency(dependency) {
        const value = this.node.getCoValue(dependency);
        if (value.isAvailable()) {
          this.missingDependencies.delete(dependency);
        } else if (this.checkCircularDependencies(value)) {
          const unsubscribe = value.subscribe(() => {
            if (value.isAvailable()) {
              this.missingDependencies.delete(dependency);
              unsubscribe();
            }
            if (this.isAvailable()) {
              this.notifyUpdate("immediate");
            }
          });
          this.missingDependencies.add(dependency);
        }
      }
      provideHeader(header, fromPeerId, streamingKnownState) {
        var _a;
        const previousState = this.loadingState;
        if ((_a = this._verified) == null ? void 0 : _a.sessions.size) {
          throw new Error("CoValueCore: provideHeader called on coValue with verified sessions present!");
        }
        this._verified = new VerifiedState(this.id, this.node.crypto, header, /* @__PURE__ */ new Map(), streamingKnownState);
        this.peers.set(fromPeerId, { type: "available" });
        this.updateCounter(previousState);
        this.notifyUpdate("immediate");
      }
      internalMarkMagicallyAvailable(verified, { forceOverwrite = false } = {}) {
        const previousState = this.loadingState;
        this.internalShamefullyCloneVerifiedStateFrom(verified, {
          forceOverwrite
        });
        this.updateCounter(previousState);
        this.notifyUpdate("immediate");
      }
      markErrored(peerId, error2) {
        const previousState = this.loadingState;
        this.peers.set(peerId, { type: "errored", error: error2 });
        this.updateCounter(previousState);
        this.notifyUpdate("immediate");
      }
      markPending(peerId) {
        const previousState = this.loadingState;
        this.peers.set(peerId, { type: "pending" });
        this.updateCounter(previousState);
        this.notifyUpdate("immediate");
      }
      internalShamefullyCloneVerifiedStateFrom(state, { forceOverwrite = false } = {}) {
        var _a;
        if (!forceOverwrite && ((_a = this._verified) == null ? void 0 : _a.sessions.size)) {
          throw new Error("CoValueCore: internalShamefullyCloneVerifiedStateFrom called on coValue with verified sessions present!");
        }
        this._verified = state.clone();
        this._cachedContent = void 0;
        this._cachedDependentOn = void 0;
      }
      internalShamefullyResetCachedContent() {
        this._cachedContent = void 0;
        this._cachedDependentOn = void 0;
      }
      subscribeToGroupInvalidation() {
        if (!this.verified) {
          return;
        }
        if (this.groupInvalidationSubscription) {
          return;
        }
        const header = this.verified.header;
        if (header.ruleset.type == "ownedByGroup") {
          const groupId = header.ruleset.group;
          const entry = this.node.getCoValue(groupId);
          if (entry.isAvailable()) {
            this.groupInvalidationSubscription = entry.subscribe((_groupUpdate) => {
              this._cachedContent = void 0;
              this.notifyUpdate("immediate");
            }, false);
          } else {
            logger.error("CoValueCore: Owner group not available", {
              id: this.id,
              groupId
            });
          }
        }
      }
      contentInClonedNodeWithDifferentAccount(account) {
        return this.node.loadCoValueAsDifferentAgent(this.id, account.agentSecret, account.id).getCurrentContent();
      }
      knownStateWithStreaming() {
        if (this.isAvailable()) {
          return this.verified.knownStateWithStreaming();
        } else {
          return emptyKnownState(this.id);
        }
      }
      knownState() {
        if (this.isAvailable()) {
          return this.verified.knownState();
        } else {
          return emptyKnownState(this.id);
        }
      }
      get meta() {
        var _a;
        return ((_a = this.verified) == null ? void 0 : _a.header.meta) ?? null;
      }
      nextTransactionID() {
        var _a, _b;
        if (!this.verified) {
          throw new Error("CoValueCore: nextTransactionID called on coValue without verified state");
        }
        const sessionID = ((_a = this.verified.header.meta) == null ? void 0 : _a.type) === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
        return {
          sessionID,
          txIndex: ((_b = this.verified.sessions.get(sessionID)) == null ? void 0 : _b.transactions.length) || 0
        };
      }
      tryAddTransactions(sessionID, newTransactions, givenExpectedNewHash, newSignature, notifyMode, skipVerify = false, givenNewStreamingHash) {
        return this.node.resolveAccountAgent(accountOrAgentIDfromSessionID(sessionID), "Expected to know signer of transaction").andThen((agent) => {
          if (!this.verified) {
            return err({
              type: "TriedToAddTransactionsWithoutVerifiedState",
              id: this.id
            });
          }
          const signerID = this.crypto.getAgentSignerID(agent);
          const result = this.verified.tryAddTransactions(sessionID, signerID, newTransactions, givenExpectedNewHash, newSignature, skipVerify, givenNewStreamingHash);
          if (result.isOk()) {
            if (this._cachedContent && "processNewTransactions" in this._cachedContent && typeof this._cachedContent.processNewTransactions === "function") {
              this._cachedContent.processNewTransactions();
            } else {
              this._cachedContent = void 0;
            }
            this._cachedDependentOn = void 0;
            this.notifyUpdate(notifyMode);
          }
          return result;
        });
      }
      notifyUpdate(notifyMode) {
        if (this.listeners.size === 0) {
          return;
        }
        if (notifyMode === "immediate") {
          for (const listener of this.listeners) {
            try {
              listener(this, () => {
                this.listeners.delete(listener);
              });
            } catch (e) {
              logger.error("Error in listener for coValue " + this.id, { err: e });
            }
          }
        } else {
          if (!this.nextDeferredNotify) {
            this.nextDeferredNotify = new Promise((resolve) => {
              setTimeout(() => {
                this.nextDeferredNotify = void 0;
                this.deferredUpdates = 0;
                for (const listener of this.listeners) {
                  try {
                    listener(this, () => {
                      this.listeners.delete(listener);
                    });
                  } catch (e) {
                    logger.error("Error in listener for coValue " + this.id, {
                      err: e
                    });
                  }
                }
                resolve();
              }, 0);
            });
          }
          this.deferredUpdates++;
        }
      }
      subscribe(listener, immediateInvoke = true) {
        this.listeners.add(listener);
        if (immediateInvoke) {
          listener(this, () => {
            this.listeners.delete(listener);
          });
        }
        return () => {
          this.listeners.delete(listener);
        };
      }
      makeTransaction(changes, privacy) {
        var _a;
        if (!this.verified) {
          throw new Error("CoValueCore: makeTransaction called on coValue without verified state");
        }
        const madeAt = Date.now();
        let transaction;
        if (privacy === "private") {
          const { secret: keySecret, id: keyID } = this.getCurrentReadKey();
          if (!keySecret) {
            throw new Error("Can't make transaction without read key secret");
          }
          const encrypted = this.crypto.encryptForTransaction(changes, keySecret, {
            in: this.id,
            tx: this.nextTransactionID()
          });
          this._decryptionCache[encrypted] = changes;
          transaction = {
            privacy: "private",
            madeAt,
            keyUsed: keyID,
            encryptedChanges: encrypted
          };
        } else {
          transaction = {
            privacy: "trusting",
            madeAt,
            changes: stableStringify(changes)
          };
        }
        const sessionID = ((_a = this.verified.header.meta) == null ? void 0 : _a.type) === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID;
        const { expectedNewHash, newStreamingHash } = this.verified.expectedNewHashAfter(sessionID, [transaction]);
        const signature = this.crypto.sign(this.node.getCurrentAgent().currentSignerSecret(), expectedNewHash);
        const success2 = this.tryAddTransactions(sessionID, [transaction], expectedNewHash, signature, "immediate", true, newStreamingHash)._unsafeUnwrap({ withStackTrace: true });
        if (success2) {
          this.node.syncManager.recordTransactionsSize([transaction], "local");
          void this.node.syncManager.requestCoValueSync(this);
        }
        return success2;
      }
      getCurrentContent(options) {
        if (!this.verified) {
          throw new Error("CoValueCore: getCurrentContent called on coValue without verified state");
        }
        if (!(options == null ? void 0 : options.ignorePrivateTransactions) && this._cachedContent) {
          return this._cachedContent;
        }
        this.subscribeToGroupInvalidation();
        const newContent = coreToCoValue(this, options);
        if (!(options == null ? void 0 : options.ignorePrivateTransactions)) {
          this._cachedContent = newContent;
        }
        return newContent;
      }
      getValidTransactions(options) {
        var _a;
        const validTransactions = determineValidTransactions(this, options == null ? void 0 : options.knownTransactions);
        const allTransactions = [];
        for (const { txID, tx } of validTransactions) {
          if (((_a = options == null ? void 0 : options.knownTransactions) == null ? void 0 : _a[txID.sessionID]) >= txID.txIndex) {
            continue;
          }
          if (tx.privacy === "trusting") {
            try {
              allTransactions.push({
                txID,
                madeAt: tx.madeAt,
                changes: parseJSON(tx.changes)
              });
            } catch (e) {
              logger.error("Failed to parse trusting transaction on " + this.id, {
                err: e,
                txID,
                changes: tx.changes.slice(0, 50)
              });
            }
            continue;
          }
          if (options == null ? void 0 : options.ignorePrivateTransactions) {
            continue;
          }
          const readKey = this.getReadKey(tx.keyUsed);
          if (!readKey) {
            continue;
          }
          let decryptedChanges = this._decryptionCache[tx.encryptedChanges];
          if (!decryptedChanges) {
            const decryptedString = this.crypto.decryptRawForTransaction(tx.encryptedChanges, readKey, {
              in: this.id,
              tx: txID
            });
            try {
              decryptedChanges = decryptedString && parseJSON(decryptedString);
            } catch (e) {
              logger.error("Failed to parse private transaction on " + this.id, {
                err: e,
                txID,
                changes: decryptedString == null ? void 0 : decryptedString.slice(0, 50)
              });
              continue;
            }
            this._decryptionCache[tx.encryptedChanges] = decryptedChanges;
          }
          if (!decryptedChanges) {
            logger.error("Failed to decrypt transaction despite having key", {
              err: new Error("Failed to decrypt transaction despite having key")
            });
            continue;
          }
          allTransactions.push({
            txID,
            madeAt: tx.madeAt,
            changes: decryptedChanges
          });
        }
        return allTransactions;
      }
      getValidSortedTransactions(options) {
        const allTransactions = this.getValidTransactions(options);
        allTransactions.sort(this.compareTransactions);
        return allTransactions;
      }
      compareTransactions(a, b) {
        if (a.madeAt !== b.madeAt) {
          return a.madeAt - b.madeAt;
        }
        if (a.txID.sessionID === b.txID.sessionID) {
          return a.txID.txIndex - b.txID.txIndex;
        }
        return 0;
      }
      getCurrentReadKey() {
        if (!this.verified) {
          throw new Error("CoValueCore: getCurrentReadKey called on coValue without verified state");
        }
        if (this.verified.header.ruleset.type === "group") {
          const content = expectGroup(this.getCurrentContent());
          const currentKeyId = content.getCurrentReadKeyId();
          if (!currentKeyId) {
            throw new Error("No readKey set");
          }
          const secret = this.getReadKey(currentKeyId);
          return {
            secret,
            id: currentKeyId
          };
        } else if (this.verified.header.ruleset.type === "ownedByGroup") {
          return this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentReadKey();
        } else {
          throw new Error("Only groups or values owned by groups have read secrets");
        }
      }
      getReadKey(keyID) {
        var _a;
        let key = (_a = readKeyCache.get(this)) == null ? void 0 : _a[keyID];
        if (!key) {
          key = this.getUncachedReadKey(keyID);
          if (key) {
            let cache = readKeyCache.get(this);
            if (!cache) {
              cache = {};
              readKeyCache.set(this, cache);
            }
            cache[keyID] = key;
          }
        }
        return key;
      }
      getUncachedReadKey(keyID) {
        if (!this.verified) {
          throw new Error("CoValueCore: getUncachedReadKey called on coValue without verified state");
        }
        if (this.verified.header.ruleset.type === "group") {
          const content = expectGroup(this.getCurrentContent({ ignorePrivateTransactions: true }));
          const keyForEveryone = content.get(`${keyID}_for_everyone`);
          if (keyForEveryone) {
            return keyForEveryone;
          }
          const currentAgentOrAccountID = accountOrAgentIDfromSessionID(this.node.currentSessionID);
          const lookupAccountOrAgentID = isAccountID$1(currentAgentOrAccountID) ? this.id === currentAgentOrAccountID ? this.crypto.getAgentID(this.node.agentSecret) : currentAgentOrAccountID : currentAgentOrAccountID;
          const lastReadyKeyEdit = content.lastEditAt(`${keyID}_for_${lookupAccountOrAgentID}`);
          if (lastReadyKeyEdit == null ? void 0 : lastReadyKeyEdit.value) {
            const revealer = lastReadyKeyEdit.by;
            const revealerAgent = this.node.resolveAccountAgent(revealer, "Expected to know revealer")._unsafeUnwrap({ withStackTrace: true });
            const secret = this.crypto.unseal(
              lastReadyKeyEdit.value,
              this.crypto.getAgentSealerSecret(this.node.agentSecret),
              // being careful here to avoid recursion
              this.crypto.getAgentSealerID(revealerAgent),
              {
                in: this.id,
                tx: lastReadyKeyEdit.tx
              }
            );
            if (secret) {
              return secret;
            }
          }
          for (const co of content.keys()) {
            if (isKeyForKeyField(co) && co.startsWith(keyID)) {
              const encryptingKeyID = co.split("_for_")[1];
              const encryptingKeySecret = this.getReadKey(encryptingKeyID);
              if (!encryptingKeySecret) {
                continue;
              }
              const encryptedPreviousKey = content.get(co);
              const secret = this.crypto.decryptKeySecret({
                encryptedID: keyID,
                encryptingID: encryptingKeyID,
                encrypted: encryptedPreviousKey
              }, encryptingKeySecret);
              if (secret) {
                return secret;
              } else {
                logger.warn(`Encrypting ${encryptingKeyID} key didn't decrypt ${keyID}`);
              }
            }
          }
          for (const co of content.keys()) {
            if (isParentGroupReference(co)) {
              const parentGroupID = getParentGroupId(co);
              const parentGroup = this.node.expectCoValueLoaded(parentGroupID, "Expected parent group to be loaded");
              const parentKeys = this.findValidParentKeys(keyID, content, parentGroup);
              for (const parentKey of parentKeys) {
                const revelationForParentKey = content.get(`${keyID}_for_${parentKey.id}`);
                if (revelationForParentKey) {
                  const secret = parentGroup.crypto.decryptKeySecret({
                    encryptedID: keyID,
                    encryptingID: parentKey.id,
                    encrypted: revelationForParentKey
                  }, parentKey.secret);
                  if (secret) {
                    return secret;
                  } else {
                    logger.warn(`Encrypting parent ${parentKey.id} key didn't decrypt ${keyID}`);
                  }
                }
              }
            }
          }
          return void 0;
        } else if (this.verified.header.ruleset.type === "ownedByGroup") {
          return this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getReadKey(keyID);
        } else {
          throw new Error("Only groups or values owned by groups have read secrets");
        }
      }
      findValidParentKeys(keyID, group, parentGroup) {
        const validParentKeys = [];
        for (const co of group.keys()) {
          if (isKeyForKeyField(co) && co.startsWith(keyID)) {
            const encryptingKeyID = co.split("_for_")[1];
            const encryptingKeySecret = parentGroup.getReadKey(encryptingKeyID);
            if (!encryptingKeySecret) {
              continue;
            }
            validParentKeys.push({
              id: encryptingKeyID,
              secret: encryptingKeySecret
            });
          }
        }
        return validParentKeys;
      }
      getGroup() {
        if (!this.verified) {
          throw new Error("CoValueCore: getGroup called on coValue without verified state");
        }
        if (this.verified.header.ruleset.type !== "ownedByGroup") {
          throw new Error("Only values owned by groups have groups");
        }
        return expectGroup(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent());
      }
      getTx(txID) {
        var _a, _b;
        return (_b = (_a = this.verified) == null ? void 0 : _a.sessions.get(txID.sessionID)) == null ? void 0 : _b.transactions[txID.txIndex];
      }
      getDependedOnCoValues() {
        if (this._cachedDependentOn) {
          return this._cachedDependentOn;
        } else {
          if (!this.verified) {
            return /* @__PURE__ */ new Set();
          }
          const dependentOn = getDependedOnCoValuesFromRawData(this.id, this.verified.header, this.verified.sessions.keys(), Array.from(this.verified.sessions.values(), (session) => session.transactions));
          this._cachedDependentOn = dependentOn;
          return dependentOn;
        }
      }
      waitForSync(options) {
        return this.node.syncManager.waitForSync(this.id, options == null ? void 0 : options.timeout);
      }
      load(peers) {
        this.loadFromStorage((found) => {
          if (!found) {
            this.loadFromPeers(peers);
          }
        });
      }
      loadFromStorage(done) {
        const node = this.node;
        if (!node.storage) {
          done == null ? void 0 : done(false);
          return;
        }
        const currentState = this.peers.get("storage");
        if (currentState && currentState.type !== "unknown") {
          done == null ? void 0 : done(currentState.type === "available");
          return;
        }
        this.markPending("storage");
        node.storage.load(this.id, (data2) => {
          node.syncManager.handleNewContent(data2, "storage");
        }, (found) => {
          if (!found) {
            this.markNotFoundInPeer("storage");
          }
          done == null ? void 0 : done(found);
        });
      }
      loadFromPeers(peers) {
        var _a;
        if (peers.length === 0) {
          return;
        }
        const peersToActuallyLoadFrom = [];
        for (const peer of peers) {
          const currentState = (_a = this.peers.get(peer.id)) == null ? void 0 : _a.type;
          if (!currentState || currentState === "unknown" || currentState === "unavailable") {
            peersToActuallyLoadFrom.push(peer);
            this.markPending(peer.id);
          }
        }
        for (const peer of peersToActuallyLoadFrom) {
          this.internalLoadFromPeer(peer);
        }
      }
      internalLoadFromPeer(peer) {
        if (peer.closed) {
          this.markNotFoundInPeer(peer.id);
          return;
        }
        peer.pushOutgoingMessage({
          action: "load",
          ...this.knownState()
        });
        peer.trackLoadRequestSent(this.id);
        return new Promise((resolve) => {
          const markNotFound = () => {
            var _a;
            if (((_a = this.peers.get(peer.id)) == null ? void 0 : _a.type) === "pending") {
              logger.warn("Timeout waiting for peer to load coValue", {
                id: this.id,
                peerID: peer.id
              });
              this.markNotFoundInPeer(peer.id);
            }
          };
          const timeout = setTimeout(markNotFound, CO_VALUE_LOADING_CONFIG.TIMEOUT);
          const removeCloseListener = peer.addCloseListener(markNotFound);
          const listener = (state) => {
            const peerState = state.peers.get(peer.id);
            if (state.isAvailable() || // might have become available from another peer e.g. through handleNewContent
            (peerState == null ? void 0 : peerState.type) === "available" || (peerState == null ? void 0 : peerState.type) === "errored" || (peerState == null ? void 0 : peerState.type) === "unavailable") {
              this.listeners.delete(listener);
              removeCloseListener();
              clearTimeout(timeout);
              resolve();
            }
          };
          this.listeners.add(listener);
          listener(this);
        });
      }
    }
    class LocalNode {
      /** @category 3. Low-level */
      constructor(agentSecret, currentSessionID, crypto2) {
        this.coValues = /* @__PURE__ */ new Map();
        this.syncManager = new SyncManager(this);
        this.crashed = void 0;
        this.agentSecret = agentSecret;
        this.currentSessionID = currentSessionID;
        this.crypto = crypto2;
      }
      setStorage(storage) {
        this.storage = storage;
      }
      removeStorage() {
        var _a;
        (_a = this.storage) == null ? void 0 : _a.close();
        this.storage = void 0;
      }
      getCoValue(id2) {
        let entry = this.coValues.get(id2);
        if (!entry) {
          entry = CoValueCore.fromID(id2, this);
          this.coValues.set(id2, entry);
        }
        return entry;
      }
      allCoValues() {
        return this.coValues.values();
      }
      putCoValue(id2, verified, { forceOverwrite = false } = {}) {
        const entry = this.getCoValue(id2);
        entry.internalMarkMagicallyAvailable(verified, { forceOverwrite });
        return entry;
      }
      internalDeleteCoValue(id2) {
        this.coValues.delete(id2);
      }
      getCurrentAccountOrAgentID() {
        return accountOrAgentIDfromSessionID(this.currentSessionID);
      }
      getCurrentAgent() {
        const accountOrAgent = this.getCurrentAccountOrAgentID();
        if (isAgentID(accountOrAgent)) {
          return new ControlledAgent(this.agentSecret, this.crypto);
        }
        return new ControlledAccount(expectAccount(this.expectCoValueLoaded(accountOrAgent).getCurrentContent()), this.agentSecret);
      }
      expectCurrentAccountID(reason) {
        const accountOrAgent = this.getCurrentAccountOrAgentID();
        if (isAgentID(accountOrAgent)) {
          throw new Error("Current account is an agent, but expected an account: " + reason);
        }
        return accountOrAgent;
      }
      expectCurrentAccount(reason) {
        const accountID = this.expectCurrentAccountID(reason);
        return expectAccount(this.expectCoValueLoaded(accountID).getCurrentContent());
      }
      static internalCreateAccount(opts) {
        const { crypto: crypto2, initialAgentSecret = crypto2.newRandomAgentSecret(), peersToLoadFrom = [] } = opts;
        const accountHeader = accountHeaderForInitialAgentSecret(initialAgentSecret, crypto2);
        const accountID = idforHeader(accountHeader, crypto2);
        const node = new LocalNode(initialAgentSecret, crypto2.newRandomSessionID(accountID), crypto2);
        if (opts.storage) {
          node.setStorage(opts.storage);
        }
        for (const peer of peersToLoadFrom) {
          node.syncManager.addPeer(peer);
        }
        const accountAgentID = crypto2.getAgentID(initialAgentSecret);
        const rawAccount = expectGroup(node.createCoValue(accountHeader).getCurrentContent());
        rawAccount.set(accountAgentID, "admin", "trusting");
        const readKey = crypto2.newRandomKeySecret();
        const sealed = crypto2.seal({
          message: readKey.secret,
          from: crypto2.getAgentSealerSecret(initialAgentSecret),
          to: crypto2.getAgentSealerID(accountAgentID),
          nOnceMaterial: {
            in: rawAccount.id,
            tx: rawAccount.core.nextTransactionID()
          }
        });
        rawAccount.set(`${readKey.id}_for_${accountAgentID}`, sealed, "trusting");
        rawAccount.set("readKey", readKey.id, "trusting");
        return node.expectCurrentAccount("after creation");
      }
      /** @category 2. Node Creation */
      static async withNewlyCreatedAccount({ creationProps, peersToLoadFrom, migration, crypto: crypto2, initialAgentSecret = crypto2.newRandomAgentSecret(), storage }) {
        const account = LocalNode.internalCreateAccount({
          crypto: crypto2,
          initialAgentSecret,
          peersToLoadFrom,
          storage
        });
        const node = account.core.node;
        if (migration) {
          await migration(account, node, creationProps);
        } else {
          const profileGroup = node.createGroup();
          profileGroup.addMember("everyone", "reader");
          const profile = profileGroup.createMap({
            name: creationProps.name
          });
          account.set("profile", profile.id, "trusting");
        }
        const profileId = account.get("profile");
        if (!profileId) {
          throw new Error("Must set account profile in initial migration");
        }
        if (node.storage) {
          await Promise.all([
            node.syncManager.waitForStorageSync(account.id),
            node.syncManager.waitForStorageSync(profileId)
          ]);
        }
        return {
          node,
          accountID: account.id,
          accountSecret: initialAgentSecret,
          sessionID: node.currentSessionID
        };
      }
      /** @category 2. Node Creation */
      static async withLoadedAccount({ accountID, accountSecret, sessionID, peersToLoadFrom, crypto: crypto2, migration, storage }) {
        try {
          const node = new LocalNode(accountSecret, sessionID || crypto2.newRandomSessionID(accountID), crypto2);
          if (storage) {
            node.setStorage(storage);
          }
          for (const peer of peersToLoadFrom) {
            node.syncManager.addPeer(peer);
          }
          const account = await node.load(accountID);
          if (account === "unavailable") {
            throw new Error("Account unavailable from all peers");
          }
          const profileID = account.get("profile");
          if (!profileID) {
            throw new Error("Account has no profile");
          }
          await node.load(profileID);
          if (migration) {
            await migration(account, node);
          }
          return node;
        } catch (e) {
          logger.error("Error withLoadedAccount", { err: e });
          throw e;
        }
      }
      /** @internal */
      createCoValue(header) {
        if (this.crashed) {
          throw new Error("Trying to create CoValue after node has crashed", {
            cause: this.crashed
          });
        }
        const id2 = idforHeader(header, this.crypto);
        const coValue = this.putCoValue(id2, new VerifiedState(id2, this.crypto, header, /* @__PURE__ */ new Map()));
        void this.syncManager.requestCoValueSync(coValue);
        return coValue;
      }
      /** @internal */
      async loadCoValueCore(id2, skipLoadingFromPeer, skipRetry) {
        if (typeof id2 !== "string" || !id2.startsWith("co_z")) {
          throw new TypeError(`Trying to load CoValue with invalid id ${Array.isArray(id2) ? JSON.stringify(id2) : id2}`);
        }
        if (this.crashed) {
          throw new Error("Trying to load CoValue after node has crashed", {
            cause: this.crashed
          });
        }
        let retries = 0;
        while (true) {
          const coValue = this.getCoValue(id2);
          if (coValue.isAvailable()) {
            return coValue;
          }
          if (coValue.loadingState === "unknown" || coValue.loadingState === "unavailable") {
            const peers = this.syncManager.getServerPeers(skipLoadingFromPeer);
            if (!this.storage && peers.length === 0) {
              return coValue;
            }
            coValue.load(peers);
          }
          const result = await coValue.waitForAvailableOrUnavailable();
          if (result.isAvailable() || skipRetry || retries >= CO_VALUE_LOADING_CONFIG.MAX_RETRIES) {
            return result;
          }
          await Promise.race([
            new Promise((resolve) => setTimeout(resolve, CO_VALUE_LOADING_CONFIG.RETRY_DELAY)),
            coValue.waitForAvailable()
            // Stop waiting if the coValue becomes available
          ]);
          retries++;
        }
      }
      /**
       * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
       * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
       * for listening to subsequent updates to the CoValue.
       *
       * @category 3. Low-level
       */
      async load(id2, skipRetry) {
        const core = await this.loadCoValueCore(id2, void 0, skipRetry);
        if (!core.isAvailable()) {
          return "unavailable";
        }
        return core.getCurrentContent();
      }
      getLoaded(id2) {
        const coValue = this.getCoValue(id2);
        if (coValue.isAvailable()) {
          return coValue.getCurrentContent();
        }
        return void 0;
      }
      /** @category 3. Low-level */
      subscribe(id2, callback, skipRetry) {
        let stopped = false;
        let unsubscribe;
        this.load(id2, skipRetry).then((coValue) => {
          if (stopped) {
            return;
          }
          if (coValue === "unavailable") {
            callback("unavailable");
            return;
          }
          unsubscribe = coValue.subscribe(callback);
        }).catch((e) => {
          logger.error("Subscription error", {
            id: id2,
            err: e
          });
        });
        return () => {
          stopped = true;
          unsubscribe == null ? void 0 : unsubscribe();
        };
      }
      async acceptInvite(groupOrOwnedValueID, inviteSecret) {
        var _a;
        const value = await this.load(groupOrOwnedValueID);
        if (value === "unavailable") {
          throw new Error("Trying to accept invite: Group/owned value unavailable from all peers");
        }
        const ruleset = value.core.verified.header.ruleset;
        let group;
        if (ruleset.type === "unsafeAllowAll") {
          throw new Error("Can only accept invites to values owned by groups");
        }
        if (ruleset.type === "ownedByGroup") {
          const owner = await this.load(ruleset.group);
          if (owner === "unavailable") {
            throw new Error("Trying to accept invite: CoValue owner unavailable from all peers");
          }
          group = expectGroup(owner);
        } else {
          group = expectGroup(value);
        }
        if (((_a = group.core.verified.header.meta) == null ? void 0 : _a.type) === "account") {
          throw new Error("Can't accept invites to values owned by accounts");
        }
        const inviteAgentSecret = this.crypto.agentSecretFromSecretSeed(secretSeedFromInviteSecret(inviteSecret));
        const inviteAgentID = this.crypto.getAgentID(inviteAgentSecret);
        const inviteRole = await new Promise((resolve, reject) => {
          group.subscribe((groupUpdate) => {
            const role = groupUpdate.get(inviteAgentID);
            if (role) {
              resolve(role);
            }
          });
          setTimeout(() => reject(new Error("Couldn't find invite before timeout")), 2e3);
        });
        if (!inviteRole) {
          throw new Error("No invite found");
        }
        const account = this.getCurrentAgent();
        const existingRole = group.get(account.id);
        if (existingRole === "admin" || existingRole === "writer" && inviteRole === "writerInvite" || existingRole === "writer" && inviteRole === "reader" || existingRole === "reader" && inviteRole === "readerInvite" || existingRole && inviteRole === "writeOnlyInvite") {
          logger.debug("Not accepting invite that would replace or downgrade role");
          return;
        }
        const groupAsInvite = expectGroup(this.loadCoValueAsDifferentAgent(group.id, inviteAgentSecret).getCurrentContent());
        groupAsInvite.addMemberInternal(account, inviteRole === "adminInvite" ? "admin" : inviteRole === "writerInvite" ? "writer" : inviteRole === "writeOnlyInvite" ? "writeOnly" : "reader");
        group.core.internalShamefullyCloneVerifiedStateFrom(groupAsInvite.core.verified, { forceOverwrite: true });
        group.processNewTransactions();
        group.core.notifyUpdate("immediate");
        this.syncManager.requestCoValueSync(group.core);
      }
      /** @internal */
      expectCoValueLoaded(id2, expectation) {
        const coValue = this.getCoValue(id2);
        if (!coValue.isAvailable()) {
          throw new Error(`${expectation ? expectation + ": " : ""}CoValue ${id2} not yet loaded.`);
        }
        return coValue;
      }
      /** @internal */
      expectProfileLoaded(id2, expectation) {
        const account = this.expectCoValueLoaded(id2, expectation);
        const profileID = expectGroup(account.getCurrentContent()).get("profile");
        if (!profileID) {
          throw new Error(`${expectation ? expectation + ": " : ""}Account ${id2} has no profile`);
        }
        return this.expectCoValueLoaded(profileID, expectation).getCurrentContent();
      }
      /** @internal */
      resolveAccountAgent(id2, expectation) {
        if (isAgentID(id2)) {
          return ok(id2);
        }
        let coValue;
        try {
          coValue = this.expectCoValueLoaded(id2, expectation);
        } catch (e) {
          return err({
            type: "ErrorLoadingCoValueCore",
            expectation,
            id: id2,
            error: e
          });
        }
        if (coValue.verified.header.type !== "comap" || coValue.verified.header.ruleset.type !== "group" || !coValue.verified.header.meta || !("type" in coValue.verified.header.meta) || coValue.verified.header.meta.type !== "account") {
          return err({
            type: "UnexpectedlyNotAccount",
            expectation,
            id: id2
          });
        }
        return ok(coValue.getCurrentContent().currentAgentID());
      }
      createGroup(uniqueness = this.crypto.createdNowUnique()) {
        const account = this.getCurrentAgent();
        const groupCoValue = this.createCoValue({
          type: "comap",
          ruleset: { type: "group", initialAdmin: account.id },
          meta: null,
          ...uniqueness
        });
        const group = expectGroup(groupCoValue.getCurrentContent());
        group.set(account.id, "admin", "trusting");
        const readKey = this.crypto.newRandomKeySecret();
        group.set(`${readKey.id}_for_${account.id}`, this.crypto.seal({
          message: readKey.secret,
          from: account.currentSealerSecret(),
          to: account.currentSealerID(),
          nOnceMaterial: {
            in: groupCoValue.id,
            tx: groupCoValue.nextTransactionID()
          }
        }), "trusting");
        group.set("readKey", readKey.id, "trusting");
        return group;
      }
      loadCoValueAsDifferentAgent(id2, secret, accountId) {
        const agent = new ControlledAgent(secret, this.crypto);
        const newNode = new LocalNode(secret, this.crypto.newRandomSessionID(accountId || agent.id), this.crypto);
        newNode.cloneVerifiedStateFrom(this, id2);
        return newNode.expectCoValueLoaded(id2);
      }
      /** @internal */
      cloneVerifiedStateFrom(otherNode, id2) {
        var _a;
        const coValuesIdsToCopy = [id2];
        for (let i = 0; i < coValuesIdsToCopy.length; i++) {
          const coValueID = coValuesIdsToCopy[i];
          const coValue = otherNode.getCoValue(coValueID);
          if (!coValue.isAvailable()) {
            continue;
          }
          for (const dep of coValue.getDependedOnCoValues()) {
            coValuesIdsToCopy.push(dep);
          }
        }
        while (coValuesIdsToCopy.length > 0) {
          const coValueID = coValuesIdsToCopy.pop();
          const coValue = otherNode.getCoValue(coValueID);
          if (!coValue.isAvailable()) {
            continue;
          }
          if ((_a = this.coValues.get(coValueID)) == null ? void 0 : _a.isAvailable()) {
            continue;
          }
          this.putCoValue(coValueID, coValue.verified);
        }
      }
      gracefulShutdown() {
        var _a;
        (_a = this.storage) == null ? void 0 : _a.close();
        this.syncManager.gracefulShutdown();
      }
    }
    function connectedPeers(peer1id, peer2id, { peer1role = "client", peer2role = "client" } = {}) {
      const from1to2 = new ConnectedPeerChannel$1();
      const from2to1 = new ConnectedPeerChannel$1();
      const peer2AsPeer = {
        id: peer2id,
        incoming: from2to1,
        outgoing: from1to2,
        role: peer2role
      };
      const peer1AsPeer = {
        id: peer1id,
        incoming: from1to2,
        outgoing: from2to1,
        role: peer1role
      };
      return [peer1AsPeer, peer2AsPeer];
    }
    let ConnectedPeerChannel$1 = class ConnectedPeerChannel {
      constructor() {
        this.buffer = [];
        this.listeners = /* @__PURE__ */ new Set();
        this.closed = false;
        this.closeListeners = /* @__PURE__ */ new Set();
      }
      push(msg) {
        if (!this.listeners.size) {
          this.buffer.push(msg);
          return;
        }
        for (const listener of this.listeners) {
          listener(msg);
        }
      }
      close() {
        this.closed = true;
        for (const listener of this.closeListeners) {
          listener();
        }
        this.closeListeners.clear();
        this.listeners.clear();
      }
      onMessage(callback) {
        if (this.buffer.length) {
          for (const msg of this.buffer) {
            callback(msg);
          }
          this.buffer = [];
        }
        this.listeners.add(callback);
      }
      onClose(callback) {
        this.closeListeners.add(callback);
      }
    };
    class StorageKnownState {
      constructor() {
        this.knwonStates = /* @__PURE__ */ new Map();
        this.waitForSyncRequests = /* @__PURE__ */ new Map();
      }
      getKnownState(id2) {
        const knownState = this.knwonStates.get(id2);
        if (!knownState) {
          const empty = emptyKnownState(id2);
          this.knwonStates.set(id2, empty);
          return empty;
        }
        return knownState;
      }
      setKnownState(id2, knownState) {
        this.knwonStates.set(id2, knownState);
      }
      handleUpdate(id2, knownState) {
        const requests = this.waitForSyncRequests.get(id2);
        if (!requests) {
          return;
        }
        for (const request of requests) {
          if (isInSync(request.knownState, knownState)) {
            request.resolve();
            requests.delete(request);
          }
        }
      }
      waitForSync(id2, coValue) {
        const initialKnownState = coValue.knownState();
        if (isInSync(initialKnownState, this.getKnownState(id2))) {
          return Promise.resolve();
        }
        const requests = this.waitForSyncRequests.get(id2) || /* @__PURE__ */ new Set();
        this.waitForSyncRequests.set(id2, requests);
        return new Promise((resolve) => {
          const unsubscribe = coValue.subscribe((coValue2) => {
            req.knownState = coValue2.knownState();
            this.handleUpdate(id2, this.getKnownState(id2));
          }, false);
          const handleResolve = () => {
            resolve();
            unsubscribe();
          };
          const req = { knownState: initialKnownState, resolve: handleResolve };
          requests.add(req);
        });
      }
    }
    function isInSync(knownState, knownStateFromStorage) {
      if (!knownStateFromStorage.header && knownState.header) {
        return false;
      }
      return getIsUploaded(knownState.sessions, knownStateFromStorage.sessions);
    }
    function collectNewTxs({ newTxsInSession, contentMessage, sessionRow, firstNewTxIdx, signature }) {
      let sessionEntry = contentMessage.new[sessionRow.sessionID];
      if (!sessionEntry) {
        sessionEntry = {
          after: firstNewTxIdx,
          lastSignature: signature,
          newTransactions: []
        };
        contentMessage.new[sessionRow.sessionID] = sessionEntry;
      } else {
        sessionEntry.lastSignature = signature;
      }
      for (const tx of newTxsInSession) {
        sessionEntry.newTransactions.push(tx.tx);
      }
    }
    function getDependedOnCoValues(header, contentMessage) {
      const id2 = contentMessage.id;
      const sessionIDs = Object.keys(contentMessage.new);
      const transactions = Object.values(contentMessage.new).map((entry) => entry.newTransactions);
      return getDependedOnCoValuesFromRawData(id2, header, sessionIDs, transactions);
    }
    class StoreQueue {
      constructor() {
        this.queue = new LinkedList();
        this.processing = false;
      }
      push(data2, correctionCallback) {
        this.queue.push({ data: data2, correctionCallback });
      }
      pull() {
        return this.queue.shift();
      }
      async processQueue(callback) {
        if (this.processing) {
          return;
        }
        this.processing = true;
        let entry;
        while (entry = this.pull()) {
          const { data: data2, correctionCallback } = entry;
          try {
            await callback(data2, correctionCallback);
          } catch (err2) {
            logger.error("Error processing message in store queue", { err: err2 });
          }
        }
        this.processing = false;
      }
      drain() {
        while (this.pull()) {
        }
      }
    }
    class StorageApiAsync {
      constructor(dbClient) {
        this.loadedCoValues = /* @__PURE__ */ new Set();
        this.knwonStates = new StorageKnownState();
        this.storeQueue = new StoreQueue();
        this.dbClient = dbClient;
      }
      getKnownState(id2) {
        return this.knwonStates.getKnownState(id2);
      }
      async load(id2, callback, done) {
        await this.loadCoValue(id2, callback, done);
      }
      async loadCoValue(id2, callback, done) {
        const coValueRow = await this.dbClient.getCoValue(id2);
        if (!coValueRow) {
          done == null ? void 0 : done(false);
          return;
        }
        const allCoValueSessions = await this.dbClient.getCoValueSessions(coValueRow.rowID);
        const signaturesBySession = /* @__PURE__ */ new Map();
        let contentStreaming = false;
        await Promise.all(allCoValueSessions.map(async (sessionRow) => {
          const signatures = await this.dbClient.getSignatures(sessionRow.rowID, 0);
          if (signatures.length > 0) {
            contentStreaming = true;
            signaturesBySession.set(sessionRow.sessionID, signatures);
          }
        }));
        const knownState = this.knwonStates.getKnownState(coValueRow.id);
        for (const sessionRow of allCoValueSessions) {
          knownState.sessions[sessionRow.sessionID] = sessionRow.lastIdx;
        }
        this.loadedCoValues.add(coValueRow.id);
        let contentMessage = {
          action: "content",
          id: coValueRow.id,
          header: coValueRow.header,
          new: {},
          priority: getPriorityFromHeader(coValueRow.header)
        };
        if (contentStreaming) {
          contentMessage.expectContentUntil = knownState["sessions"];
        }
        for (const sessionRow of allCoValueSessions) {
          const signatures = signaturesBySession.get(sessionRow.sessionID) || [];
          let idx = 0;
          signatures.push({
            idx: sessionRow.lastIdx,
            signature: sessionRow.lastSignature
          });
          for (const signature of signatures) {
            const newTxsInSession = await this.dbClient.getNewTransactionInSession(sessionRow.rowID, idx, signature.idx);
            collectNewTxs({
              newTxsInSession,
              contentMessage,
              sessionRow,
              firstNewTxIdx: idx,
              signature: signature.signature
            });
            idx = signature.idx + 1;
            if (signatures.length > 1) {
              await this.pushContentWithDependencies(coValueRow, contentMessage, callback);
              contentMessage = {
                action: "content",
                id: coValueRow.id,
                header: coValueRow.header,
                new: {},
                priority: getPriorityFromHeader(coValueRow.header)
              };
            }
          }
        }
        const hasNewContent = Object.keys(contentMessage.new).length > 0;
        if (hasNewContent || !contentStreaming) {
          await this.pushContentWithDependencies(coValueRow, contentMessage, callback);
        }
        this.knwonStates.handleUpdate(coValueRow.id, knownState);
        done == null ? void 0 : done(true);
      }
      async pushContentWithDependencies(coValueRow, contentMessage, pushCallback) {
        const dependedOnCoValuesList = getDependedOnCoValues(coValueRow.header, contentMessage);
        const promises = [];
        for (const dependedOnCoValue of dependedOnCoValuesList) {
          if (this.loadedCoValues.has(dependedOnCoValue)) {
            continue;
          }
          promises.push(new Promise((resolve) => {
            this.loadCoValue(dependedOnCoValue, pushCallback, resolve);
          }));
        }
        await Promise.all(promises);
        pushCallback(contentMessage);
      }
      async store(msgs, correctionCallback) {
        this.storeQueue.push(msgs, correctionCallback);
        this.storeQueue.processQueue(async (data2, correctionCallback2) => {
          for (const msg of data2) {
            const success2 = await this.storeSingle(msg, correctionCallback2);
            if (!success2) {
              break;
            }
          }
        });
      }
      async storeSingle(msg, correctionCallback) {
        const id2 = msg.id;
        const coValueRow = await this.dbClient.getCoValue(id2);
        const invalidAssumptionOnHeaderPresence = !msg.header && !coValueRow;
        if (invalidAssumptionOnHeaderPresence) {
          const knownState2 = emptyKnownState(id2);
          this.knwonStates.setKnownState(id2, knownState2);
          correctionCallback(knownState2);
          return false;
        }
        const storedCoValueRowID = coValueRow ? coValueRow.rowID : await this.dbClient.addCoValue(msg);
        const knownState = this.knwonStates.getKnownState(id2);
        knownState.header = true;
        let invalidAssumptions = false;
        for (const sessionID of Object.keys(msg.new)) {
          await this.dbClient.transaction(async () => {
            var _a;
            const sessionRow = await this.dbClient.getSingleCoValueSession(storedCoValueRowID, sessionID);
            if (sessionRow) {
              knownState.sessions[sessionRow.sessionID] = sessionRow.lastIdx;
            }
            const lastIdx = (sessionRow == null ? void 0 : sessionRow.lastIdx) || 0;
            const after = ((_a = msg.new[sessionID]) == null ? void 0 : _a.after) || 0;
            if (lastIdx < after) {
              knownState.sessions[sessionID] = lastIdx;
              invalidAssumptions = true;
            } else {
              const newLastIdx = await this.putNewTxs(msg, sessionID, sessionRow, storedCoValueRowID);
              knownState.sessions[sessionID] = newLastIdx;
            }
          });
        }
        this.knwonStates.handleUpdate(id2, knownState);
        if (invalidAssumptions) {
          correctionCallback(knownState);
          return false;
        }
        return true;
      }
      async putNewTxs(msg, sessionID, sessionRow, storedCoValueRowID) {
        var _a, _b;
        const newTransactions = ((_a = msg.new[sessionID]) == null ? void 0 : _a.newTransactions) || [];
        const actuallyNewOffset = ((sessionRow == null ? void 0 : sessionRow.lastIdx) || 0) - (((_b = msg.new[sessionID]) == null ? void 0 : _b.after) || 0);
        const actuallyNewTransactions = newTransactions.slice(actuallyNewOffset);
        if (actuallyNewTransactions.length === 0) {
          return (sessionRow == null ? void 0 : sessionRow.lastIdx) || 0;
        }
        let newBytesSinceLastSignature = ((sessionRow == null ? void 0 : sessionRow.bytesSinceLastSignature) || 0) + actuallyNewTransactions.reduce((sum, tx) => sum + (tx.privacy === "private" ? tx.encryptedChanges.length : tx.changes.length), 0);
        const newLastIdx = ((sessionRow == null ? void 0 : sessionRow.lastIdx) || 0) + actuallyNewTransactions.length;
        let shouldWriteSignature = false;
        if (newBytesSinceLastSignature > MAX_RECOMMENDED_TX_SIZE) {
          shouldWriteSignature = true;
          newBytesSinceLastSignature = 0;
        }
        const nextIdx = (sessionRow == null ? void 0 : sessionRow.lastIdx) || 0;
        if (!msg.new[sessionID])
          throw new Error("Session ID not found");
        const sessionUpdate = {
          coValue: storedCoValueRowID,
          sessionID,
          lastIdx: newLastIdx,
          lastSignature: msg.new[sessionID].lastSignature,
          bytesSinceLastSignature: newBytesSinceLastSignature
        };
        const sessionRowID = await this.dbClient.addSessionUpdate({
          sessionUpdate,
          sessionRow
        });
        if (shouldWriteSignature) {
          await this.dbClient.addSignatureAfter({
            sessionRowID,
            idx: newLastIdx - 1,
            signature: msg.new[sessionID].lastSignature
          });
        }
        await Promise.all(actuallyNewTransactions.map((newTransaction, i) => this.dbClient.addTransaction(sessionRowID, nextIdx + i, newTransaction)));
        return newLastIdx;
      }
      waitForSync(id2, coValue) {
        return this.knwonStates.waitForSync(id2, coValue);
      }
      close() {
        this.storeQueue.drain();
      }
    }
    const cojsonInternals = {
      connectedPeers,
      rawCoIDtoBytes,
      rawCoIDfromBytes,
      secretSeedLength,
      shortHashLength,
      expectGroup,
      base64URLtoBytes,
      bytesToBase64url,
      parseJSON,
      stableStringify,
      getDependedOnCoValuesFromRawData,
      accountOrAgentIDfromSessionID,
      isAccountID: isAccountID$1,
      accountHeaderForInitialAgentSecret,
      idforHeader,
      StreamingHash,
      getPriorityFromHeader,
      getGroupDependentKeyList,
      getGroupDependentKey,
      disablePermissionErrors,
      SyncManager,
      CO_VALUE_LOADING_CONFIG,
      CO_VALUE_PRIORITY: CO_VALUE_PRIORITY$1,
      setIncomingMessagesTimeBudget,
      setCoValueLoadingRetryDelay,
      ConnectedPeerChannel: ConnectedPeerChannel$1,
      textEncoder,
      textDecoder
    };
    var bin = {};
    var hasRequiredBin;
    function requireBin() {
      if (hasRequiredBin) return bin;
      hasRequiredBin = 1;
      Object.defineProperty(bin, "__esModule", { value: true });
      bin.calcSlices = bin.applyPatch = bin.calcPatch = bin.lcs = bin.diff = bin.diff_core = void 0;
      function diff_internal(state, c) {
        const { b, eq, stack_base } = state;
        let { i, N, j, M, Z, stack_top } = state;
        for (; ; ) {
          switch (c) {
            case 0: {
              Z_block: while (N > 0 && M > 0) {
                b.fill(0, 0, 2 * Z);
                const W = N - M;
                const L = N + M;
                const parity = L & 1;
                const offsetx = i + N - 1;
                const offsety = j + M - 1;
                const hmax = (L + parity) / 2;
                let z2;
                h_loop: for (let h = 0; h <= hmax; h++) {
                  const kmin = 2 * Math.max(0, h - M) - h;
                  const kmax = h - 2 * Math.max(0, h - N);
                  for (let k = kmin; k <= kmax; k += 2) {
                    const gkm = b[k - 1 - Z * Math.floor((k - 1) / Z)];
                    const gkp = b[k + 1 - Z * Math.floor((k + 1) / Z)];
                    const u = k === -h || k !== h && gkm < gkp ? gkp : gkm + 1;
                    const v = u - k;
                    let x = u;
                    let y = v;
                    while (x < N && y < M && eq(i + x, j + y))
                      x++, y++;
                    b[k - Z * Math.floor(k / Z)] = x;
                    if (parity === 1 && (z2 = W - k) >= 1 - h && z2 < h && x + b[Z + z2 - Z * Math.floor(z2 / Z)] >= N) {
                      if (h > 1 || x !== u) {
                        stack_base[stack_top++] = i + x;
                        stack_base[stack_top++] = N - x;
                        stack_base[stack_top++] = j + y;
                        stack_base[stack_top++] = M - y;
                        N = u;
                        M = v;
                        Z = 2 * (Math.min(N, M) + 1);
                        continue Z_block;
                      } else
                        break h_loop;
                    }
                  }
                  for (let k = kmin; k <= kmax; k += 2) {
                    const pkm = b[Z + k - 1 - Z * Math.floor((k - 1) / Z)];
                    const pkp = b[Z + k + 1 - Z * Math.floor((k + 1) / Z)];
                    const u = k === -h || k !== h && pkm < pkp ? pkp : pkm + 1;
                    const v = u - k;
                    let x = u;
                    let y = v;
                    while (x < N && y < M && eq(offsetx - x, offsety - y))
                      x++, y++;
                    b[Z + k - Z * Math.floor(k / Z)] = x;
                    if (parity === 0 && (z2 = W - k) >= -h && z2 <= h && x + b[z2 - Z * Math.floor(z2 / Z)] >= N) {
                      if (h > 0 || x !== u) {
                        stack_base[stack_top++] = i + N - u;
                        stack_base[stack_top++] = u;
                        stack_base[stack_top++] = j + M - v;
                        stack_base[stack_top++] = v;
                        N = N - x;
                        M = M - y;
                        Z = 2 * (Math.min(N, M) + 1);
                        continue Z_block;
                      } else
                        break h_loop;
                    }
                  }
                }
                if (N === M)
                  continue;
                if (M > N) {
                  i += N;
                  j += N;
                  M -= N;
                  N = 0;
                } else {
                  i += M;
                  j += M;
                  N -= M;
                  M = 0;
                }
                break;
              }
              if (N + M !== 0) {
                if (state.pxe === i || state.pye === j) {
                  state.pxe = i + N;
                  state.pye = j + M;
                } else {
                  const sx = state.pxs;
                  state.oxs = state.pxs;
                  state.oxe = state.pxe;
                  state.oys = state.pys;
                  state.oye = state.pye;
                  state.pxs = i;
                  state.pxe = i + N;
                  state.pys = j;
                  state.pye = j + M;
                  if (sx >= 0) {
                    state.i = i;
                    state.N = N;
                    state.j = j;
                    state.M = M;
                    state.Z = Z;
                    state.stack_top = stack_top;
                    return 1;
                  }
                }
              }
            }
            case 1: {
              if (stack_top === 0)
                return 2;
              M = stack_base[--stack_top];
              j = stack_base[--stack_top];
              N = stack_base[--stack_top];
              i = stack_base[--stack_top];
              Z = 2 * (Math.min(N, M) + 1);
              c = 0;
            }
          }
        }
      }
      class DiffGen {
        constructor(state) {
          this.state = state;
          this.c = 0;
          this.result = { value: null, done: false };
        }
        [Symbol.iterator]() {
          return this;
        }
        next() {
          const { state, result } = this;
          if (this.c > 1) {
            result.done = true;
            result.value = void 0;
            return result;
          }
          const c = diff_internal(state, this.c);
          this.c = c;
          if (c === 1) {
            result.value = [state.oxs, state.oxe, state.oys, state.oye];
            return result;
          }
          if (state.pxs >= 0) {
            result.value = [state.pxs, state.pxe, state.pys, state.pye];
            return result;
          }
          result.done = true;
          result.value = void 0;
          return result;
        }
      }
      function diff_core(i, N, j, M, eq) {
        const Z = (Math.min(N, M) + 1) * 2;
        const L = N + M;
        const b = new (L < 256 ? Uint8Array : L < 65536 ? Uint16Array : Uint32Array)(2 * Z);
        return new DiffGen({ i, N, j, M, Z, b, eq, pxs: -1, pxe: -1, pys: -1, pye: -1, oxs: -1, oxe: -1, oys: -1, oye: -1, stack_top: 0, stack_base: [] });
      }
      bin.diff_core = diff_core;
      function diff(xs, ys, eq) {
        let [i, N, M] = [0, xs.length, ys.length];
        if (typeof eq === "function") {
          while (i < N && i < M && eq(i, i))
            i++;
          if (i === N && i === M)
            return [][Symbol.iterator]();
          while (eq(--N, --M) && N > i && M > i) ;
        } else {
          while (i < N && i < M && xs[i] === ys[i])
            i++;
          if (i === N && i === M)
            return [][Symbol.iterator]();
          while (xs[--N] === ys[--M] && N > i && M > i) ;
          eq = (i2, j) => xs[i2] === ys[j];
        }
        return diff_core(i, N + 1 - i, i, M + 1 - i, eq);
      }
      bin.diff = diff;
      class LCSGen {
        constructor(diff2, N) {
          this.diff = diff2;
          this.N = N;
          this.i = 0;
          this.j = 0;
        }
        [Symbol.iterator]() {
          return this;
        }
        next() {
          const rec = this.diff.next();
          if (rec.done) {
            const { i: i2, j: j2, N } = this;
            if (i2 < N) {
              rec.done = false;
              rec.value = [i2, j2, N - i2];
              this.i = N;
            }
            return rec;
          }
          const v = rec.value;
          const sx = v[0];
          const ex = v[1];
          const ey = v[3];
          const { i, j } = this;
          if (i !== sx) {
            v.length--;
            v[0] = i;
            v[1] = j;
            v[2] = sx - i;
          }
          this.i = ex;
          this.j = ey;
          return rec;
        }
      }
      function lcs(xs, ys, eq) {
        return new LCSGen(diff(xs, ys, eq), xs.length);
      }
      bin.lcs = lcs;
      function* calcPatch(xs, ys, eq) {
        const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
        for (const v of diff(xs, ys, eq)) {
          v[2] = slice.call(ys, v[2], v[3]);
          yield v;
        }
      }
      bin.calcPatch = calcPatch;
      function* applyPatch(xs, patch) {
        let i = 0;
        const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
        for (const [dels, dele, ins] of patch) {
          if (i < dels)
            yield slice.call(xs, i, dels);
          if (ins.length > 0)
            yield ins;
          i = dele;
        }
        if (i < xs.length)
          yield slice.call(xs, i);
      }
      bin.applyPatch = applyPatch;
      function* calcSlices(xs, ys, eq) {
        let i = 0;
        const slice = ArrayBuffer.isView(xs) ? Uint8Array.prototype.subarray : xs.slice;
        for (const [dels, dele, inss, inse] of diff(xs, ys, eq)) {
          if (i < dels)
            yield [0, slice.call(xs, i, dels)];
          if (dels < dele)
            yield [-1, slice.call(xs, dels, dele)];
          if (inss < inse)
            yield [1, slice.call(ys, inss, inse)];
          i = dele;
        }
        if (i < xs.length)
          yield [0, xs.slice(i)];
      }
      bin.calcSlices = calcSlices;
      return bin;
    }
    var binExports = requireBin();
    /*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
    function isBytes$2(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abool$1(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    function anumber$2(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes$1(b, ...lengths) {
      if (!isBytes$2(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function aexists$1(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput$1(out, instance) {
      abytes$1(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u32$1(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean$1(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    const isLE$1 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function utf8ToBytes$1(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes$1(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes$1(data2);
      else if (isBytes$2(data2))
        data2 = copyBytes(data2);
      else
        throw new Error("Uint8Array expected, got " + typeof data2);
      return data2;
    }
    function checkOpts(defaults, opts) {
      if (opts == null || typeof opts !== "object")
        throw new Error("options must be defined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    const wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
      function wrappedCipher(key, ...args) {
        abytes$1(key);
        if (!isLE$1)
          throw new Error("Non little-endian hardware is not yet supported");
        if (params.nonceLength !== void 0) {
          const nonce = args[0];
          if (!nonce)
            throw new Error("nonce / iv required");
          if (params.varSizeNonce)
            abytes$1(nonce);
          else
            abytes$1(nonce, params.nonceLength);
        }
        const tagl = params.tagLength;
        if (tagl && args[1] !== void 0) {
          abytes$1(args[1]);
        }
        const cipher = constructor(key, ...args);
        const checkOutput = (fnLength, output2) => {
          if (output2 !== void 0) {
            if (fnLength !== 2)
              throw new Error("cipher output not supported");
            abytes$1(output2);
          }
        };
        let called = false;
        const wrCipher = {
          encrypt(data2, output2) {
            if (called)
              throw new Error("cannot encrypt() twice with same key + nonce");
            called = true;
            abytes$1(data2);
            checkOutput(cipher.encrypt.length, output2);
            return cipher.encrypt(data2, output2);
          },
          decrypt(data2, output2) {
            abytes$1(data2);
            if (tagl && data2.length < tagl)
              throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
            checkOutput(cipher.decrypt.length, output2);
            return cipher.decrypt(data2, output2);
          }
        };
        return wrCipher;
      }
      Object.assign(wrappedCipher, params);
      return wrappedCipher;
    };
    function getOutput(expectedLength, out, onlyAligned = true) {
      if (out === void 0)
        return new Uint8Array(expectedLength);
      if (out.length !== expectedLength)
        throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
      if (onlyAligned && !isAligned32$1(out))
        throw new Error("invalid output, must be aligned");
      return out;
    }
    function isAligned32$1(bytes) {
      return bytes.byteOffset % 4 === 0;
    }
    function copyBytes(bytes) {
      return Uint8Array.from(bytes);
    }
    const _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
    const sigma16 = _utf8ToBytes("expand 16-byte k");
    const sigma32 = _utf8ToBytes("expand 32-byte k");
    const sigma16_32 = u32$1(sigma16);
    const sigma32_32 = u32$1(sigma32);
    function rotl(a, b) {
      return a << b | a >>> 32 - b;
    }
    function isAligned32(b) {
      return b.byteOffset % 4 === 0;
    }
    const BLOCK_LEN = 64;
    const BLOCK_LEN32 = 16;
    const MAX_COUNTER = 2 ** 32 - 1;
    const U32_EMPTY = new Uint32Array();
    function runCipher(core, sigma, key, nonce, data2, output2, counter, rounds) {
      const len = data2.length;
      const block = new Uint8Array(BLOCK_LEN);
      const b32 = u32$1(block);
      const isAligned = isAligned32(data2) && isAligned32(output2);
      const d32 = isAligned ? u32$1(data2) : U32_EMPTY;
      const o32 = isAligned ? u32$1(output2) : U32_EMPTY;
      for (let pos = 0; pos < len; counter++) {
        core(sigma, key, nonce, b32, counter, rounds);
        if (counter >= MAX_COUNTER)
          throw new Error("arx: counter overflow");
        const take = Math.min(BLOCK_LEN, len - pos);
        if (isAligned && take === BLOCK_LEN) {
          const pos32 = pos / 4;
          if (pos % 4 !== 0)
            throw new Error("arx: invalid block position");
          for (let j = 0, posj; j < BLOCK_LEN32; j++) {
            posj = pos32 + j;
            o32[posj] = d32[posj] ^ b32[j];
          }
          pos += BLOCK_LEN;
          continue;
        }
        for (let j = 0, posj; j < take; j++) {
          posj = pos + j;
          output2[posj] = data2[posj] ^ block[j];
        }
        pos += take;
      }
    }
    function createCipher(core, opts) {
      const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
      if (typeof core !== "function")
        throw new Error("core must be a function");
      anumber$2(counterLength);
      anumber$2(rounds);
      abool$1(counterRight);
      abool$1(allowShortKeys);
      return (key, nonce, data2, output2, counter = 0) => {
        abytes$1(key);
        abytes$1(nonce);
        abytes$1(data2);
        const len = data2.length;
        if (output2 === void 0)
          output2 = new Uint8Array(len);
        abytes$1(output2);
        anumber$2(counter);
        if (counter < 0 || counter >= MAX_COUNTER)
          throw new Error("arx: counter overflow");
        if (output2.length < len)
          throw new Error(`arx: output (${output2.length}) is shorter than data (${len})`);
        const toClean = [];
        let l = key.length;
        let k;
        let sigma;
        if (l === 32) {
          toClean.push(k = copyBytes(key));
          sigma = sigma32_32;
        } else if (l === 16 && allowShortKeys) {
          k = new Uint8Array(32);
          k.set(key);
          k.set(key, 16);
          sigma = sigma16_32;
          toClean.push(k);
        } else {
          throw new Error(`arx: invalid 32-byte key, got length=${l}`);
        }
        if (!isAligned32(nonce))
          toClean.push(nonce = copyBytes(nonce));
        const k32 = u32$1(k);
        if (extendNonceFn) {
          if (nonce.length !== 24)
            throw new Error(`arx: extended nonce must be 24 bytes`);
          extendNonceFn(sigma, k32, u32$1(nonce.subarray(0, 16)), k32);
          nonce = nonce.subarray(16);
        }
        const nonceNcLen = 16 - counterLength;
        if (nonceNcLen !== nonce.length)
          throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
        if (nonceNcLen !== 12) {
          const nc = new Uint8Array(12);
          nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
          nonce = nc;
          toClean.push(nonce);
        }
        const n32 = u32$1(nonce);
        runCipher(core, sigma, k32, n32, data2, output2, counter, rounds);
        clean$1(...toClean);
        return output2;
      };
    }
    const u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
    class Poly1305 {
      constructor(key) {
        this.blockLen = 16;
        this.outputLen = 16;
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.pos = 0;
        this.finished = false;
        key = toBytes$1(key);
        abytes$1(key, 32);
        const t0 = u8to16(key, 0);
        const t1 = u8to16(key, 2);
        const t2 = u8to16(key, 4);
        const t3 = u8to16(key, 6);
        const t4 = u8to16(key, 8);
        const t5 = u8to16(key, 10);
        const t6 = u8to16(key, 12);
        const t7 = u8to16(key, 14);
        this.r[0] = t0 & 8191;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        for (let i = 0; i < 8; i++)
          this.pad[i] = u8to16(key, 16 + 2 * i);
      }
      process(data2, offset, isLast = false) {
        const hibit = isLast ? 0 : 1 << 11;
        const { h, r: r2 } = this;
        const r0 = r2[0];
        const r1 = r2[1];
        const r22 = r2[2];
        const r3 = r2[3];
        const r4 = r2[4];
        const r5 = r2[5];
        const r6 = r2[6];
        const r7 = r2[7];
        const r8 = r2[8];
        const r9 = r2[9];
        const t0 = u8to16(data2, offset + 0);
        const t1 = u8to16(data2, offset + 2);
        const t2 = u8to16(data2, offset + 4);
        const t3 = u8to16(data2, offset + 6);
        const t4 = u8to16(data2, offset + 8);
        const t5 = u8to16(data2, offset + 10);
        const t6 = u8to16(data2, offset + 12);
        const t7 = u8to16(data2, offset + 14);
        let h0 = h[0] + (t0 & 8191);
        let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
        let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
        let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
        let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
        let h5 = h[5] + (t4 >>> 1 & 8191);
        let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
        let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
        let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
        let h9 = h[9] + (t7 >>> 5 | hibit);
        let c = 0;
        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r22) + h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r22);
        c += d1 >>> 13;
        d1 &= 8191;
        let d2 = c + h0 * r22 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        let d3 = c + h0 * r3 + h1 * r22 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        let d4 = c + h0 * r4 + h1 * r3 + h2 * r22 + h3 * r1 + h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r22 + h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r22;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r22 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3 + h6 * r22 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4 + h6 * r3 + h7 * r22 + h8 * r1 + h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h[0] = d0;
        h[1] = d1;
        h[2] = d2;
        h[3] = d3;
        h[4] = d4;
        h[5] = d5;
        h[6] = d6;
        h[7] = d7;
        h[8] = d8;
        h[9] = d9;
      }
      finalize() {
        const { h, pad } = this;
        const g = new Uint16Array(10);
        let c = h[1] >>> 13;
        h[1] &= 8191;
        for (let i = 2; i < 10; i++) {
          h[i] += c;
          c = h[i] >>> 13;
          h[i] &= 8191;
        }
        h[0] += c * 5;
        c = h[0] >>> 13;
        h[0] &= 8191;
        h[1] += c;
        c = h[1] >>> 13;
        h[1] &= 8191;
        h[2] += c;
        g[0] = h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (let i = 1; i < 10; i++) {
          g[i] = h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        let mask = (c ^ 1) - 1;
        for (let i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (let i = 0; i < 10; i++)
          h[i] = h[i] & mask | g[i];
        h[0] = (h[0] | h[1] << 13) & 65535;
        h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
        h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
        h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
        h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
        h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
        h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
        h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
        let f = h[0] + pad[0];
        h[0] = f & 65535;
        for (let i = 1; i < 8; i++) {
          f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
          h[i] = f & 65535;
        }
        clean$1(g);
      }
      update(data2) {
        aexists$1(this);
        data2 = toBytes$1(data2);
        abytes$1(data2);
        const { buffer, blockLen } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(data2, pos);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(buffer, 0, false);
            this.pos = 0;
          }
        }
        return this;
      }
      destroy() {
        clean$1(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(out) {
        aexists$1(this);
        aoutput$1(out, this);
        this.finished = true;
        const { buffer, h } = this;
        let { pos } = this;
        if (pos) {
          buffer[pos++] = 1;
          for (; pos < 16; pos++)
            buffer[pos] = 0;
          this.process(buffer, 0, true);
        }
        this.finalize();
        let opos = 0;
        for (let i = 0; i < 8; i++) {
          out[opos++] = h[i] >>> 0;
          out[opos++] = h[i] >>> 8;
        }
        return out;
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
    }
    function wrapConstructorWithKey(hashCons) {
      const hashC = (msg, key) => hashCons(key).update(toBytes$1(msg)).digest();
      const tmp = hashCons(new Uint8Array(32));
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (key) => hashCons(key);
      return hashC;
    }
    const poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));
    function salsaCore(s, k, n, out, cnt, rounds = 20) {
      let y00 = s[0], y01 = k[0], y02 = k[1], y03 = k[2], y04 = k[3], y05 = s[1], y06 = n[0], y07 = n[1], y08 = cnt, y09 = 0, y10 = s[2], y11 = k[4], y12 = k[5], y13 = k[6], y14 = k[7], y15 = s[3];
      let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
      for (let r2 = 0; r2 < rounds; r2 += 2) {
        x04 ^= rotl(x00 + x12 | 0, 7);
        x08 ^= rotl(x04 + x00 | 0, 9);
        x12 ^= rotl(x08 + x04 | 0, 13);
        x00 ^= rotl(x12 + x08 | 0, 18);
        x09 ^= rotl(x05 + x01 | 0, 7);
        x13 ^= rotl(x09 + x05 | 0, 9);
        x01 ^= rotl(x13 + x09 | 0, 13);
        x05 ^= rotl(x01 + x13 | 0, 18);
        x14 ^= rotl(x10 + x06 | 0, 7);
        x02 ^= rotl(x14 + x10 | 0, 9);
        x06 ^= rotl(x02 + x14 | 0, 13);
        x10 ^= rotl(x06 + x02 | 0, 18);
        x03 ^= rotl(x15 + x11 | 0, 7);
        x07 ^= rotl(x03 + x15 | 0, 9);
        x11 ^= rotl(x07 + x03 | 0, 13);
        x15 ^= rotl(x11 + x07 | 0, 18);
        x01 ^= rotl(x00 + x03 | 0, 7);
        x02 ^= rotl(x01 + x00 | 0, 9);
        x03 ^= rotl(x02 + x01 | 0, 13);
        x00 ^= rotl(x03 + x02 | 0, 18);
        x06 ^= rotl(x05 + x04 | 0, 7);
        x07 ^= rotl(x06 + x05 | 0, 9);
        x04 ^= rotl(x07 + x06 | 0, 13);
        x05 ^= rotl(x04 + x07 | 0, 18);
        x11 ^= rotl(x10 + x09 | 0, 7);
        x08 ^= rotl(x11 + x10 | 0, 9);
        x09 ^= rotl(x08 + x11 | 0, 13);
        x10 ^= rotl(x09 + x08 | 0, 18);
        x12 ^= rotl(x15 + x14 | 0, 7);
        x13 ^= rotl(x12 + x15 | 0, 9);
        x14 ^= rotl(x13 + x12 | 0, 13);
        x15 ^= rotl(x14 + x13 | 0, 18);
      }
      let oi = 0;
      out[oi++] = y00 + x00 | 0;
      out[oi++] = y01 + x01 | 0;
      out[oi++] = y02 + x02 | 0;
      out[oi++] = y03 + x03 | 0;
      out[oi++] = y04 + x04 | 0;
      out[oi++] = y05 + x05 | 0;
      out[oi++] = y06 + x06 | 0;
      out[oi++] = y07 + x07 | 0;
      out[oi++] = y08 + x08 | 0;
      out[oi++] = y09 + x09 | 0;
      out[oi++] = y10 + x10 | 0;
      out[oi++] = y11 + x11 | 0;
      out[oi++] = y12 + x12 | 0;
      out[oi++] = y13 + x13 | 0;
      out[oi++] = y14 + x14 | 0;
      out[oi++] = y15 + x15 | 0;
    }
    function hsalsa(s, k, i, o32) {
      let x00 = s[0], x01 = k[0], x02 = k[1], x03 = k[2], x04 = k[3], x05 = s[1], x06 = i[0], x07 = i[1], x08 = i[2], x09 = i[3], x10 = s[2], x11 = k[4], x12 = k[5], x13 = k[6], x14 = k[7], x15 = s[3];
      for (let r2 = 0; r2 < 20; r2 += 2) {
        x04 ^= rotl(x00 + x12 | 0, 7);
        x08 ^= rotl(x04 + x00 | 0, 9);
        x12 ^= rotl(x08 + x04 | 0, 13);
        x00 ^= rotl(x12 + x08 | 0, 18);
        x09 ^= rotl(x05 + x01 | 0, 7);
        x13 ^= rotl(x09 + x05 | 0, 9);
        x01 ^= rotl(x13 + x09 | 0, 13);
        x05 ^= rotl(x01 + x13 | 0, 18);
        x14 ^= rotl(x10 + x06 | 0, 7);
        x02 ^= rotl(x14 + x10 | 0, 9);
        x06 ^= rotl(x02 + x14 | 0, 13);
        x10 ^= rotl(x06 + x02 | 0, 18);
        x03 ^= rotl(x15 + x11 | 0, 7);
        x07 ^= rotl(x03 + x15 | 0, 9);
        x11 ^= rotl(x07 + x03 | 0, 13);
        x15 ^= rotl(x11 + x07 | 0, 18);
        x01 ^= rotl(x00 + x03 | 0, 7);
        x02 ^= rotl(x01 + x00 | 0, 9);
        x03 ^= rotl(x02 + x01 | 0, 13);
        x00 ^= rotl(x03 + x02 | 0, 18);
        x06 ^= rotl(x05 + x04 | 0, 7);
        x07 ^= rotl(x06 + x05 | 0, 9);
        x04 ^= rotl(x07 + x06 | 0, 13);
        x05 ^= rotl(x04 + x07 | 0, 18);
        x11 ^= rotl(x10 + x09 | 0, 7);
        x08 ^= rotl(x11 + x10 | 0, 9);
        x09 ^= rotl(x08 + x11 | 0, 13);
        x10 ^= rotl(x09 + x08 | 0, 18);
        x12 ^= rotl(x15 + x14 | 0, 7);
        x13 ^= rotl(x12 + x15 | 0, 9);
        x14 ^= rotl(x13 + x12 | 0, 13);
        x15 ^= rotl(x14 + x13 | 0, 18);
      }
      let oi = 0;
      o32[oi++] = x00;
      o32[oi++] = x05;
      o32[oi++] = x10;
      o32[oi++] = x15;
      o32[oi++] = x06;
      o32[oi++] = x07;
      o32[oi++] = x08;
      o32[oi++] = x09;
    }
    const xsalsa20 = /* @__PURE__ */ createCipher(salsaCore, {
      counterRight: true,
      extendNonceFn: hsalsa
    });
    const xsalsa20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (key, nonce) => {
      return {
        encrypt(plaintext, output2) {
          output2 = getOutput(plaintext.length + 32, output2, false);
          const authKey = output2.subarray(0, 32);
          const ciphPlaintext = output2.subarray(32);
          output2.set(plaintext, 32);
          clean$1(authKey);
          xsalsa20(key, nonce, output2, output2);
          const tag = poly1305(ciphPlaintext, authKey);
          output2.set(tag, 16);
          clean$1(output2.subarray(0, 16), tag);
          return output2.subarray(16);
        },
        decrypt(ciphertext, output2) {
          abytes$1(ciphertext);
          output2 = getOutput(ciphertext.length + 32, output2, false);
          const tmp = output2.subarray(0, 32);
          const passedTag = output2.subarray(32, 48);
          const ciphPlaintext = output2.subarray(48);
          output2.set(ciphertext, 32);
          clean$1(tmp);
          const authKey = xsalsa20(key, nonce, tmp, tmp);
          const tag = poly1305(ciphPlaintext, authKey);
          if (!equalBytes(passedTag, tag))
            throw new Error("invalid tag");
          xsalsa20(key, nonce, output2.subarray(16), output2.subarray(16));
          clean$1(tmp, passedTag, tag);
          return ciphPlaintext;
        }
      };
    });
    const crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    function isBytes$1(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber$1(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes$1(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    const swap8IfBE = isLE ? (n) => n : (n) => byteSwap(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    const swap32IfBE = isLE ? (u) => u : byteSwap32;
    const hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n2;
      }
      return array2;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      abytes(data2);
      return data2;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    class Hash {
    }
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function randomBytes(bytesLength = 32) {
      if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
        return crypto$1.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto$1 && typeof crypto$1.randomBytes === "function") {
        return Uint8Array.from(crypto$1.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    function setBigUint64(view, byteOffset, value, isLE2) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE2);
      const _32n2 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n2 & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE2 ? 4 : 0;
      const l = isLE2 ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE2);
      view.setUint32(byteOffset + l, wl, isLE2);
    }
    function Chi(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    class HashMD extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data2) {
        aexists(this);
        data2 = toBytes(data2);
        abytes(data2);
        const { view, buffer, blockLen } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data2);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data2.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        clean(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    }
    const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
    const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    const _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    const shrSH = (h, _l, s) => h >>> s;
    const shrSL = (h, l, s) => h << 32 - s | l >>> s;
    const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    const SHA256_K = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    class SHA256 extends HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        clean(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        clean(this.buffer);
      }
    }
    const K512 = /* @__PURE__ */ (() => split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
    const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
    const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    class SHA512 extends HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = SHA512_IV[0] | 0;
        this.Al = SHA512_IV[1] | 0;
        this.Bh = SHA512_IV[2] | 0;
        this.Bl = SHA512_IV[3] | 0;
        this.Ch = SHA512_IV[4] | 0;
        this.Cl = SHA512_IV[5] | 0;
        this.Dh = SHA512_IV[6] | 0;
        this.Dl = SHA512_IV[7] | 0;
        this.Eh = SHA512_IV[8] | 0;
        this.El = SHA512_IV[9] | 0;
        this.Fh = SHA512_IV[10] | 0;
        this.Fl = SHA512_IV[11] | 0;
        this.Gh = SHA512_IV[12] | 0;
        this.Gl = SHA512_IV[13] | 0;
        this.Hh = SHA512_IV[14] | 0;
        this.Hl = SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
          const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
          const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
          const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
          const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
          const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = add3L(T1l, sigma0l, MAJl);
          Ah = add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        clean(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        clean(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }
    const sha256 = /* @__PURE__ */ createHasher(() => new SHA256());
    const sha512 = /* @__PURE__ */ createHasher(() => new SHA512());
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const _0n$4 = /* @__PURE__ */ BigInt(0);
    const _1n$5 = /* @__PURE__ */ BigInt(1);
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n$4 : BigInt("0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if (isBytes$1(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    const isPosBig = (n) => typeof n === "bigint" && _0n$4 <= n;
    function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n$4; n >>= _1n$5, len += 1)
        ;
      return len;
    }
    const bitMask = (n) => (_1n$5 << BigInt(n)) - _1n$5;
    function _validateObject(object2, fields, optFields = {}) {
      if (!object2 || typeof object2 !== "object")
        throw new Error("expected valid options object");
      function checkField(fieldName, expectedType, isOpt) {
        const val = object2[fieldName];
        if (isOpt && val === void 0)
          return;
        const current = typeof val;
        if (current !== expectedType || val === null)
          throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
      }
      Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
      Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
    }
    function memoized(fn) {
      const map2 = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map2.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map2.set(arg, computed);
        return computed;
      };
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const _0n$3 = BigInt(0), _1n$4 = BigInt(1), _2n$3 = /* @__PURE__ */ BigInt(2), _3n$1 = /* @__PURE__ */ BigInt(3);
    const _4n = /* @__PURE__ */ BigInt(4), _5n$1 = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);
    const _8n$2 = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n$3 ? result : b + result;
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n$3) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number2, modulo) {
      if (number2 === _0n$3)
        throw new Error("invert: expected non-zero number");
      if (modulo <= _0n$3)
        throw new Error("invert: expected positive modulus, got " + modulo);
      let a = mod(number2, modulo);
      let b = modulo;
      let x = _0n$3, u = _1n$4;
      while (a !== _0n$3) {
        const q = b / a;
        const r2 = b % a;
        const m = x - u * q;
        b = a, a = r2, x = u, u = m;
      }
      const gcd2 = b;
      if (gcd2 !== _1n$4)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function assertIsSquare(Fp2, root, n) {
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
    }
    function sqrt3mod4(Fp2, n) {
      const p1div4 = (Fp2.ORDER + _1n$4) / _4n;
      const root = Fp2.pow(n, p1div4);
      assertIsSquare(Fp2, root, n);
      return root;
    }
    function sqrt5mod8(Fp2, n) {
      const p5div8 = (Fp2.ORDER - _5n$1) / _8n$2;
      const n2 = Fp2.mul(n, _2n$3);
      const v = Fp2.pow(n2, p5div8);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n$3), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      assertIsSquare(Fp2, root, n);
      return root;
    }
    function sqrt9mod16(P) {
      const Fp_ = Field(P);
      const tn = tonelliShanks(P);
      const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
      const c2 = tn(Fp_, c1);
      const c3 = tn(Fp_, Fp_.neg(c1));
      const c4 = (P + _7n) / _16n;
      return (Fp2, n) => {
        let tv1 = Fp2.pow(n, c4);
        let tv2 = Fp2.mul(tv1, c1);
        const tv3 = Fp2.mul(tv1, c2);
        const tv4 = Fp2.mul(tv1, c3);
        const e1 = Fp2.eql(Fp2.sqr(tv2), n);
        const e2 = Fp2.eql(Fp2.sqr(tv3), n);
        tv1 = Fp2.cmov(tv1, tv2, e1);
        tv2 = Fp2.cmov(tv4, tv3, e2);
        const e3 = Fp2.eql(Fp2.sqr(tv2), n);
        const root = Fp2.cmov(tv1, tv2, e3);
        assertIsSquare(Fp2, root, n);
        return root;
      };
    }
    function tonelliShanks(P) {
      if (P < _3n$1)
        throw new Error("sqrt is not defined for small field");
      let Q = P - _1n$4;
      let S = 0;
      while (Q % _2n$3 === _0n$3) {
        Q /= _2n$3;
        S++;
      }
      let Z = _2n$3;
      const _Fp = Field(P);
      while (FpLegendre(_Fp, Z) === 1) {
        if (Z++ > 1e3)
          throw new Error("Cannot find square root: probably non-prime P");
      }
      if (S === 1)
        return sqrt3mod4;
      let cc = _Fp.pow(Z, Q);
      const Q1div2 = (Q + _1n$4) / _2n$3;
      return function tonelliSlow(Fp2, n) {
        if (Fp2.is0(n))
          return n;
        if (FpLegendre(Fp2, n) !== 1)
          throw new Error("Cannot find square root");
        let M = S;
        let c = Fp2.mul(Fp2.ONE, cc);
        let t = Fp2.pow(n, Q);
        let R = Fp2.pow(n, Q1div2);
        while (!Fp2.eql(t, Fp2.ONE)) {
          if (Fp2.is0(t))
            return Fp2.ZERO;
          let i = 1;
          let t_tmp = Fp2.sqr(t);
          while (!Fp2.eql(t_tmp, Fp2.ONE)) {
            i++;
            t_tmp = Fp2.sqr(t_tmp);
            if (i === M)
              throw new Error("Cannot find square root");
          }
          const exponent = _1n$4 << BigInt(M - i - 1);
          const b = Fp2.pow(c, exponent);
          M = i;
          c = Fp2.sqr(b);
          t = Fp2.mul(t, c);
          R = Fp2.mul(R, b);
        }
        return R;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n$1)
        return sqrt3mod4;
      if (P % _8n$2 === _5n$1)
        return sqrt5mod8;
      if (P % _16n === _9n)
        return sqrt9mod16(P);
      return tonelliShanks(P);
    }
    const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$4) === _1n$4;
    const FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
      };
      const opts = FIELD_FIELDS.reduce((map2, val) => {
        map2[val] = "function";
        return map2;
      }, initial);
      _validateObject(field, opts);
      return field;
    }
    function FpPow(Fp2, num, power) {
      if (power < _0n$3)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n$3)
        return Fp2.ONE;
      if (power === _1n$4)
        return num;
      let p = Fp2.ONE;
      let d = num;
      while (power > _0n$3) {
        if (power & _1n$4)
          p = Fp2.mul(p, d);
        d = Fp2.sqr(d);
        power >>= _1n$4;
      }
      return p;
    }
    function FpInvertBatch(Fp2, nums, passZero = false) {
      const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
      const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp2.is0(num))
          return acc;
        inverted[i] = acc;
        return Fp2.mul(acc, num);
      }, Fp2.ONE);
      const invertedAcc = Fp2.inv(multipliedAcc);
      nums.reduceRight((acc, num, i) => {
        if (Fp2.is0(num))
          return acc;
        inverted[i] = Fp2.mul(acc, inverted[i]);
        return Fp2.mul(acc, num);
      }, invertedAcc);
      return inverted;
    }
    function FpLegendre(Fp2, n) {
      const p1mod2 = (Fp2.ORDER - _1n$4) / _2n$3;
      const powered = Fp2.pow(n, p1mod2);
      const yes = Fp2.eql(powered, Fp2.ONE);
      const zero = Fp2.eql(powered, Fp2.ZERO);
      const no2 = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
      if (!yes && !zero && !no2)
        throw new Error("invalid Legendre symbol result");
      return yes ? 1 : zero ? 0 : -1;
    }
    function nLength(n, nBitLength) {
      if (nBitLength !== void 0)
        anumber$1(nBitLength);
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLenOrOpts, isLE2 = false, opts = {}) {
      if (ORDER <= _0n$3)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      let _sqrt = void 0;
      let modOnDecode = false;
      let allowedLengths = void 0;
      if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
        if (opts.sqrt || isLE2)
          throw new Error("cannot specify opts in two arguments");
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
          _nbitLength = _opts.BITS;
        if (_opts.sqrt)
          _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === "boolean")
          isLE2 = _opts.isLE;
        if (typeof _opts.modOnDecode === "boolean")
          modOnDecode = _opts.modOnDecode;
        allowedLengths = _opts.allowedLengths;
      } else {
        if (typeof bitLenOrOpts === "number")
          _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
          _sqrt = opts.sqrt;
      }
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        isLE: isLE2,
        BITS,
        BYTES,
        MASK: bitMask(BITS),
        ZERO: _0n$3,
        ONE: _1n$4,
        allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num);
          return _0n$3 <= num && num < ORDER;
        },
        is0: (num) => num === _0n$3,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n$4) === _1n$4,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt || ((n) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f, n);
        }),
        toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
        fromBytes: (bytes, skipValidation = true) => {
          if (allowedLengths) {
            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
              throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
            }
            const padded = new Uint8Array(BYTES);
            padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);
            bytes = padded;
          }
          if (bytes.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
          let scalar = isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
          if (modOnDecode)
            scalar = mod(scalar, ORDER);
          if (!skipValidation) {
            if (!f.isValid(scalar))
              throw new Error("invalid field element: outside of range 0..ORDER");
          }
          return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => c ? b : a
      });
      return Object.freeze(f);
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const _0n$2 = BigInt(0);
    const _1n$3 = BigInt(1);
    function negateCt(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function normalizeZ(c, points) {
      const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
      return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
    }
    function calcWOpts(W, scalarBits) {
      validateW(W, scalarBits);
      const windows = Math.ceil(scalarBits / W) + 1;
      const windowSize = 2 ** (W - 1);
      const maxNumber = 2 ** W;
      const mask = bitMask(W);
      const shiftBy = BigInt(W);
      return { windows, windowSize, mask, maxNumber, shiftBy };
    }
    function calcOffsets(n, window2, wOpts) {
      const { windowSize, mask, maxNumber, shiftBy } = wOpts;
      let wbits = Number(n & mask);
      let nextN = n >> shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        nextN += _1n$3;
      }
      const offsetStart = window2 * windowSize;
      const offset = offsetStart + Math.abs(wbits) - 1;
      const isZero = wbits === 0;
      const isNeg = wbits < 0;
      const isNegF = window2 % 2 !== 0;
      const offsetF = offsetStart;
      return { nextN, offset, isZero, isNeg, isNegF, offsetF };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p, i) => {
        if (!(p instanceof c))
          throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s))
          throw new Error("invalid scalar at index " + i);
      });
    }
    const pointPrecomputes = /* @__PURE__ */ new WeakMap();
    const pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function assert0(n) {
      if (n !== _0n$2)
        throw new Error("invalid wNAF");
    }
    class wNAF {
      // Parametrized with a given Point class (not individual point)
      constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n$2) {
          if (n & _1n$3)
            p = p.add(d);
          d = d.double();
          n >>= _1n$3;
        }
        return p;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        if (!this.Fn.isValid(n))
          throw new Error("invalid scalar");
        let p = this.ZERO;
        let f = this.BASE;
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n);
        return { p, f };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n$2)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      }
      getPrecomputes(W, point, transform2) {
        let comp = pointPrecomputes.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W);
          if (W !== 1) {
            if (typeof transform2 === "function")
              comp = transform2(comp);
            pointPrecomputes.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform2) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform2), scalar);
      }
      unsafe(point, scalar, transform2, prev) {
        const W = getW(point);
        if (W === 1)
          return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform2), scalar, prev);
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      const plength = points.length;
      const slength = scalars.length;
      if (plength !== slength)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = bitLen(BigInt(plength));
      let windowSize = 1;
      if (wbits > 12)
        windowSize = wbits - 3;
      else if (wbits > 4)
        windowSize = wbits - 2;
      else if (wbits > 0)
        windowSize = 2;
      const MASK = bitMask(windowSize);
      const buckets = new Array(Number(MASK) + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
          const scalar = scalars[j];
          const wbits2 = Number(scalar >> BigInt(i) & MASK);
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
          for (let j = 0; j < windowSize; j++)
            sum = sum.double();
      }
      return sum;
    }
    function createField(order, field) {
      if (field) {
        if (field.ORDER !== order)
          throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        validateField(field);
        return field;
      } else {
        return Field(order);
      }
    }
    function _createCurveFields(type, CURVE, curveOpts = {}) {
      if (!CURVE || typeof CURVE !== "object")
        throw new Error(`expected valid ${type} CURVE object`);
      for (const p of ["p", "n", "h"]) {
        const val = CURVE[p];
        if (!(typeof val === "bigint" && val > _0n$2))
          throw new Error(`CURVE.${p} must be positive bigint`);
      }
      const Fp2 = createField(CURVE.p, curveOpts.Fp);
      const Fn = createField(CURVE.n, curveOpts.Fn);
      const _b = "d";
      const params = ["Gx", "Gy", "a", _b];
      for (const p of params) {
        if (!Fp2.isValid(CURVE[p]))
          throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
      }
      return { Fp: Fp2, Fn };
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const _0n$1 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = BigInt(2), _8n$1 = BigInt(8);
    function isEdValidXY(Fp2, CURVE, x, y) {
      const x2 = Fp2.sqr(x);
      const y2 = Fp2.sqr(y);
      const left = Fp2.add(Fp2.mul(CURVE.a, x2), y2);
      const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x2, y2)));
      return Fp2.eql(left, right);
    }
    function edwards(CURVE, curveOpts = {}) {
      const { Fp: Fp2, Fn } = _createCurveFields("edwards", CURVE, curveOpts);
      const { h: cofactor, n: CURVE_ORDER } = CURVE;
      _validateObject(curveOpts, {}, { uvRatio: "function" });
      const MASK = _2n$2 << BigInt(Fn.BYTES * 8) - _1n$2;
      const modP = (n) => Fp2.create(n);
      const uvRatio2 = curveOpts.uvRatio || ((u, v) => {
        try {
          return { isValid: true, value: Fp2.sqrt(Fp2.div(u, v)) };
        } catch (e) {
          return { isValid: false, value: _0n$1 };
        }
      });
      if (!isEdValidXY(Fp2, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      function acoord(title, n, banZero = false) {
        const min = banZero ? _1n$2 : _0n$1;
        aInRange("coordinate " + title, n, min, MASK);
        return n;
      }
      function aextpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ExtendedPoint expected");
      }
      const toAffineMemo = memoized((p, iz) => {
        const { X: X2, Y, Z } = p;
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? _8n$1 : Fp2.inv(Z);
        const x = modP(X2 * iz);
        const y = modP(Y * iz);
        const zz = Fp2.mul(Z, iz);
        if (is0)
          return { x: _0n$1, y: _1n$2 };
        if (zz !== _1n$2)
          throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = memoized((p) => {
        const { a, d } = CURVE;
        if (p.is0())
          throw new Error("bad point: ZERO");
        const { X: X2, Y, Z, T } = p;
        const X22 = modP(X2 * X2);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X22 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X22 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X2 * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
        return true;
      });
      class Point {
        constructor(X2, Y, Z, T) {
          this.X = acoord("x", X2);
          this.Y = acoord("y", Y);
          this.Z = acoord("z", Z, true);
          this.T = acoord("t", T);
          Object.freeze(this);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        // TODO: remove
        get ex() {
          return this.X;
        }
        get ey() {
          return this.Y;
        }
        get ez() {
          return this.Z;
        }
        get et() {
          return this.T;
        }
        static normalizeZ(points) {
          return normalizeZ(Point, points);
        }
        static msm(points, scalars) {
          return pippenger(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        static fromAffine(p) {
          if (p instanceof Point)
            throw new Error("extended point not allowed");
          const { x, y } = p || {};
          acoord("x", x);
          acoord("y", y);
          return new Point(x, y, _1n$2, modP(x * y));
        }
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_2n$2);
          return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
          assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
          aextpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const X1Z2 = modP(X1 * Z2);
          const X2Z1 = modP(X2 * Z1);
          const Y1Z2 = modP(Y1 * Z2);
          const Y2Z1 = modP(Y2 * Z1);
          return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        negate() {
          return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
          const { a } = CURVE;
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const A = modP(X1 * X1);
          const B = modP(Y1 * Y1);
          const C = modP(_2n$2 * modP(Z1 * Z1));
          const D = modP(a * A);
          const x1y1 = X1 + Y1;
          const E = modP(modP(x1y1 * x1y1) - A - B);
          const G = D + B;
          const F = G - C;
          const H = D - B;
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
          aextpoint(other);
          const { a, d } = CURVE;
          const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
          const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
          const A = modP(X1 * X2);
          const B = modP(Y1 * Y2);
          const C = modP(T1 * d * T2);
          const D = modP(Z1 * Z2);
          const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
          const F = D - C;
          const G = D + C;
          const H = modP(B - a * A);
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
          const n = scalar;
          aInRange("scalar", n, _1n$2, CURVE_ORDER);
          const { p, f } = wnaf.cached(this, n, (p2) => normalizeZ(Point, p2));
          return normalizeZ(Point, [p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
          const n = scalar;
          aInRange("scalar", n, _0n$1, CURVE_ORDER);
          if (n === _0n$1)
            return Point.ZERO;
          if (this.is0() || n === _1n$2)
            return this;
          return wnaf.unsafe(this, n, (p) => normalizeZ(Point, p), acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
          return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
          if (cofactor === _1n$2)
            return this;
          return this.multiplyUnsafe(cofactor);
        }
        static fromBytes(bytes, zip215 = false) {
          abytes(bytes);
          return Point.fromHex(bytes, zip215);
        }
        // Converts hash string or Uint8Array to Point.
        // Uses algo from RFC8032 5.1.3.
        static fromHex(hex, zip215 = false) {
          const { d, a } = CURVE;
          const len = Fp2.BYTES;
          hex = ensureBytes("pointHex", hex, len);
          abool("zip215", zip215);
          const normed = hex.slice();
          const lastByte = hex[len - 1];
          normed[len - 1] = lastByte & -129;
          const y = bytesToNumberLE(normed);
          const max = zip215 ? MASK : Fp2.ORDER;
          aInRange("pointHex.y", y, _0n$1, max);
          const y2 = modP(y * y);
          const u = modP(y2 - _1n$2);
          const v = modP(d * y2 - a);
          let { isValid, value: x } = uvRatio2(u, v);
          if (!isValid)
            throw new Error("Point.fromHex: invalid y coordinate");
          const isXOdd = (x & _1n$2) === _1n$2;
          const isLastByteOdd = (lastByte & 128) !== 0;
          if (!zip215 && x === _0n$1 && isLastByteOdd)
            throw new Error("Point.fromHex: x=0 and x_0=1");
          if (isLastByteOdd !== isXOdd)
            x = modP(-x);
          return Point.fromAffine({ x, y });
        }
        toBytes() {
          const { x, y } = this.toAffine();
          const bytes = numberToBytesLE(y, Fp2.BYTES);
          bytes[bytes.length - 1] |= x & _1n$2 ? 128 : 0;
          return bytes;
        }
        /** @deprecated use `toBytes` */
        toRawBytes() {
          return this.toBytes();
        }
        toHex() {
          return bytesToHex(this.toBytes());
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$2, modP(CURVE.Gx * CURVE.Gy));
      Point.ZERO = new Point(_0n$1, _1n$2, _1n$2, _0n$1);
      Point.Fp = Fp2;
      Point.Fn = Fn;
      const wnaf = new wNAF(Point, Fn.BYTES * 8);
      return Point;
    }
    function eddsa(Point, cHash, eddsaOpts) {
      if (typeof cHash !== "function")
        throw new Error('"hash" function param is required');
      _validateObject(eddsaOpts, {}, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
      });
      const { prehash } = eddsaOpts;
      const { BASE: G, Fp: Fp2, Fn } = Point;
      const CURVE_ORDER = Fn.ORDER;
      const randomBytes_ = eddsaOpts.randomBytes || randomBytes;
      const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
      const domain = eddsaOpts.domain || ((data2, ctx, phflag) => {
        abool("phflag", phflag);
        if (ctx.length || phflag)
          throw new Error("Contexts/pre-hash are not supported");
        return data2;
      });
      function modN(a) {
        return Fn.create(a);
      }
      function modN_LE(hash) {
        return modN(bytesToNumberLE(hash));
      }
      function getPrivateScalar(key) {
        const len = Fp2.BYTES;
        key = ensureBytes("private key", key, len);
        const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes2(hashed.slice(0, len));
        const prefix = hashed.slice(len, 2 * len);
        const scalar = modN_LE(head);
        return { head, prefix, scalar };
      }
      function getExtendedPublicKey(secretKey) {
        const { head, prefix, scalar } = getPrivateScalar(secretKey);
        const point = G.multiply(scalar);
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
      }
      function getPublicKey(secretKey) {
        return getExtendedPublicKey(secretKey).pointBytes;
      }
      function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = concatBytes(...msgs);
        return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
      }
      function sign2(msg, secretKey, options = {}) {
        msg = ensureBytes("message", msg);
        if (prehash)
          msg = prehash(msg);
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
        const r2 = hashDomainToScalar(options.context, prefix, msg);
        const R = G.multiply(r2).toBytes();
        const k = hashDomainToScalar(options.context, R, pointBytes, msg);
        const s = modN(r2 + k * scalar);
        aInRange("signature.s", s, _0n$1, CURVE_ORDER);
        const L = Fp2.BYTES;
        const res = concatBytes(R, numberToBytesLE(s, L));
        return ensureBytes("result", res, L * 2);
      }
      const verifyOpts = { zip215: true };
      function verify2(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = Fp2.BYTES;
        sig = ensureBytes("signature", sig, 2 * len);
        msg = ensureBytes("message", msg);
        publicKey = ensureBytes("publicKey", publicKey, len);
        if (zip215 !== void 0)
          abool("zip215", zip215);
        if (prehash)
          msg = prehash(msg);
        const s = bytesToNumberLE(sig.slice(len, 2 * len));
        let A, R, SB;
        try {
          A = Point.fromHex(publicKey, zip215);
          R = Point.fromHex(sig.slice(0, len), zip215);
          SB = G.multiplyUnsafe(s);
        } catch (error2) {
          return false;
        }
        if (!zip215 && A.isSmallOrder())
          return false;
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        return RkA.subtract(SB).clearCofactor().is0();
      }
      G.precompute(8);
      const size = Fp2.BYTES;
      const lengths = {
        secret: size,
        public: size,
        signature: 2 * size,
        seed: size
      };
      function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return seed;
      }
      const utils2 = {
        getExtendedPublicKey,
        /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        randomPrivateKey: randomSecretKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         *
         * There is NO `fromMontgomery`:
         * - There are 2 valid ed25519 points for every x25519, with flipped coordinate
         * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*
         *   accepts inputs on the quadratic twist, which can't be moved to ed25519
         */
        toMontgomery(publicKey) {
          const { y } = Point.fromBytes(publicKey);
          const is25519 = size === 32;
          if (!is25519 && size !== 57)
            throw new Error("only defined for 25519 and 448");
          const u = is25519 ? Fp2.div(_1n$2 + y, _1n$2 - y) : Fp2.div(y - _1n$2, y + _1n$2);
          return Fp2.toBytes(u);
        },
        toMontgomeryPriv(privateKey) {
          abytes(privateKey, size);
          const hashed = cHash(privateKey.subarray(0, size));
          return adjustScalarBytes2(hashed).subarray(0, size);
        },
        /**
         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
         * values. This slows down first getPublicKey() by milliseconds (see Speed section),
         * but allows to speed-up subsequent getPublicKey() calls up to 20x.
         * @param windowSize 2, 4, 8, 16
         */
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      function keygen(seed) {
        const secretKey = utils2.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isValidSecretKey(key) {
        try {
          return !!Fn.fromBytes(key, false);
        } catch (error2) {
          return false;
        }
      }
      function isValidPublicKey(key, zip215) {
        try {
          return !!Point.fromBytes(key, zip215);
        } catch (error2) {
          return false;
        }
      }
      return Object.freeze({
        keygen,
        getPublicKey,
        sign: sign2,
        verify: verify2,
        utils: utils2,
        Point,
        info: { type: "edwards", lengths }
      });
    }
    function _eddsa_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp2 = c.Fp;
      const Fn = Field(CURVE.n, c.nBitLength, true);
      const curveOpts = { Fp: Fp2, Fn, uvRatio: c.uvRatio };
      const eddsaOpts = {
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve
      };
      return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
    }
    function _eddsa_new_output_to_legacy(c, eddsa2) {
      const legacy = Object.assign({}, eddsa2, { ExtendedPoint: eddsa2.Point, CURVE: c });
      return legacy;
    }
    function twistedEdwards(c) {
      const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
      const Point = edwards(CURVE, curveOpts);
      const EDDSA = eddsa(Point, hash, eddsaOpts);
      return _eddsa_new_output_to_legacy(c, EDDSA);
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const _0n = BigInt(0);
    const _1n$1 = BigInt(1);
    const _2n$1 = BigInt(2);
    function validateOpts(curve) {
      _validateObject(curve, {
        adjustScalarBytes: "function",
        powPminus2: "function"
      });
      return Object.freeze({ ...curve });
    }
    function montgomery(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { P, type, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand } = CURVE;
      const is25519 = type === "x25519";
      if (!is25519 && type !== "x448")
        throw new Error("invalid type");
      const randomBytes_ = rand || randomBytes;
      const montgomeryBits = is25519 ? 255 : 448;
      const fieldLen = is25519 ? 32 : 56;
      const Gu = is25519 ? BigInt(9) : BigInt(5);
      const a24 = is25519 ? BigInt(121665) : BigInt(39081);
      const minScalar = is25519 ? _2n$1 ** BigInt(254) : _2n$1 ** BigInt(447);
      const maxAdded = is25519 ? BigInt(8) * _2n$1 ** BigInt(251) - _1n$1 : BigInt(4) * _2n$1 ** BigInt(445) - _1n$1;
      const maxScalar = minScalar + maxAdded + _1n$1;
      const modP = (n) => mod(n, P);
      const GuBytes = encodeU(Gu);
      function encodeU(u) {
        return numberToBytesLE(modP(u), fieldLen);
      }
      function decodeU(u) {
        const _u = ensureBytes("u coordinate", u, fieldLen);
        if (is25519)
          _u[31] &= 127;
        return modP(bytesToNumberLE(_u));
      }
      function decodeScalar(scalar) {
        return bytesToNumberLE(adjustScalarBytes2(ensureBytes("scalar", scalar, fieldLen)));
      }
      function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        if (pu === _0n)
          throw new Error("invalid private or public key received");
        return encodeU(pu);
      }
      function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
      }
      function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return { x_2, x_3 };
      }
      function montgomeryLadder(u, scalar) {
        aInRange("u", u, _0n, P);
        aInRange("scalar", scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n$1;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n$1;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
          const k_t = k >> t & _1n$1;
          swap ^= k_t;
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          swap = k_t;
          const A = x_2 + z_2;
          const AA = modP(A * A);
          const B = x_2 - z_2;
          const BB = modP(B * B);
          const E = AA - BB;
          const C = x_3 + z_3;
          const D = x_3 - z_3;
          const DA = modP(D * A);
          const CB = modP(C * B);
          const dacb = DA + CB;
          const da_cb = DA - CB;
          x_3 = modP(dacb * dacb);
          z_3 = modP(x_1 * modP(da_cb * da_cb));
          x_2 = modP(AA * BB);
          z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2);
        return modP(x_2 * z2);
      }
      const randomSecretKey = (seed = randomBytes_(fieldLen)) => seed;
      const utils2 = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey
      };
      function keygen(seed) {
        const secretKey = utils2.randomSecretKey(seed);
        return { secretKey, publicKey: scalarMultBase(secretKey) };
      }
      const lengths = {
        secret: fieldLen,
        public: fieldLen,
        seed: fieldLen
      };
      return {
        keygen,
        getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey) => scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils: utils2,
        GuBytes: GuBytes.slice(),
        info: { type: "montgomery", lengths }
      };
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    BigInt(0);
    const _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
    const _5n = BigInt(5), _8n = BigInt(8);
    const ed25519_CURVE = {
      p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
      n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
      h: _8n,
      a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
      d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
      Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
      Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
    };
    function ed25519_pow_2_252_3(x) {
      const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
      const P = ed25519_CURVE.p;
      const x2 = x * x % P;
      const b2 = x2 * x % P;
      const b4 = pow2(b2, _2n, P) * b2 % P;
      const b5 = pow2(b4, _1n, P) * x % P;
      const b10 = pow2(b5, _5n, P) * b5 % P;
      const b20 = pow2(b10, _10n, P) * b10 % P;
      const b40 = pow2(b20, _20n, P) * b20 % P;
      const b80 = pow2(b40, _40n, P) * b40 % P;
      const b160 = pow2(b80, _80n, P) * b80 % P;
      const b240 = pow2(b160, _80n, P) * b80 % P;
      const b250 = pow2(b240, _10n, P) * b10 % P;
      const pow_p_5_8 = pow2(b250, _2n, P) * x % P;
      return { pow_p_5_8, b2 };
    }
    function adjustScalarBytes(bytes) {
      bytes[0] &= 248;
      bytes[31] &= 127;
      bytes[31] |= 64;
      return bytes;
    }
    const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    function uvRatio(u, v) {
      const P = ed25519_CURVE.p;
      const v3 = mod(v * v * v, P);
      const v7 = mod(v3 * v3 * v, P);
      const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
      let x = mod(u * v3 * pow, P);
      const vx2 = mod(v * x * x, P);
      const root1 = x;
      const root2 = mod(x * ED25519_SQRT_M1, P);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === mod(-u, P);
      const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
      if (useRoot1)
        x = root1;
      if (useRoot2 || noRoot)
        x = root2;
      if (isNegativeLE(x, P))
        x = mod(-x, P);
      return { isValid: useRoot1 || useRoot2, value: x };
    }
    const Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();
    const ed25519Defaults = /* @__PURE__ */ (() => ({
      ...ed25519_CURVE,
      Fp,
      hash: sha512,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/√v
      uvRatio
    }))();
    const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
    const x25519 = /* @__PURE__ */ (() => {
      const P = ed25519_CURVE.p;
      return montgomery({
        P,
        type: "x25519",
        powPminus2: (x) => {
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return mod(pow2(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes
      });
    })();
    function G1s(a, b, c, d, x) {
      a = a + b + x | 0;
      d = rotr(d ^ a, 16);
      c = c + d | 0;
      b = rotr(b ^ c, 12);
      return { a, b, c, d };
    }
    function G2s(a, b, c, d, x) {
      a = a + b + x | 0;
      d = rotr(d ^ a, 8);
      c = c + d | 0;
      b = rotr(b ^ c, 7);
      return { a, b, c, d };
    }
    class BLAKE2 extends Hash {
      constructor(blockLen, outputLen) {
        super();
        this.finished = false;
        this.destroyed = false;
        this.length = 0;
        this.pos = 0;
        anumber$1(blockLen);
        anumber$1(outputLen);
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.buffer = new Uint8Array(blockLen);
        this.buffer32 = u32(this.buffer);
      }
      update(data2) {
        aexists(this);
        data2 = toBytes(data2);
        abytes(data2);
        const { blockLen, buffer, buffer32 } = this;
        const len = data2.length;
        const offset = data2.byteOffset;
        const buf = data2.buffer;
        for (let pos = 0; pos < len; ) {
          if (this.pos === blockLen) {
            swap32IfBE(buffer32);
            this.compress(buffer32, 0, false);
            swap32IfBE(buffer32);
            this.pos = 0;
          }
          const take = Math.min(blockLen - this.pos, len - pos);
          const dataOffset = offset + pos;
          if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
            const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
            swap32IfBE(data32);
            for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
              this.length += blockLen;
              this.compress(data32, pos32, false);
            }
            swap32IfBE(data32);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          this.length += take;
          pos += take;
        }
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        const { pos, buffer32 } = this;
        this.finished = true;
        clean(this.buffer.subarray(pos));
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, true);
        swap32IfBE(buffer32);
        const out32 = u32(out);
        this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        const { buffer, length, finished, destroyed, outputLen, pos } = this;
        to || (to = new this.constructor({ dkLen: outputLen }));
        to.set(...this.get());
        to.buffer.set(buffer);
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        to.outputLen = outputLen;
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    }
    function compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
      let j = 0;
      for (let i = 0; i < rounds; i++) {
        ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));
        ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));
        ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));
        ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));
        ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));
        ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));
        ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));
        ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));
        ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));
        ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));
        ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));
        ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));
        ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));
        ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));
        ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));
        ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));
      }
      return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };
    }
    const B3_Flags = {
      CHUNK_START: 1,
      CHUNK_END: 2,
      PARENT: 4,
      ROOT: 8,
      KEYED_HASH: 16,
      DERIVE_KEY_CONTEXT: 32,
      DERIVE_KEY_MATERIAL: 64
    };
    const B3_IV = SHA256_IV.slice();
    const B3_SIGMA = /* @__PURE__ */ (() => {
      const Id = Array.from({ length: 16 }, (_, i) => i);
      const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);
      const res = [];
      for (let i = 0, v = Id; i < 7; i++, v = permute(v))
        res.push(...v);
      return Uint8Array.from(res);
    })();
    class BLAKE3 extends BLAKE2 {
      constructor(opts = {}, flags = 0) {
        super(64, opts.dkLen === void 0 ? 32 : opts.dkLen);
        this.chunkPos = 0;
        this.chunksDone = 0;
        this.flags = 0 | 0;
        this.stack = [];
        this.posOut = 0;
        this.bufferOut32 = new Uint32Array(16);
        this.chunkOut = 0;
        this.enableXOF = true;
        const { key, context } = opts;
        const hasContext = context !== void 0;
        if (key !== void 0) {
          if (hasContext)
            throw new Error('Only "key" or "context" can be specified at same time');
          const k = toBytes(key).slice();
          abytes(k, 32);
          this.IV = u32(k);
          swap32IfBE(this.IV);
          this.flags = flags | B3_Flags.KEYED_HASH;
        } else if (hasContext) {
          const ctx = toBytes(context);
          const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
          this.IV = u32(contextKey);
          swap32IfBE(this.IV);
          this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
        } else {
          this.IV = B3_IV.slice();
          this.flags = flags;
        }
        this.state = this.IV.slice();
        this.bufferOut = u8(this.bufferOut32);
      }
      // Unused
      get() {
        return [];
      }
      set() {
      }
      b2Compress(counter, flags, buf, bufPos = 0) {
        const { state: s, pos } = this;
        const { h, l } = fromBig(BigInt(counter), true);
        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);
        s[0] = v0 ^ v8;
        s[1] = v1 ^ v9;
        s[2] = v2 ^ v10;
        s[3] = v3 ^ v11;
        s[4] = v4 ^ v12;
        s[5] = v5 ^ v13;
        s[6] = v6 ^ v14;
        s[7] = v7 ^ v15;
      }
      compress(buf, bufPos = 0, isLast = false) {
        let flags = this.flags;
        if (!this.chunkPos)
          flags |= B3_Flags.CHUNK_START;
        if (this.chunkPos === 15 || isLast)
          flags |= B3_Flags.CHUNK_END;
        if (!isLast)
          this.pos = this.blockLen;
        this.b2Compress(this.chunksDone, flags, buf, bufPos);
        this.chunkPos += 1;
        if (this.chunkPos === 16 || isLast) {
          let chunk = this.state;
          this.state = this.IV.slice();
          for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
            if (!(last = this.stack.pop()))
              break;
            this.buffer32.set(last, 0);
            this.buffer32.set(chunk, 8);
            this.pos = this.blockLen;
            this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
            chunk = this.state;
            this.state = this.IV.slice();
          }
          this.chunksDone++;
          this.chunkPos = 0;
          this.stack.push(chunk);
        }
        this.pos = 0;
      }
      _cloneInto(to) {
        to = super._cloneInto(to);
        const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
        to.state.set(state.slice());
        to.stack = stack.map((i) => Uint32Array.from(i));
        to.IV.set(IV);
        to.flags = flags;
        to.chunkPos = chunkPos;
        to.chunksDone = chunksDone;
        to.posOut = posOut;
        to.chunkOut = chunkOut;
        to.enableXOF = this.enableXOF;
        to.bufferOut32.set(this.bufferOut32);
        return to;
      }
      destroy() {
        this.destroyed = true;
        clean(this.state, this.buffer32, this.IV, this.bufferOut32);
        clean(...this.stack);
      }
      // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
      b2CompressOut() {
        const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;
        const { h, l } = fromBig(BigInt(this.chunkOut++));
        swap32IfBE(buffer32);
        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);
        out32[0] = v0 ^ v8;
        out32[1] = v1 ^ v9;
        out32[2] = v2 ^ v10;
        out32[3] = v3 ^ v11;
        out32[4] = v4 ^ v12;
        out32[5] = v5 ^ v13;
        out32[6] = v6 ^ v14;
        out32[7] = v7 ^ v15;
        out32[8] = s[0] ^ v8;
        out32[9] = s[1] ^ v9;
        out32[10] = s[2] ^ v10;
        out32[11] = s[3] ^ v11;
        out32[12] = s[4] ^ v12;
        out32[13] = s[5] ^ v13;
        out32[14] = s[6] ^ v14;
        out32[15] = s[7] ^ v15;
        swap32IfBE(buffer32);
        swap32IfBE(out32);
        this.posOut = 0;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        clean(this.buffer.subarray(this.pos));
        let flags = this.flags | B3_Flags.ROOT;
        if (this.stack.length) {
          flags |= B3_Flags.PARENT;
          swap32IfBE(this.buffer32);
          this.compress(this.buffer32, 0, true);
          swap32IfBE(this.buffer32);
          this.chunksDone = 0;
          this.pos = this.blockLen;
        } else {
          flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
        }
        this.flags = flags;
        this.b2CompressOut();
      }
      writeInto(out) {
        aexists(this, false);
        abytes(out);
        this.finish();
        const { blockLen, bufferOut } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.b2CompressOut();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible after digest call");
        return this.writeInto(out);
      }
      xof(bytes) {
        anumber$1(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        aoutput(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.enableXOF = false;
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
    }
    const blake3 = /* @__PURE__ */ createXOFer((opts) => new BLAKE3(opts));
    class PureJSCrypto extends CryptoProvider {
      static async create() {
        return new PureJSCrypto();
      }
      emptyBlake3State() {
        return blake3.create({});
      }
      cloneBlake3State(state) {
        return state.clone();
      }
      blake3HashOnce(data2) {
        return blake3(data2);
      }
      blake3HashOnceWithContext(data2, { context }) {
        return blake3.create({}).update(context).update(data2).digest();
      }
      blake3IncrementalUpdate(state, data2) {
        return state.update(data2);
      }
      blake3DigestForState(state) {
        return state.clone().digest();
      }
      generateNonce(input) {
        return this.blake3HashOnce(input).slice(0, 24);
      }
      generateJsonNonce(material) {
        return this.generateNonce(textEncoder.encode(stableStringify(material)));
      }
      newEd25519SigningKey() {
        return ed25519.utils.randomPrivateKey();
      }
      getSignerID(secret) {
        return `signer_z${base58.encode(ed25519.getPublicKey(base58.decode(secret.substring("signerSecret_z".length))))}`;
      }
      sign(secret, message) {
        const signature = ed25519.sign(textEncoder.encode(stableStringify(message)), base58.decode(secret.substring("signerSecret_z".length)));
        return `signature_z${base58.encode(signature)}`;
      }
      verify(signature, message, id2) {
        return ed25519.verify(base58.decode(signature.substring("signature_z".length)), textEncoder.encode(stableStringify(message)), base58.decode(id2.substring("signer_z".length)));
      }
      newX25519StaticSecret() {
        return x25519.utils.randomPrivateKey();
      }
      getSealerID(secret) {
        return `sealer_z${base58.encode(x25519.getPublicKey(base58.decode(secret.substring("sealerSecret_z".length))))}`;
      }
      encrypt(value, keySecret, nOnceMaterial) {
        const keySecretBytes = base58.decode(keySecret.substring("keySecret_z".length));
        const nOnce = this.generateJsonNonce(nOnceMaterial);
        const plaintext = textEncoder.encode(stableStringify(value));
        const ciphertext = xsalsa20(keySecretBytes, nOnce, plaintext);
        return `encrypted_U${bytesToBase64url(ciphertext)}`;
      }
      decryptRaw(encrypted, keySecret, nOnceMaterial) {
        const keySecretBytes = base58.decode(keySecret.substring("keySecret_z".length));
        const nOnce = this.generateJsonNonce(nOnceMaterial);
        const ciphertext = base64URLtoBytes(encrypted.substring("encrypted_U".length));
        const plaintext = xsalsa20(keySecretBytes, nOnce, ciphertext);
        return textDecoder.decode(plaintext);
      }
      seal({ message, from, to, nOnceMaterial }) {
        const nOnce = this.generateJsonNonce(nOnceMaterial);
        const sealerPub = base58.decode(to.substring("sealer_z".length));
        const senderPriv = base58.decode(from.substring("sealerSecret_z".length));
        const plaintext = textEncoder.encode(stableStringify(message));
        const sharedSecret = x25519.getSharedSecret(senderPriv, sealerPub);
        const sealedBytes = xsalsa20poly1305(sharedSecret, nOnce).encrypt(plaintext);
        return `sealed_U${bytesToBase64url(sealedBytes)}`;
      }
      unseal(sealed, sealer, from, nOnceMaterial) {
        const nOnce = this.generateJsonNonce(nOnceMaterial);
        const sealerPriv = base58.decode(sealer.substring("sealerSecret_z".length));
        const senderPub = base58.decode(from.substring("sealer_z".length));
        const sealedBytes = base64URLtoBytes(sealed.substring("sealed_U".length));
        const sharedSecret = x25519.getSharedSecret(sealerPriv, senderPub);
        const plaintext = xsalsa20poly1305(sharedSecret, nOnce).decrypt(sealedBytes);
        try {
          return JSON.parse(textDecoder.decode(plaintext));
        } catch (e) {
          logger.error("Failed to decrypt/parse sealed message", { err: e });
          return void 0;
        }
      }
    }
    var __defProp = Object.defineProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var zodReExport_exports = {};
    __export(zodReExport_exports, {
      array: () => array,
      base64: () => base64,
      base64url: () => base64url,
      boolean: () => boolean,
      cidrv4: () => cidrv4,
      cidrv6: () => cidrv6,
      cuid: () => cuid,
      cuid2: () => cuid2,
      date: () => date,
      discriminatedUnion: () => discriminatedUnion,
      email: () => email,
      emoji: () => emoji,
      enum: () => _enum,
      int: () => int,
      int32: () => int32,
      ipv4: () => ipv4,
      ipv6: () => ipv6,
      iso: () => iso,
      json: () => json,
      literal: () => literal,
      nanoid: () => nanoid,
      number: () => number,
      object: () => object,
      optional: () => optional,
      strictObject: () => strictObject,
      string: () => string,
      templateLiteral: () => templateLiteral,
      tuple: () => tuple,
      ulid: () => ulid,
      union: () => union,
      url: () => url,
      uuid: () => uuid,
      z: () => z
    });
    function union(options, params) {
      return union$1(options, params);
    }
    function array(element, params) {
      return array$1(element, params);
    }
    function tuple(options, params) {
      return tuple$1(options, params);
    }
    var CoValueBase = class {
      get _owner() {
        const schema = this._raw.group instanceof RawAccount ? RegisteredSchemas["Account"] : RegisteredSchemas["Group"];
        return accessChildById(this, this._raw.group.id, {
          ref: schema,
          optional: false
        });
      }
      /** @private */
      get _loadedAs() {
        const agent = this._raw.core.node.getCurrentAgent();
        if (agent instanceof ControlledAccount) {
          return coValuesCache.get(
            agent.account,
            () => anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(
              agent.account
            )
          );
        }
        return new AnonymousJazzAgent(this._raw.core.node);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(..._args) {
        Object.defineProperty(this, "_instanceID", {
          value: `instance-${Math.random().toString(36).slice(2)}`,
          enumerable: false
        });
      }
      /** @category Internals */
      static fromRaw(raw) {
        return new this({ fromRaw: raw });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      toJSON() {
        return {
          id: this.id,
          type: this._type,
          error: "unknown CoValue class"
        };
      }
      [inspect]() {
        return this.toJSON();
      }
      /** @category Type Helpers */
      castAs(schema) {
        const cl = isCoValueSchema(schema) ? schema.getCoValueClass() : schema;
        if (this.constructor === cl) {
          return this;
        }
        return cl.fromRaw(this._raw);
      }
    };
    var inspect = Symbol.for("nodejs.util.inspect.custom");
    var SchemaInit = "$SchemaInit$";
    var ItemsSym = "$items$";
    var RegisteredSchemas = {};
    var _CoMap = class _CoMap2 extends CoValueBase {
      /** @internal */
      get _schema() {
        return this.constructor._schema;
      }
      /**
       * The timestamp of the creation time of the CoMap
       */
      get _createdAt() {
        return this._raw.earliestTxMadeAt ?? Number.MAX_SAFE_INTEGER;
      }
      /**
       * The timestamp of the last updated time of the CoMap
       */
      get _lastUpdatedAt() {
        return this._raw.latestTxMadeAt;
      }
      /**
       * If property `prop` is a `coField.ref(...)`, you can use `coMaps._refs.prop` to access
       * the `Ref` instead of the potentially loaded/null value.
       *
       * This allows you to always get the ID or load the value manually.
       *
       * @example
       * ```ts
       * person._refs.pet.id; // => ID<Animal>
       * person._refs.pet.value;
       * // => Animal | null
       * const pet = await person._refs.pet.load();
       * ```
       *
       * @category Content
       **/
      get _refs() {
        return makeRefs(
          this,
          (key) => this._raw.get(key),
          () => {
            const keys = this._raw.keys().filter((key) => {
              const descriptor = this.getDescriptor(key);
              return descriptor && descriptor !== "json" && isRefEncoded(descriptor);
            });
            return keys;
          },
          this._loadedAs,
          (key) => this.getDescriptor(key)
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        );
      }
      /** @internal */
      getEditFromRaw(target, rawEdit, descriptor, key) {
        return {
          value: descriptor === "json" ? rawEdit.value : "encoded" in descriptor ? rawEdit.value === null || rawEdit.value === void 0 ? rawEdit.value : descriptor.encoded.decode(rawEdit.value) : accessChildById(target, rawEdit.value, descriptor),
          ref: descriptor !== "json" && isRefEncoded(descriptor) ? new Ref(
            rawEdit.value,
            target._loadedAs,
            descriptor,
            target
          ) : void 0,
          get by() {
            return rawEdit.by && accessChildById(target, rawEdit.by, {
              ref: Account,
              optional: false
            });
          },
          madeAt: rawEdit.at,
          key
        };
      }
      /** @category Collaboration */
      get _edits() {
        const map2 = this;
        return new Proxy(
          {},
          {
            get(_target, key) {
              const rawEdit = map2._raw.lastEditAt(key);
              if (!rawEdit) return void 0;
              const descriptor = map2.getDescriptor(key);
              if (!descriptor) return void 0;
              return {
                ...map2.getEditFromRaw(map2, rawEdit, descriptor, key),
                get all() {
                  return [...map2._raw.editsAt(key)].map(
                    (rawEdit2) => map2.getEditFromRaw(map2, rawEdit2, descriptor, key)
                  );
                }
              };
            },
            ownKeys(_target) {
              return map2._raw.keys();
            },
            getOwnPropertyDescriptor(target, key) {
              return {
                value: Reflect.get(target, key),
                writable: false,
                enumerable: true,
                configurable: true
              };
            }
          }
        );
      }
      /** @internal */
      constructor(options) {
        super();
        if (options) {
          if ("fromRaw" in options) {
            Object.defineProperties(this, {
              id: {
                value: options.fromRaw.id,
                enumerable: false
              },
              _raw: { value: options.fromRaw, enumerable: false }
            });
          } else {
            throw new Error("Invalid CoMap constructor arguments");
          }
        }
        return new Proxy(this, CoMapProxyHandler);
      }
      /**
       * Create a new CoMap with the given initial values and owner.
       *
       * The owner (a Group or Account) determines access rights to the CoMap.
       *
       * The CoMap will immediately be persisted and synced to connected peers.
       *
       * @example
       * ```ts
       * const person = Person.create({
       *   name: "Alice",
       *   age: 42,
       *   pet: cat,
       * }, { owner: friendGroup });
       * ```
       *
       * @category Creation
       **/
      static create(init, options) {
        const instance = new this();
        return instance._createCoMap(init, options);
      }
      /**
       * Return a JSON representation of the `CoMap`
       * @category Content
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      toJSON(_key, processedValues) {
        const result = {
          id: this.id,
          _type: this._type
        };
        for (const key of this._raw.keys()) {
          const tKey = key;
          const descriptor = this.getDescriptor(tKey);
          if (!descriptor) {
            continue;
          }
          if (descriptor == "json" || "encoded" in descriptor) {
            result[key] = this._raw.get(key);
          } else if (isRefEncoded(descriptor)) {
            const id2 = this._raw.get(key);
            if ((processedValues == null ? void 0 : processedValues.includes(id2)) || id2 === this.id) {
              result[key] = { _circular: id2 };
              continue;
            }
            const ref2 = this[tKey];
            if (ref2 && typeof ref2 === "object" && "toJSON" in ref2 && typeof ref2.toJSON === "function") {
              const jsonedRef = ref2.toJSON(tKey, [
                ...processedValues || [],
                this.id
              ]);
              result[key] = jsonedRef;
            }
          } else {
            result[key] = void 0;
          }
        }
        return result;
      }
      [inspect]() {
        return this.toJSON();
      }
      _createCoMap(init, options) {
        const { owner, uniqueness } = parseCoValueCreateOptions(options);
        const raw = this.rawFromInit(init, owner, uniqueness);
        Object.defineProperties(this, {
          id: {
            value: raw.id,
            enumerable: false
          },
          _raw: { value: raw, enumerable: false }
        });
        return this;
      }
      /**
       * Create a new `RawCoMap` from an initialization object
       * @internal
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      rawFromInit(init, owner, uniqueness) {
        const rawOwner = owner._raw;
        const rawInit = {};
        if (init)
          for (const key of Object.keys(init)) {
            const initValue = init[key];
            const descriptor = this.getDescriptor(key);
            if (!descriptor) {
              continue;
            }
            if (descriptor === "json") {
              rawInit[key] = initValue;
            } else if (isRefEncoded(descriptor)) {
              if (initValue) {
                rawInit[key] = initValue.id;
              }
            } else if ("encoded" in descriptor) {
              rawInit[key] = descriptor.encoded.encode(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                initValue
              );
            }
          }
        return rawOwner.createMap(rawInit, null, "private", uniqueness);
      }
      getDescriptor(key) {
        var _a, _b;
        return ((_a = this._schema) == null ? void 0 : _a[key]) || ((_b = this._schema) == null ? void 0 : _b[ItemsSym]);
      }
      /**
       * Declare a Record-like CoMap schema, by extending `CoMap.Record(...)` and passing the value schema using `co`. Keys are always `string`.
       *
       * @example
       * ```ts
       * import { coField, CoMap } from "jazz-tools";
       *
       * class ColorToFruitMap extends CoMap.Record(
       *  coField.ref(Fruit)
       * ) {}
       *
       * // assume we have map: ColorToFruitMap
       * // and strawberry: Fruit
       * map["red"] = strawberry;
       * ```
       *
       * @category Declaration
       */
      static Record(value) {
        var _a, _b;
        class RecordLikeCoMap extends (_b = _CoMap2, _a = ItemsSym, _b) {
          constructor() {
            super(...arguments);
            this[_a] = value;
          }
        }
        return RecordLikeCoMap;
      }
      /**
       * Load a `CoMap` with a given ID, as a given account.
       *
       * `depth` specifies which (if any) fields that reference other CoValues to load as well before resolving.
       * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.
       *
       * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.
       *
       * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.
       *
       * @example
       * ```ts
       * const person = await Person.load(
       *   "co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax",
       *   { pet: {} }
       * );
       * ```
       *
       * @category Subscription & Loading
       */
      static load(id2, options) {
        return loadCoValueWithoutMe(this, id2, options);
      }
      static subscribe(id2, ...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToCoValueWithoutMe(this, id2, options, listener);
      }
      /** @deprecated Use `CoMap.upsertUnique` and `CoMap.loadUnique` instead. */
      static findUnique(unique, ownerID, as) {
        return _CoMap2._findUnique(unique, ownerID, as);
      }
      /** @internal */
      static _findUnique(unique, ownerID, as) {
        as || (as = activeAccountContext.get());
        const header = {
          type: "comap",
          ruleset: {
            type: "ownedByGroup",
            group: ownerID
          },
          meta: null,
          uniqueness: unique
        };
        const crypto2 = as._type === "Anonymous" ? as.node.crypto : as._raw.core.node.crypto;
        return cojsonInternals.idforHeader(header, crypto2);
      }
      /**
       * Given some data, updates an existing CoMap or initialises a new one if none exists.
       *
       * Note: This method respects resolve options, and thus can return `null` if the references cannot be resolved.
       *
       * @example
       * ```ts
       * const activeEvent = await Event.upsertUnique(
       *   sourceData.identifier,
       *   workspace.id,
       *   {
       *     title: sourceData.title,
       *     identifier: sourceData.identifier,
       *     external_id: sourceData._id,
       *   },
       *   workspace
       * );
       * ```
       *
       * @param options The options for creating or loading the CoMap. This includes the intended state of the CoMap, its unique identifier, its owner, and the references to resolve.
       * @returns Either an existing & modified CoMap, or a new initialised CoMap if none exists.
       * @category Subscription & Loading
       */
      static async upsertUnique(options) {
        let mapId = _CoMap2._findUnique(options.unique, options.owner.id);
        let map2 = await loadCoValueWithoutMe(this, mapId, {
          ...options,
          loadAs: options.owner._loadedAs,
          skipRetry: true
        });
        if (!map2) {
          const instance = new this();
          map2 = instance._createCoMap(options.value, {
            owner: options.owner,
            unique: options.unique
          });
        } else {
          map2.applyDiff(options.value);
        }
        return await loadCoValueWithoutMe(this, mapId, {
          ...options,
          loadAs: options.owner._loadedAs,
          skipRetry: true
        });
      }
      /**
       * Loads a CoMap by its unique identifier and owner's ID.
       * @param unique The unique identifier of the CoMap to load.
       * @param ownerID The ID of the owner of the CoMap.
       * @param options Additional options for loading the CoMap.
       * @returns The loaded CoMap, or null if unavailable.
       */
      static loadUnique(unique, ownerID, options) {
        return loadCoValueWithoutMe(
          this,
          _CoMap2._findUnique(unique, ownerID, options == null ? void 0 : options.loadAs),
          { ...options, skipRetry: true }
        );
      }
      /**
       * Given an already loaded `CoMap`, ensure that the specified fields are loaded to the specified depth.
       *
       * Works like `CoMap.load()`, but you don't need to pass the ID or the account to load as again.
       *
       * @category Subscription & Loading
       */
      ensureLoaded(options) {
        return ensureCoValueLoaded(this, options);
      }
      subscribe(...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToExistingCoValue(this, options, listener);
      }
      applyDiff(newValues) {
        for (const key in newValues) {
          if (Object.prototype.hasOwnProperty.call(newValues, key)) {
            const tKey = key;
            const descriptor = this.getDescriptor(key);
            if (!descriptor) continue;
            const newValue = newValues[tKey];
            const currentValue = this[tKey];
            if (descriptor === "json" || "encoded" in descriptor) {
              if (currentValue !== newValue) {
                this[tKey] = newValue;
              }
            } else if (isRefEncoded(descriptor)) {
              const currentId = currentValue == null ? void 0 : currentValue.id;
              const newId = newValue == null ? void 0 : newValue.id;
              if (currentId !== newId) {
                this[tKey] = newValue;
              }
            }
          }
        }
        return this;
      }
      /**
       * Wait for the `CoMap` to be uploaded to the other peers.
       *
       * @category Subscription & Loading
       */
      waitForSync(options) {
        return this._raw.core.waitForSync(options);
      }
    };
    _CoMap.prototype._type = "CoMap";
    var CoMap = _CoMap;
    var CoMapProxyHandler = {
      get(target, key, receiver) {
        if (key === "_schema") {
          return Reflect.get(target, key);
        } else if (key in target) {
          return Reflect.get(target, key, receiver);
        } else {
          if (typeof key !== "string") {
            return void 0;
          }
          const descriptor = target.getDescriptor(key);
          if (!descriptor) {
            return void 0;
          }
          const raw = target._raw.get(key);
          if (descriptor === "json") {
            return raw;
          } else if ("encoded" in descriptor) {
            return raw === void 0 ? void 0 : descriptor.encoded.decode(raw);
          } else if (isRefEncoded(descriptor)) {
            return raw === void 0 || raw === null ? void 0 : accessChildByKey(target, raw, key);
          }
        }
      },
      set(target, key, value, receiver) {
        var _a;
        if (typeof value === "object" && value !== null && SchemaInit in value) {
          (_a = target.constructor)._schema || (_a._schema = {});
          target.constructor._schema[key] = value[SchemaInit];
          return true;
        }
        const descriptor = target.getDescriptor(key);
        if (!descriptor) return false;
        if (typeof key === "string") {
          if (descriptor === "json") {
            target._raw.set(key, value);
          } else if ("encoded" in descriptor) {
            target._raw.set(key, descriptor.encoded.encode(value));
          } else if (isRefEncoded(descriptor)) {
            if (value === void 0) {
              if (descriptor.optional) {
                target._raw.set(key, null);
              } else {
                throw new Error(
                  `Cannot set required reference ${key} to undefined`
                );
              }
            } else if (value == null ? void 0 : value.id) {
              target._raw.set(key, value.id);
            } else {
              throw new Error(
                `Cannot set reference ${key} to a non-CoValue. Got ${value}`
              );
            }
          }
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      },
      defineProperty(target, key, attributes) {
        var _a;
        if ("value" in attributes && typeof attributes.value === "object" && SchemaInit in attributes.value) {
          (_a = target.constructor)._schema || (_a._schema = {});
          target.constructor._schema[key] = attributes.value[SchemaInit];
          return true;
        } else {
          return Reflect.defineProperty(target, key, attributes);
        }
      },
      ownKeys(target) {
        const keys = Reflect.ownKeys(target).filter((k) => k !== ItemsSym);
        for (const key of target._raw.keys()) {
          if (!keys.includes(key)) {
            keys.push(key);
          }
        }
        return keys;
      },
      getOwnPropertyDescriptor(target, key) {
        if (key in target) {
          return Reflect.getOwnPropertyDescriptor(target, key);
        } else {
          const descriptor = target.getDescriptor(key);
          if (descriptor || key in target._raw.latest) {
            return {
              enumerable: true,
              configurable: true,
              writable: true
            };
          }
        }
      },
      has(target, key) {
        const descriptor = target.getDescriptor(key);
        if (target._raw && typeof key === "string" && descriptor) {
          return target._raw.get(key) !== void 0;
        } else {
          return Reflect.has(target, key);
        }
      },
      deleteProperty(target, key) {
        const descriptor = target.getDescriptor(key);
        if (typeof key === "string" && descriptor) {
          target._raw.delete(key);
          return true;
        } else {
          return Reflect.deleteProperty(target, key);
        }
      }
    };
    RegisteredSchemas["CoMap"] = CoMap;
    var _CoList = class _CoList2 extends Array {
      /**
       * Declare a `CoList` by subclassing `CoList.Of(...)` and passing the item schema using `co`.
       *
       * @example
       * ```ts
       * class ColorList extends CoList.Of(
       *   coField.string
       * ) {}
       * class AnimalList extends CoList.Of(
       *   coField.ref(Animal)
       * ) {}
       * ```
       *
       * @category Declaration
       */
      static Of(item) {
        var _a, _b;
        return class CoListOf extends (_b = _CoList2, _a = coField.items, _b) {
          constructor() {
            super(...arguments);
            this[_a] = item;
          }
        };
      }
      /**
       * @ignore
       * @deprecated Use UPPERCASE `CoList.Of` instead! */
      static of(..._args) {
        throw new Error("Can't use Array.of with CoLists");
      }
      /** @internal */
      get _schema() {
        return this.constructor._schema;
      }
      /** @category Collaboration */
      get _owner() {
        return this._raw.group instanceof RawAccount ? anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(
          this._raw.group
        ) : RegisteredSchemas["Group"].fromRaw(this._raw.group);
      }
      /**
       * If a `CoList`'s items are a `coField.ref(...)`, you can use `coList._refs[i]` to access
       * the `Ref` instead of the potentially loaded/null value.
       *
       * This allows you to always get the ID or load the value manually.
       *
       * @example
       * ```ts
       * animals._refs[0].id; // => ID<Animal>
       * animals._refs[0].value;
       * // => Animal | null
       * const animal = await animals._refs[0].load();
       * ```
       *
       * @category Content
       **/
      get _refs() {
        return makeRefs(
          this,
          (idx) => this._raw.get(idx),
          () => Array.from({ length: this._raw.entries().length }, (_, idx) => idx),
          this._loadedAs,
          (_idx) => this._schema[ItemsSym]
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        );
      }
      get _edits() {
        throw new Error("Not implemented");
      }
      get _loadedAs() {
        const agent = this._raw.core.node.getCurrentAgent();
        if (agent instanceof ControlledAccount) {
          return coValuesCache.get(
            agent.account,
            () => anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(
              agent.account
            )
          );
        }
        return new AnonymousJazzAgent(this._raw.core.node);
      }
      static get [Symbol.species]() {
        return Array;
      }
      getItemsDescriptor() {
        var _a;
        return (_a = this._schema) == null ? void 0 : _a[ItemsSym];
      }
      constructor(options) {
        super();
        Object.defineProperty(this, "_instanceID", {
          value: `instance-${Math.random().toString(36).slice(2)}`,
          enumerable: false
        });
        if (options && "fromRaw" in options) {
          Object.defineProperties(this, {
            id: {
              value: options.fromRaw.id,
              enumerable: false
            },
            _raw: { value: options.fromRaw, enumerable: false }
          });
        }
        return new Proxy(this, CoListProxyHandler);
      }
      /**
       * Create a new CoList with the given initial values and owner.
       *
       * The owner (a Group or Account) determines access rights to the CoMap.
       *
       * The CoList will immediately be persisted and synced to connected peers.
       *
       * @example
       * ```ts
       * const colours = ColorList.create(
       *   ["red", "green", "blue"],
       *   { owner: me }
       * );
       * const animals = AnimalList.create(
       *   [cat, dog, fish],
       *   { owner: me }
       * );
       * ```
       *
       * @category Creation
       **/
      static create(items, options) {
        const { owner } = parseCoValueCreateOptions(options);
        const instance = new this({ init: items, owner });
        const raw = owner._raw.createList(
          toRawItems(items, instance._schema[ItemsSym])
        );
        Object.defineProperties(instance, {
          id: {
            value: raw.id,
            enumerable: false
          },
          _raw: { value: raw, enumerable: false }
        });
        return instance;
      }
      push(...items) {
        this._raw.appendItems(
          toRawItems(items, this._schema[ItemsSym]),
          void 0,
          "private"
        );
        return this._raw.entries().length;
      }
      unshift(...items) {
        for (const item of toRawItems(items, this._schema[ItemsSym])) {
          this._raw.prepend(item);
        }
        return this._raw.entries().length;
      }
      pop() {
        const last = this[this.length - 1];
        this._raw.delete(this.length - 1);
        return last;
      }
      shift() {
        const first = this[0];
        this._raw.delete(0);
        return first;
      }
      /**
       * Splice the `CoList` at a given index.
       *
       * @param start - The index to start the splice.
       * @param deleteCount - The number of items to delete.
       * @param items - The items to insert.
       */
      splice(start, deleteCount, ...items) {
        const deleted = this.slice(start, start + deleteCount);
        for (let idxToDelete = start + deleteCount - 1; idxToDelete >= start; idxToDelete--) {
          this._raw.delete(idxToDelete);
        }
        const rawItems = toRawItems(items, this._schema[ItemsSym]);
        if (rawItems.length === 0) {
          return deleted;
        }
        if (rawItems.length === 1) {
          const item = rawItems[0];
          if (item === void 0) return deleted;
          if (start === 0) {
            this._raw.prepend(item);
          } else {
            this._raw.append(item, Math.max(start - 1, 0));
          }
          return deleted;
        }
        if (start === 0) {
          for (let i = rawItems.length - 1; i >= 0; i--) {
            const item = rawItems[i];
            if (item === void 0) continue;
            this._raw.prepend(item);
          }
        } else {
          let appendAfter = Math.max(start - 1, 0);
          for (const item of rawItems) {
            if (item === void 0) continue;
            this._raw.append(item, appendAfter);
            appendAfter++;
          }
        }
        return deleted;
      }
      /**
       * Modify the `CoList` to match another list, where the changes are managed internally.
       *
       * @param result - The resolved list of items.
       */
      applyDiff(result) {
        const current = this._raw.asArray();
        const comparator = isRefEncoded(this._schema[ItemsSym]) ? (aIdx, bIdx) => {
          var _a, _b;
          return ((_a = current[aIdx]) == null ? void 0 : _a.id) === ((_b = result[bIdx]) == null ? void 0 : _b.id);
        } : void 0;
        const patches = [...binExports.calcPatch(current, result, comparator)];
        for (const [from, to, insert] of patches.reverse()) {
          this.splice(from, to - from, ...insert);
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      toJSON(_key, seenAbove) {
        const itemDescriptor = this._schema[ItemsSym];
        if (itemDescriptor === "json") {
          return this._raw.asArray();
        } else if ("encoded" in itemDescriptor) {
          return this._raw.asArray().map((e) => itemDescriptor.encoded.encode(e));
        } else if (isRefEncoded(itemDescriptor)) {
          return this.map(
            (item, idx) => (seenAbove == null ? void 0 : seenAbove.includes(item == null ? void 0 : item.id)) ? { _circular: item.id } : item == null ? void 0 : item.toJSON(idx + "", [
              ...seenAbove || [],
              this.id
            ])
          );
        } else {
          return [];
        }
      }
      [inspect]() {
        return this.toJSON();
      }
      /** @category Internals */
      static fromRaw(raw) {
        return new this({ fromRaw: raw });
      }
      /** @internal */
      static schema(def) {
        this._schema || (this._schema = {});
        Object.assign(this._schema, def);
      }
      /**
       * Load a `CoList` with a given ID, as a given account.
       *
       * `depth` specifies if item CoValue references should be loaded as well before resolving.
       * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.
       *
       * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.
       *
       * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.
       *
       * @example
       * ```ts
       * const animalsWithVets =
       *   await ListOfAnimals.load(
       *     "co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax",
       *     me,
       *     [{ vet: {} }]
       *   );
       * ```
       *
       * @category Subscription & Loading
       */
      static load(id2, options) {
        return loadCoValueWithoutMe(this, id2, options);
      }
      static subscribe(id2, ...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToCoValueWithoutMe(this, id2, options, listener);
      }
      /**
       * Given an already loaded `CoList`, ensure that items are loaded to the specified depth.
       *
       * Works like `CoList.load()`, but you don't need to pass the ID or the account to load as again.
       *
       * @category Subscription & Loading
       */
      ensureLoaded(options) {
        return ensureCoValueLoaded(this, options);
      }
      subscribe(...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToExistingCoValue(this, options, listener);
      }
      /** @category Type Helpers */
      castAs(cl) {
        return cl.fromRaw(this._raw);
      }
      /**
       * Wait for the `CoList` to be uploaded to the other peers.
       *
       * @category Subscription & Loading
       */
      waitForSync(options) {
        return this._raw.core.waitForSync(options);
      }
    };
    _CoList.prototype._type = "CoList";
    var CoList = _CoList;
    function toRawItems(items, itemDescriptor) {
      const rawItems = itemDescriptor === "json" ? items : "encoded" in itemDescriptor ? items == null ? void 0 : items.map((e) => itemDescriptor.encoded.encode(e)) : isRefEncoded(itemDescriptor) ? items == null ? void 0 : items.map((v) => {
        if (!v) return null;
        return v.id;
      }) : (() => {
        throw new Error("Invalid element descriptor");
      })();
      return rawItems;
    }
    var CoListProxyHandler = {
      get(target, key, receiver) {
        if (typeof key === "string" && !isNaN(+key)) {
          const itemDescriptor = target._schema[ItemsSym];
          const rawValue = target._raw.get(Number(key));
          if (itemDescriptor === "json") {
            return rawValue;
          } else if ("encoded" in itemDescriptor) {
            return rawValue === void 0 ? void 0 : itemDescriptor.encoded.decode(rawValue);
          } else if (isRefEncoded(itemDescriptor)) {
            return rawValue === void 0 || rawValue === null ? void 0 : accessChildByKey(target, rawValue, key);
          }
        } else if (key === "length") {
          return target._raw.entries().length;
        } else {
          return Reflect.get(target, key, receiver);
        }
      },
      set(target, key, value, receiver) {
        var _a;
        if (key === ItemsSym && typeof value === "object" && SchemaInit in value) {
          (_a = target.constructor)._schema || (_a._schema = {});
          target.constructor._schema[ItemsSym] = value[SchemaInit];
          return true;
        }
        if (typeof key === "string" && !isNaN(+key)) {
          const itemDescriptor = target._schema[ItemsSym];
          let rawValue;
          if (itemDescriptor === "json") {
            rawValue = value;
          } else if ("encoded" in itemDescriptor) {
            rawValue = itemDescriptor.encoded.encode(value);
          } else if (isRefEncoded(itemDescriptor)) {
            if (value === void 0) {
              if (itemDescriptor.optional) {
                rawValue = null;
              } else {
                throw new Error(
                  `Cannot set required reference ${key} to undefined`
                );
              }
            } else if (value == null ? void 0 : value.id) {
              rawValue = value.id;
            } else {
              throw new Error(
                `Cannot set reference ${key} to a non-CoValue. Got ${value}`
              );
            }
          }
          target._raw.replace(Number(key), rawValue);
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      },
      defineProperty(target, key, descriptor) {
        var _a;
        if (descriptor.value && key === ItemsSym && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
          (_a = target.constructor)._schema || (_a._schema = {});
          target.constructor._schema[ItemsSym] = descriptor.value[SchemaInit];
          return true;
        } else {
          return Reflect.defineProperty(target, key, descriptor);
        }
      },
      has(target, key) {
        if (typeof key === "string" && !isNaN(+key)) {
          return Number(key) < target._raw.entries().length;
        } else {
          return Reflect.has(target, key);
        }
      }
    };
    var _CoFeed = class _CoFeed2 extends CoValueBase {
      /**
       * Declare a `CoFeed` by subclassing `CoFeed.Of(...)` and passing the item schema using a `co` primitive or a `coField.ref`.
       *
       * @example
       * ```ts
       * class ColorFeed extends CoFeed.Of(coField.string) {}
       * class AnimalFeed extends CoFeed.Of(coField.ref(Animal)) {}
       * ```
       *
       * @category Declaration
       */
      static Of(item) {
        var _a, _b;
        const cls = class CoFeedOf extends (_b = _CoFeed2, _a = coField.items, _b) {
          constructor() {
            super(...arguments);
            this[_a] = item;
          }
        };
        cls._schema || (cls._schema = {});
        cls._schema[ItemsSym] = item[SchemaInit];
        return cls;
      }
      /** @internal */
      get _schema() {
        return this.constructor._schema;
      }
      /**
       * The current account's view of this `CoFeed`
       * @category Content
       */
      get byMe() {
        if (this._loadedAs._type === "Account") {
          return this.perAccount[this._loadedAs.id];
        } else {
          return void 0;
        }
      }
      /**
       * The per-account view of this `CoFeed`
       *
       * @example
       * ```ts
       * // Access entries directly by account ID
       * const aliceEntries = feed[aliceAccount.id];
       * console.log(aliceEntries.value); // Latest value from Alice
       *
       * // Iterate through all accounts' entries
       * for (const [accountId, entries] of Object.entries(feed)) {
       *   console.log(`Latest entry from ${accountId}:`, entries.value);
       *
       *   // Access all entries from this account
       *   for (const entry of entries.all) {
       *     console.log(`Entry made at ${entry.madeAt}:`, entry.value);
       *   }
       * }
       * ```
       *
       * @category Content
       */
      get perAccount() {
        return new Proxy({}, CoStreamPerAccountProxyHandler(this));
      }
      /**
       * The per-session view of this `CoFeed`
       * @category Content
       */
      get perSession() {
        return new Proxy(
          {},
          CoStreamPerSessionProxyHandler(this, this)
        );
      }
      /**
       * The current session's view of this `CoFeed`
       *
       * This is a shortcut for `this.perSession` where the session ID is the current session ID.
       *
       * @category Content
       */
      get inCurrentSession() {
        if (this._loadedAs._type === "Account") {
          return this.perSession[this._loadedAs.sessionID];
        } else {
          return void 0;
        }
      }
      constructor(options) {
        super();
        if (options && "fromRaw" in options) {
          Object.defineProperties(this, {
            id: {
              value: options.fromRaw.id,
              enumerable: false
            },
            _raw: { value: options.fromRaw, enumerable: false }
          });
        }
        return this;
      }
      /**
       * Create a new `CoFeed`
       * @category Creation
       */
      static create(init, options) {
        const { owner } = parseCoValueCreateOptions(options);
        const instance = new this({ init, owner });
        const raw = owner._raw.createStream();
        Object.defineProperties(instance, {
          id: {
            value: raw.id,
            enumerable: false
          },
          _raw: { value: raw, enumerable: false }
        });
        if (init) {
          instance.push(...init);
        }
        return instance;
      }
      getItemsDescriptor() {
        var _a;
        return (_a = this._schema) == null ? void 0 : _a[ItemsSym];
      }
      /**
       * Push items to this `CoFeed`
       *
       * Items are appended to the current session's log. Each session (tab, device, app instance)
       * maintains its own append-only log, which is then aggregated into the per-account view.
       *
       * @example
       * ```ts
       * // Adds items to current session's log
       * feed.push("item1", "item2");
       *
       * // View items from current session
       * console.log(feed.inCurrentSession);
       *
       * // View aggregated items from all sessions for current account
       * console.log(feed.byMe);
       * ```
       *
       * @category Content
       */
      push(...items) {
        for (const item of items) {
          this.pushItem(item);
        }
      }
      pushItem(item) {
        const itemDescriptor = this._schema[ItemsSym];
        if (itemDescriptor === "json") {
          this._raw.push(item);
        } else if ("encoded" in itemDescriptor) {
          this._raw.push(itemDescriptor.encoded.encode(item));
        } else if (isRefEncoded(itemDescriptor)) {
          this._raw.push(item.id);
        }
      }
      /**
       * Get a JSON representation of the `CoFeed`
       * @category
       */
      toJSON() {
        const itemDescriptor = this._schema[ItemsSym];
        const mapper = itemDescriptor === "json" ? (v) => v : "encoded" in itemDescriptor ? itemDescriptor.encoded.encode : (v) => v && v.id;
        return {
          id: this.id,
          _type: this._type,
          ...Object.fromEntries(
            Object.entries(this).map(([account, entry]) => [
              account,
              mapper(entry.value)
            ])
          ),
          in: Object.fromEntries(
            Object.entries(this.perSession).map(([session, entry]) => [
              session,
              mapper(entry.value)
            ])
          )
        };
      }
      /** @internal */
      [inspect]() {
        return this.toJSON();
      }
      /** @internal */
      static schema(def) {
        this._schema || (this._schema = {});
        Object.assign(this._schema, def);
      }
      /**
       * Load a `CoFeed`
       * @category Subscription & Loading
       */
      static load(id2, options) {
        return loadCoValueWithoutMe(this, id2, options);
      }
      static subscribe(id2, ...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToCoValueWithoutMe(this, id2, options, listener);
      }
      /**
       * Ensure a `CoFeed` is loaded to the specified depth
       *
       * @returns A new instance of the same CoFeed that's loaded to the specified depth
       * @category Subscription & Loading
       */
      ensureLoaded(options) {
        return ensureCoValueLoaded(this, options);
      }
      subscribe(...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToExistingCoValue(this, options, listener);
      }
      /**
       * Wait for the `CoFeed` to be uploaded to the other peers.
       *
       * @category Subscription & Loading
       */
      waitForSync(options) {
        return this._raw.core.waitForSync(options);
      }
    };
    _CoFeed.prototype._type = "CoStream";
    var CoFeed = _CoFeed;
    function entryFromRawEntry(accessFrom, rawEntry, loadedAs, accountID, itemField) {
      return {
        get value() {
          if (itemField === "json") {
            return rawEntry.value;
          } else if ("encoded" in itemField) {
            return itemField.encoded.decode(rawEntry.value);
          } else if (isRefEncoded(itemField)) {
            return accessChildById(
              accessFrom,
              rawEntry.value,
              itemField
            );
          } else {
            throw new Error("Invalid item field schema");
          }
        },
        get ref() {
          if (itemField !== "json" && isRefEncoded(itemField)) {
            const rawId = rawEntry.value;
            return new Ref(
              rawId,
              loadedAs,
              itemField,
              accessFrom
            );
          } else {
            return void 0;
          }
        },
        get by() {
          return accountID && accessChildById(accessFrom, accountID, {
            ref: Account,
            optional: false
          });
        },
        madeAt: rawEntry.at,
        tx: rawEntry.tx
      };
    }
    var CoStreamPerAccountProxyHandler = (innerTarget) => ({
      get(_target, key, receiver) {
        if (typeof key === "string" && key.startsWith("co_")) {
          const rawEntry = innerTarget._raw.lastItemBy(key);
          if (!rawEntry) return;
          const entry = entryFromRawEntry(
            receiver,
            rawEntry,
            innerTarget._loadedAs,
            key,
            innerTarget._schema[ItemsSym]
          );
          Object.defineProperty(entry, "all", {
            get: () => {
              const allRawEntries = innerTarget._raw.itemsBy(key);
              return function* () {
                while (true) {
                  const rawEntry2 = allRawEntries.next();
                  if (rawEntry2.done) return;
                  yield entryFromRawEntry(
                    receiver,
                    rawEntry2.value,
                    innerTarget._loadedAs,
                    key,
                    innerTarget._schema[ItemsSym]
                  );
                }
              }();
            }
          });
          return entry;
        } else {
          return Reflect.get(innerTarget, key, receiver);
        }
      },
      ownKeys(_target) {
        return Array.from(innerTarget._raw.accounts());
      },
      getOwnPropertyDescriptor(_target, key) {
        if (typeof key === "string" && key.startsWith("co_")) {
          return {
            configurable: true,
            enumerable: true,
            writable: false
          };
        } else {
          return Reflect.getOwnPropertyDescriptor(innerTarget, key);
        }
      }
    });
    var CoStreamPerSessionProxyHandler = (innerTarget, accessFrom) => ({
      get(_target, key, receiver) {
        if (typeof key === "string" && key.includes("session")) {
          const sessionID = key;
          const rawEntry = innerTarget._raw.lastItemIn(sessionID);
          if (!rawEntry) return;
          const by = cojsonInternals.accountOrAgentIDfromSessionID(sessionID);
          const entry = entryFromRawEntry(
            accessFrom,
            rawEntry,
            innerTarget._loadedAs,
            cojsonInternals.isAccountID(by) ? by : void 0,
            innerTarget._schema[ItemsSym]
          );
          Object.defineProperty(entry, "all", {
            get: () => {
              const allRawEntries = innerTarget._raw.itemsIn(sessionID);
              return function* () {
                while (true) {
                  const rawEntry2 = allRawEntries.next();
                  if (rawEntry2.done) return;
                  yield entryFromRawEntry(
                    accessFrom,
                    rawEntry2.value,
                    innerTarget._loadedAs,
                    cojsonInternals.isAccountID(by) ? by : void 0,
                    innerTarget._schema[ItemsSym]
                  );
                }
              }();
            }
          });
          return entry;
        } else {
          return Reflect.get(innerTarget, key, receiver);
        }
      },
      ownKeys() {
        return innerTarget._raw.sessions();
      },
      getOwnPropertyDescriptor(target, key) {
        if (typeof key === "string" && key.startsWith("co_")) {
          return {
            configurable: true,
            enumerable: true,
            writable: false
          };
        } else {
          return Reflect.getOwnPropertyDescriptor(target, key);
        }
      }
    });
    var FileStream = class extends CoValueBase {
      constructor(options) {
        super();
        let raw;
        if ("fromRaw" in options) {
          raw = options.fromRaw;
        } else {
          const rawOwner = options.owner._raw;
          raw = rawOwner.createBinaryStream();
        }
        Object.defineProperties(this, {
          id: {
            value: raw.id,
            enumerable: false
          },
          _type: { value: "BinaryCoStream", enumerable: false },
          _raw: { value: raw, enumerable: false }
        });
      }
      /**
       * Create a new empty `FileStream` instance.
       *
       * @param options - Configuration options for the new FileStream
       * @param options.owner - The Account or Group that will own this FileStream and control access rights
       *
       * @example
       * ```typescript
       * // Create owned by an account
       * const stream = FileStream.create({ owner: myAccount });
       *
       * // Create owned by a group
       * const stream = FileStream.create({ owner: teamGroup });
       *
       * // Create with implicit owner
       * const stream = FileStream.create(myAccount);
       * ```
       *
       * @remarks
       * For uploading an existing file or blob, use {@link FileStream.createFromBlob} instead.
       *
       * @category Creation
       */
      static create(options) {
        return new this(parseCoValueCreateOptions(options));
      }
      getMetadata() {
        return this._raw.getBinaryStreamInfo();
      }
      getChunks(options) {
        return this._raw.getBinaryChunks(options == null ? void 0 : options.allowUnfinished);
      }
      isBinaryStreamEnded() {
        return this._raw.isBinaryStreamEnded();
      }
      start(options) {
        this._raw.startBinaryStream(options);
      }
      push(data2) {
        this._raw.pushBinaryStreamChunk(data2);
      }
      end() {
        this._raw.endBinaryStream();
      }
      toBlob(options) {
        const chunks = this.getChunks({
          allowUnfinished: options == null ? void 0 : options.allowUnfinished
        });
        if (!chunks) {
          return void 0;
        }
        return new Blob(chunks.chunks, { type: chunks.mimeType });
      }
      /**
       * Load a `FileStream` as a `Blob`
       *
       * @category Content
       */
      static async loadAsBlob(id2, options) {
        let stream = await this.load(id2, options);
        return stream == null ? void 0 : stream.toBlob({
          allowUnfinished: options == null ? void 0 : options.allowUnfinished
        });
      }
      static async loadAsBase64(id2, options) {
        const stream = await this.load(id2, options);
        return stream == null ? void 0 : stream.asBase64(options);
      }
      asBase64(options) {
        const chunks = this.getChunks(options);
        if (!chunks) return void 0;
        const output2 = [];
        for (const chunk of chunks.chunks) {
          for (const byte of chunk) {
            output2.push(String.fromCharCode(byte));
          }
        }
        const base642 = btoa(output2.join(""));
        if (options == null ? void 0 : options.dataURL) {
          return `data:${chunks.mimeType};base64,${base642}`;
        }
        return base642;
      }
      /**
       * Create a `FileStream` from a `Blob` or `File`
       *
       * @example
       * ```ts
       * import { coField, FileStream } from "jazz-tools";
       *
       * const fileStream = await FileStream.createFromBlob(file, {owner: group})
       * ```
       * @category Content
       */
      static async createFromBlob(blob, options) {
        const stream = this.create(options);
        const onProgress = options && "onProgress" in options ? options.onProgress : void 0;
        const start = Date.now();
        const data2 = new Uint8Array(await blob.arrayBuffer());
        stream.start({
          mimeType: blob.type,
          totalSizeBytes: blob.size,
          fileName: blob instanceof File ? blob.name : void 0
        });
        const chunkSize = MAX_RECOMMENDED_TX_SIZE;
        let lastProgressUpdate = Date.now();
        for (let idx = 0; idx < data2.length; idx += chunkSize) {
          stream.push(data2.slice(idx, idx + chunkSize));
          if (Date.now() - lastProgressUpdate > 100) {
            onProgress == null ? void 0 : onProgress(idx / data2.length);
            lastProgressUpdate = Date.now();
          }
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
        stream.end();
        const end = Date.now();
        console.debug(
          "Finished creating binary stream in",
          (end - start) / 1e3,
          "s - Throughput in MB/s",
          1e3 * (blob.size / (end - start)) / (1024 * 1024)
        );
        onProgress == null ? void 0 : onProgress(1);
        return stream;
      }
      /**
       * Get a JSON representation of the `FileStream`
       * @category Content
       */
      toJSON() {
        return {
          id: this.id,
          _type: this._type,
          ...this.getChunks()
        };
      }
      /** @internal */
      [inspect]() {
        return this.toJSON();
      }
      /**
       * Load a `FileStream`
       * @category Subscription & Loading
       */
      static async load(id2, options) {
        const stream = await loadCoValueWithoutMe(this, id2, options);
        if (!(options == null ? void 0 : options.allowUnfinished) && !(stream == null ? void 0 : stream.isBinaryStreamEnded())) {
          return new Promise((resolve) => {
            subscribeToCoValueWithoutMe(
              this,
              id2,
              options || {},
              (value, unsubscribe) => {
                if (value.isBinaryStreamEnded()) {
                  unsubscribe();
                  resolve(value);
                }
              }
            );
          });
        }
        return stream;
      }
      static subscribe(id2, ...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToCoValueWithoutMe(this, id2, options, listener);
      }
      /**
       * An instance method to subscribe to an existing `FileStream`
       * @category Subscription & Loading
       */
      subscribe(listener) {
        return subscribeToExistingCoValue(this, {}, listener);
      }
      /**
       * Wait for the `FileStream` to be uploaded to the other peers.
       *
       * @category Subscription & Loading
       */
      waitForSync(options) {
        return this._raw.core.waitForSync(options);
      }
    };
    var _Account = class _Account2 extends CoValueBase {
      get _schema() {
        return this.constructor._schema;
      }
      get _owner() {
        return this;
      }
      get _loadedAs() {
        if (this.isLocalNodeOwner) return this;
        const agent = this._raw.core.node.getCurrentAgent();
        if (agent instanceof ControlledAccount) {
          return coValuesCache.get(
            agent.account,
            () => _Account2.fromRaw(agent.account)
          );
        }
        return new AnonymousJazzAgent(this._raw.core.node);
      }
      getDescriptor(key) {
        if (key === "profile") {
          return this._schema.profile;
        } else if (key === "root") {
          return this._schema.root;
        }
        return void 0;
      }
      get _refs() {
        const profileID = this._raw.get("profile");
        const rootID = this._raw.get("root");
        return {
          profile: profileID ? new Ref(
            profileID,
            this._loadedAs,
            this._schema.profile,
            this
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ) : void 0,
          root: rootID ? new Ref(
            rootID,
            this._loadedAs,
            this._schema.root,
            this
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ) : void 0
        };
      }
      /**
       * Whether this account is the currently active account.
       */
      get isMe() {
        return activeAccountContext.get().id === this.id;
      }
      constructor(options) {
        super();
        if (!("fromRaw" in options)) {
          throw new Error("Can only construct account from raw or with .create()");
        }
        this.isLocalNodeOwner = options.fromRaw.id == options.fromRaw.core.node.getCurrentAgent().id;
        Object.defineProperties(this, {
          id: {
            value: options.fromRaw.id,
            enumerable: false
          },
          _raw: { value: options.fromRaw, enumerable: false },
          _type: { value: "Account", enumerable: false }
        });
        if (this.isLocalNodeOwner) {
          this.sessionID = options.fromRaw.core.node.currentSessionID;
        }
        return new Proxy(this, AccountAndGroupProxyHandler);
      }
      myRole() {
        if (this.isLocalNodeOwner) {
          return "admin";
        }
      }
      getRoleOf(member) {
        if (member === "me") {
          return this.isMe ? "admin" : void 0;
        }
        if (member === this.id) {
          return "admin";
        }
        return void 0;
      }
      getParentGroups() {
        return [];
      }
      get members() {
        const ref2 = new Ref(
          this.id,
          this._loadedAs,
          {
            ref: () => this.constructor,
            optional: false
          },
          this
        );
        return [{ id: this.id, role: "admin", ref: ref2, account: this }];
      }
      canRead(value) {
        const role = value._owner.getRoleOf(this.id);
        return role === "admin" || role === "writer" || role === "reader" || role === "writeOnly";
      }
      canWrite(value) {
        const role = value._owner.getRoleOf(this.id);
        return role === "admin" || role === "writer" || role === "writeOnly";
      }
      canAdmin(value) {
        return value._owner.getRoleOf(this.id) === "admin";
      }
      async acceptInvite(valueID, inviteSecret, coValueClass) {
        if (!this.isLocalNodeOwner) {
          throw new Error("Only a controlled account can accept invites");
        }
        await this._raw.core.node.acceptInvite(
          valueID,
          inviteSecret
        );
        return loadCoValue(anySchemaToCoSchema(coValueClass), valueID, {
          loadAs: this
        });
      }
      /** @private */
      static async create(options) {
        const { node } = await LocalNode.withNewlyCreatedAccount({
          ...options,
          migration: async (rawAccount, _node, creationProps) => {
            var _a;
            const account = new this({
              fromRaw: rawAccount
            });
            await ((_a = account.applyMigration) == null ? void 0 : _a.call(account, creationProps));
          }
        });
        return this.fromNode(node);
      }
      static getMe() {
        return activeAccountContext.get();
      }
      static async createAs(as, options) {
        const connectedPeers2 = cojsonInternals.connectedPeers(
          "creatingAccount",
          "createdAccount",
          { peer1role: "server", peer2role: "client" }
        );
        as._raw.core.node.syncManager.addPeer(connectedPeers2[1]);
        const account = await this.create({
          creationProps: options.creationProps,
          crypto: as._raw.core.node.crypto,
          peersToLoadFrom: [connectedPeers2[0]]
        });
        await account.waitForAllCoValuesSync();
        return account;
      }
      static fromNode(node) {
        return new this({
          fromRaw: node.expectCurrentAccount("jazz-tools/Account.fromNode")
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      toJSON() {
        return {
          id: this.id,
          _type: this._type
        };
      }
      [inspect]() {
        return this.toJSON();
      }
      async applyMigration(creationProps) {
        await this.migrate(creationProps);
        if (this.profile === void 0 && creationProps) {
          const profileGroup = RegisteredSchemas["Group"].create({ owner: this });
          this.profile = Profile.create({ name: creationProps.name }, profileGroup);
          profileGroup.addMember("everyone", "reader");
        } else if (this.profile && creationProps) {
          if (this.profile._owner._type !== "Group") {
            throw new Error("Profile must be owned by a Group", {
              cause: `The profile of the account "${this.id}" was created with an Account as owner, which is not allowed.`
            });
          }
        }
        const node = this._raw.core.node;
        const profile = node.expectCoValueLoaded(this._raw.get("profile")).getCurrentContent();
        if (!profile.get("inbox")) {
          const inboxRoot = createInboxRoot(this);
          profile.set("inbox", inboxRoot.id);
          profile.set("inboxInvite", inboxRoot.inviteLink);
        }
      }
      // Placeholder method for subclasses to override
      migrate(creationProps) {
      }
      /** @category Subscription & Loading */
      static load(id2, options) {
        return loadCoValueWithoutMe(this, id2, options);
      }
      static subscribe(id2, ...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToCoValueWithoutMe(this, id2, options, listener);
      }
      /** @category Subscription & Loading */
      ensureLoaded(options) {
        return ensureCoValueLoaded(this, options);
      }
      subscribe(...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToExistingCoValue(this, options, listener);
      }
      /**
       * Wait for the `Account` to be uploaded to the other peers.
       *
       * @category Subscription & Loading
       */
      waitForSync(options) {
        return this._raw.core.waitForSync(options);
      }
      /**
       * Wait for all the available `CoValues` to be uploaded to the other peers.
       *
       * @category Subscription & Loading
       */
      waitForAllCoValuesSync(options) {
        return this._raw.core.node.syncManager.waitForAllCoValuesSync(
          options == null ? void 0 : options.timeout
        );
      }
    };
    _Account._schema = {
      profile: {
        ref: () => Profile,
        optional: false
      },
      root: {
        ref: () => RegisteredSchemas["CoMap"],
        optional: true
      }
    };
    var Account = _Account;
    var AccountAndGroupProxyHandler = {
      get(target, key, receiver) {
        if (key === "profile" || key === "root") {
          const id2 = target._raw.get(key);
          if (id2) {
            return accessChildByKey(target, id2, key);
          } else {
            return void 0;
          }
        } else {
          return Reflect.get(target, key, receiver);
        }
      },
      set(target, key, value, receiver) {
        var _a;
        if ((key === "profile" || key === "root") && typeof value === "object" && SchemaInit in value) {
          (_a = target.constructor)._schema || (_a._schema = {});
          target.constructor._schema[key] = value[SchemaInit];
          return true;
        } else if (key === "profile") {
          if (value) {
            target._raw.set(
              "profile",
              value.id,
              "trusting"
            );
          }
          return true;
        } else if (key === "root") {
          if (value) {
            target._raw.set("root", value.id);
          }
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      },
      defineProperty(target, key, descriptor) {
        var _a;
        if ((key === "profile" || key === "root") && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
          (_a = target.constructor)._schema || (_a._schema = {});
          target.constructor._schema[key] = descriptor.value[SchemaInit];
          return true;
        } else {
          return Reflect.defineProperty(target, key, descriptor);
        }
      }
    };
    function isControlledAccount(account) {
      return account.isLocalNodeOwner;
    }
    RegisteredSchemas["Account"] = Account;
    var _Group = class _Group2 extends CoValueBase {
      get _schema() {
        return this.constructor._schema;
      }
      get _refs() {
        const profileID = this._raw.get("profile");
        const rootID = this._raw.get("root");
        return {
          profile: profileID ? new Ref(
            profileID,
            this._loadedAs,
            this._schema.profile,
            this
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ) : void 0,
          root: rootID ? new Ref(
            rootID,
            this._loadedAs,
            this._schema.root,
            this
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ) : void 0
        };
      }
      /** @deprecated Don't use constructor directly, use .create */
      constructor(options) {
        super();
        let raw;
        if (options && "fromRaw" in options) {
          raw = options.fromRaw;
        } else {
          const initOwner = options.owner;
          if (!initOwner) throw new Error("No owner provided");
          if (initOwner._type === "Account" && isControlledAccount(initOwner)) {
            const rawOwner = initOwner._raw;
            raw = rawOwner.core.node.createGroup();
          } else {
            throw new Error("Can only construct group as a controlled account");
          }
        }
        Object.defineProperties(this, {
          id: {
            value: raw.id,
            enumerable: false
          },
          _raw: { value: raw, enumerable: false }
        });
        return new Proxy(this, AccountAndGroupProxyHandler);
      }
      static create(options) {
        return new this(parseGroupCreateOptions(options));
      }
      myRole() {
        return this._raw.myRole();
      }
      addMember(member, role) {
        if (member !== "everyone" && member._type === "Group") {
          if (role === "writeOnly")
            throw new Error("Cannot add group as member with write-only role");
          this._raw.extend(member._raw, role);
        } else if (role !== void 0 && role !== "inherit") {
          this._raw.addMember(member === "everyone" ? member : member._raw, role);
        }
      }
      removeMember(member) {
        if (member !== "everyone" && member._type === "Group") {
          return this._raw.revokeExtend(member._raw);
        } else {
          return this._raw.removeMember(
            member === "everyone" ? member : member._raw
          );
        }
      }
      getMembersFromKeys(accountIDs) {
        const members = [];
        const refEncodedAccountSchema = {
          ref: () => Account,
          optional: false
        };
        for (const accountID of accountIDs) {
          if (!isAccountID(accountID)) continue;
          const role = this._raw.roleOf(accountID);
          if (role === "admin" || role === "writer" || role === "reader" || role === "writeOnly") {
            const ref2 = new Ref(
              accountID,
              this._loadedAs,
              refEncodedAccountSchema,
              this
            );
            const group = this;
            members.push({
              id: accountID,
              role,
              ref: ref2,
              get account() {
                return accessChildById(group, accountID, refEncodedAccountSchema);
              }
            });
          }
        }
        return members;
      }
      /**
       * Returns all members of the group, including inherited members from parent
       * groups.
       *
       * If you need only the direct members of the group, use
       * {@link getDirectMembers} instead.
       *
       * @returns The members of the group.
       */
      get members() {
        return this.getMembersFromKeys(this._raw.getAllMemberKeysSet());
      }
      /**
       * Returns the direct members of the group.
       *
       * If you need all members of the group, including inherited members from
       * parent groups, use {@link Group.members|members} instead.
       * @returns The direct members of the group.
       */
      getDirectMembers() {
        return this.getMembersFromKeys(this._raw.getMemberKeys());
      }
      getRoleOf(member) {
        if (member === "me") {
          return this._raw.roleOf(
            activeAccountContext.get().id
          );
        }
        return this._raw.roleOf(
          member === "everyone" ? member : member
        );
      }
      /**
       * Make the group public, so that everyone can read it.
       * Alias for `addMember("everyone", role)`.
       *
       * @param role - Optional: the role to grant to everyone. Defaults to "reader".
       * @returns The group itself.
       */
      makePublic(role = "reader") {
        this.addMember("everyone", role);
        return this;
      }
      getParentGroups() {
        return this._raw.getParentGroups().map((group) => _Group2.fromRaw(group));
      }
      /** @category Identity & Permissions
       * Gives members of a parent group membership in this group.
       * @deprecated Use `addMember` instead.
       * @param parent The group that will gain access to this group.
       * @param roleMapping The role all members of the parent group should have in this group.
       * @returns This group.
       */
      extend(parent, roleMapping) {
        this._raw.extend(parent._raw, roleMapping);
        return this;
      }
      /** @category Identity & Permissions
       * Revokes membership from members a parent group.
       * @deprecated Use `removeMember` instead.
       * @param parent The group that will lose access to this group.
       * @returns This group.
       */
      async revokeExtend(parent) {
        await this._raw.revokeExtend(parent._raw);
        return this;
      }
      /** @category Subscription & Loading */
      static load(id2, options) {
        return loadCoValueWithoutMe(this, id2, options);
      }
      static subscribe(id2, ...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToCoValueWithoutMe(this, id2, options, listener);
      }
      /** @category Subscription & Loading */
      ensureLoaded(options) {
        return ensureCoValueLoaded(this, options);
      }
      subscribe(...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToExistingCoValue(this, options, listener);
      }
      /**
       * Wait for the `Group` to be uploaded to the other peers.
       *
       * @category Subscription & Loading
       */
      waitForSync(options) {
        return this._raw.core.waitForSync(options);
      }
    };
    _Group.prototype._type = "Group";
    _Group._schema = {
      profile: "json",
      root: "json"
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    };
    Object.defineProperty(_Group.prototype, "_schema", {
      get: () => _Group._schema
    });
    var Group = _Group;
    RegisteredSchemas["Group"] = Group;
    function isAccountID(id2) {
      return id2.startsWith("co_");
    }
    var Profile = class extends CoMap {
      constructor() {
        super(...arguments);
        this.name = coField.string;
        this.inbox = coField.optional.string;
        this.inboxInvite = coField.optional.string;
      }
      /**
       * Creates a new profile with the given initial values and owner.
       *
       * The owner (a Group) determines access rights to the Profile.
       *
       * @category Creation
       */
      static create(init, options) {
        const owner = options !== void 0 && "owner" in options ? options.owner : options;
        if ((owner == null ? void 0 : owner._type) === "Account") {
          throw new Error("Profiles should be owned by a group");
        }
        return super.create(init, options);
      }
    };
    function createInboxRoot(account) {
      if (!account.isLocalNodeOwner) {
        throw new Error("Account is not controlled");
      }
      const rawAccount = account._raw;
      const group = rawAccount.core.node.createGroup();
      const messagesFeed = group.createStream();
      const inboxRoot = rawAccount.createMap();
      const processedFeed = rawAccount.createStream();
      const failedFeed = rawAccount.createStream();
      const inviteLink = `${messagesFeed.id}/${group.createInvite("writeOnly")}`;
      inboxRoot.set("messages", messagesFeed.id);
      inboxRoot.set("processed", processedFeed.id);
      inboxRoot.set("failed", failedFeed.id);
      return {
        id: inboxRoot.id,
        inviteLink
      };
    }
    var weakMap = /* @__PURE__ */ new WeakMap();
    var coValuesCache = {
      get: (raw, compute) => {
        const cached2 = weakMap.get(raw);
        if (cached2) {
          return cached2;
        }
        const computed = compute();
        weakMap.set(raw, computed);
        return computed;
      }
    };
    var CoPlainText = class extends String {
      get _owner() {
        return this._raw.group instanceof RawAccount ? Account.fromRaw(this._raw.group) : Group.fromRaw(this._raw.group);
      }
      get _loadedAs() {
        const agent = this._raw.core.node.getCurrentAgent();
        if (agent instanceof ControlledAccount) {
          return coValuesCache.get(
            agent.account,
            () => anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(
              agent.account
            )
          );
        }
        return new AnonymousJazzAgent(this._raw.core.node);
      }
      /** @internal */
      constructor(options) {
        if (!options) {
          super("");
          return;
        }
        if ("fromRaw" in options) {
          super(options.fromRaw.toString());
          const raw = options.fromRaw;
          Object.defineProperties(this, {
            id: { value: raw.id, enumerable: false },
            _type: { value: "CoPlainText", enumerable: false },
            _raw: { value: raw, enumerable: false }
          });
          return;
        }
        if ("text" in options && "owner" in options) {
          super(options.text);
          const raw = options.owner._raw.createPlainText(options.text);
          Object.defineProperties(this, {
            id: { value: raw.id, enumerable: false },
            _type: { value: "CoPlainText", enumerable: false },
            _raw: { value: raw, enumerable: false }
          });
          return;
        }
        throw new Error("Invalid constructor arguments");
      }
      /**
       * Create a new `CoPlainText` with the given text and owner.
       *
       * The owner (a Group or Account) determines access rights to the CoPlainText.
       *
       * The CoPlainText will immediately be persisted and synced to connected peers.
       *
       * @example
       * ```ts
       * const text = CoPlainText.create("Hello, world!", { owner: me });
       * ```
       *
       * @category Creation
       */
      static create(text, options) {
        const { owner } = parseCoValueCreateOptions(options);
        return new this({ text, owner });
      }
      get length() {
        return this._raw.toString().length;
      }
      toString() {
        return this._raw.toString();
      }
      valueOf() {
        return this._raw.toString();
      }
      toJSON() {
        return this._raw.toString();
      }
      [inspect]() {
        return this.toJSON();
      }
      insertBefore(idx, text) {
        this._raw.insertBefore(idx, text);
      }
      insertAfter(idx, text) {
        this._raw.insertAfter(idx, text);
      }
      deleteRange(range) {
        this._raw.deleteRange(range);
      }
      posBefore(idx) {
        return this._raw.mapping.opIDbeforeIdx[idx];
      }
      posAfter(idx) {
        return this._raw.mapping.opIDafterIdx[idx];
      }
      idxBefore(pos) {
        return this._raw.mapping.idxBeforeOpID[stringifyOpID(pos)];
      }
      idxAfter(pos) {
        return this._raw.mapping.idxAfterOpID[stringifyOpID(pos)];
      }
      static fromRaw(raw) {
        return new this({ fromRaw: raw });
      }
      /**
       * Apply text, modifying the text in place. Calculates the diff and applies it to the CoValue.
       *
       * @category Mutation
       */
      applyDiff(other) {
        const current = this._raw.toString();
        const currentGraphemes = this._raw.toGraphemes(current);
        const otherGraphemes = this._raw.toGraphemes(other);
        const patches = [...binExports.calcPatch(currentGraphemes, otherGraphemes)];
        for (const [from, to, insert] of patches.reverse()) {
          if (to > from) {
            this.deleteRange({ from, to });
          }
          if (insert.length > 0) {
            this.insertBefore(from, this._raw.fromGraphemes(insert));
          }
        }
      }
      /**
       * Load a `CoPlainText` with a given ID, as a given account.
       *
       * @category Subscription & Loading
       */
      static load(id2, options) {
        return loadCoValueWithoutMe(this, id2, options);
      }
      static subscribe(id2, ...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToCoValueWithoutMe(this, id2, options, listener);
      }
      /**
       * Given an already loaded `CoPlainText`, subscribe to updates to the `CoPlainText` and ensure that the specified fields are loaded to the specified depth.
       *
       * Works like `CoPlainText.subscribe()`, but you don't need to pass the ID or the account to load as again.
       *
       * Returns an unsubscribe function that you should call when you no longer need updates.
       *
       * @category Subscription & Loading
       **/
      subscribe(listener) {
        return subscribeToExistingCoValue(this, {}, listener);
      }
      /**
       * Allow CoPlainText to behave like a primitive string in most contexts (e.g.,
       * string concatenation, template literals, React rendering, etc.) by implementing
       * Symbol.toPrimitive. This eliminates the need to call .toString() explicitly.
       *
       * The 'hint' parameter indicates the preferred type of conversion:
       * - 'string': prefer string conversion
       * - 'number': prefer number conversion (attempt to parse the text as a number)
       * - 'default': usually treat as string
       */
      [Symbol.toPrimitive](hint) {
        if (hint === "number") {
          return Number(this._raw.toString());
        }
        return this._raw.toString();
      }
    };
    var CoRichText = class extends CoPlainText {
    };
    var SchemaUnion = class _SchemaUnion extends CoValueBase {
      /**
       * Create a new union type from a discriminator function.
       *
       * The discriminator function receives the raw data and should return the appropriate concrete class to use for that data.
       *
       * When loading a SchemaUnion, the correct subclass will be instantiated based on the discriminator.
       *
       * @param discriminator - Function that determines which concrete type to use
       * @returns A new class that can create/load instances of the union type
       *
       * @example
       * ```ts
       * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {
       *   switch (raw.get("type")) {
       *     case "button": return ButtonWidget;
       *     case "slider": return SliderWidget;
       *     default: throw new Error("Unknown widget type");
       *   }
       * });
       *
       * const widget = await loadCoValue(WidgetUnion, id, me, {});
       *
       * // You can narrow the returned instance to a subclass by using `instanceof`
       * if (widget instanceof ButtonWidget) {
       *   console.log(widget.label);
       * } else if (widget instanceof SliderWidget) {
       *   console.log(widget.min, widget.max);
       * }
       * ```
       *
       * @category Declaration
       **/
      static Of(discriminator) {
        return class SchemaUnionClass extends _SchemaUnion {
          static fromRaw(raw) {
            const ResolvedClass = discriminator(
              raw
            );
            return ResolvedClass.fromRaw(raw);
          }
        };
      }
      /**
       * Create an instance from raw data. This is called internally and should not be used directly.
       * Use {@link SchemaUnion.Of} to create a union type instead.
       *
       * @internal
       */
      // @ts-ignore
      static fromRaw(raw) {
        throw new Error("Not implemented");
      }
      /**
       * Load a `SchemaUnion` with a given ID, as a given account.
       *
       * Note: The `resolve` option is not supported for `SchemaUnion`s due to https://github.com/garden-co/jazz/issues/2639
       *
       * @category Subscription & Loading
       */
      static load(id2, options) {
        return loadCoValueWithoutMe(this, id2, options);
      }
      static subscribe(id2, ...args) {
        const { options, listener } = parseSubscribeRestArgs(args);
        return subscribeToCoValueWithoutMe(this, id2, options, listener);
      }
    };
    var AnonymousJazzAgent = class {
      constructor(node) {
        this.node = node;
        this._type = "Anonymous";
      }
    };
    var ActiveAccountContext = class {
      constructor() {
        this.activeAccount = null;
        this.guestMode = false;
      }
      set(account) {
        this.activeAccount = account;
        this.guestMode = false;
      }
      setGuestMode() {
        this.activeAccount = null;
        this.guestMode = true;
      }
      maybeGet() {
        return this.activeAccount;
      }
      get() {
        if (!this.activeAccount) {
          if (this.guestMode) {
            throw new Error(
              "Something that expects a full active account was called in guest mode."
            );
          }
          throw new Error("No active account");
        }
        return this.activeAccount;
      }
    };
    var activeAccountContext = new ActiveAccountContext();
    var Ref = class {
      constructor(id2, controlledAccount, schema, parent) {
        this.id = id2;
        this.controlledAccount = controlledAccount;
        this.schema = schema;
        this.parent = parent;
        if (!isRefEncoded(schema)) {
          throw new Error("Ref must be constructed with a ref schema");
        }
      }
      async load() {
        const subscriptionScope = getSubscriptionScope(this.parent);
        subscriptionScope.subscribeToId(this.id, this.schema);
        const node = subscriptionScope.childNodes.get(this.id);
        if (!node) {
          return null;
        }
        const value = node.value;
        if ((value == null ? void 0 : value.type) === "loaded") {
          return value.value;
        } else {
          return new Promise((resolve) => {
            const unsubscribe = node.subscribe((value2) => {
              if ((value2 == null ? void 0 : value2.type) === "loaded") {
                unsubscribe();
                resolve(value2.value);
              } else if ((value2 == null ? void 0 : value2.type) === "unavailable") {
                unsubscribe();
                resolve(null);
              } else if ((value2 == null ? void 0 : value2.type) === "unauthorized") {
                unsubscribe();
                resolve(null);
              }
            });
          });
        }
      }
      get value() {
        return accessChildById(this.parent, this.id, this.schema);
      }
    };
    function makeRefs(parent, getIdForKey, getKeysWithIds, controlledAccount, refSchemaForKey) {
      const refs = {};
      return new Proxy(refs, {
        get(_target, key) {
          if (key === Symbol.iterator) {
            return function* () {
              for (const key2 of getKeysWithIds()) {
                yield new Ref(
                  getIdForKey(key2),
                  controlledAccount,
                  refSchemaForKey(key2),
                  parent
                );
              }
            };
          }
          if (typeof key === "symbol") return void 0;
          if (key === "length") {
            return getKeysWithIds().length;
          }
          const id2 = getIdForKey(key);
          if (!id2) return void 0;
          return new Ref(
            id2,
            controlledAccount,
            refSchemaForKey(key),
            parent
          );
        },
        ownKeys() {
          return getKeysWithIds().map((key) => key.toString());
        },
        getOwnPropertyDescriptor(target, key) {
          const id2 = getIdForKey(key);
          if (id2) {
            return {
              enumerable: true,
              configurable: true,
              writable: true
            };
          } else {
            return Reflect.getOwnPropertyDescriptor(target, key);
          }
        }
      });
    }
    var Encoders = {
      Date: {
        encode: (value) => value.toISOString(),
        decode: (value) => new Date(value)
      },
      OptionalDate: {
        encode: (value) => (value == null ? void 0 : value.toISOString()) || null,
        decode: (value) => value === null ? void 0 : new Date(value)
      }
    };
    var optional2 = {
      ref: optionalRef,
      json() {
        return { [SchemaInit]: "json" };
      },
      encoded(arg) {
        return { [SchemaInit]: { encoded: arg } };
      },
      string: {
        [SchemaInit]: "json"
      },
      number: {
        [SchemaInit]: "json"
      },
      boolean: {
        [SchemaInit]: "json"
      },
      null: {
        [SchemaInit]: "json"
      },
      Date: {
        [SchemaInit]: { encoded: Encoders.OptionalDate }
      },
      literal(..._lit) {
        return { [SchemaInit]: "json" };
      }
    };
    var coField = {
      string: {
        [SchemaInit]: "json"
      },
      number: {
        [SchemaInit]: "json"
      },
      boolean: {
        [SchemaInit]: "json"
      },
      null: {
        [SchemaInit]: "json"
      },
      Date: {
        [SchemaInit]: { encoded: Encoders.Date }
      },
      literal(..._lit) {
        return { [SchemaInit]: "json" };
      },
      json() {
        return { [SchemaInit]: "json" };
      },
      encoded(arg) {
        return { [SchemaInit]: { encoded: arg } };
      },
      ref,
      items: ItemsSym,
      optional: optional2
    };
    function optionalRef(arg) {
      return ref(arg, { optional: true });
    }
    function ref(arg, options) {
      return {
        [SchemaInit]: {
          ref: arg,
          optional: (options == null ? void 0 : options.optional) || false
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      };
    }
    function isRefEncoded(schema) {
      return typeof schema === "object" && "ref" in schema && "optional" in schema && typeof schema.ref === "function";
    }
    function instantiateRefEncoded(schema, raw) {
      return isCoValueClass(schema.ref) ? schema.ref.fromRaw(raw) : schema.ref(
        raw
      ).fromRaw(raw);
    }
    function applyCoValueMigrations(instance) {
      var _a;
      const node = instance._raw.core.node;
      const migratedCoValues = node._migratedCoValues ?? (node._migratedCoValues = /* @__PURE__ */ new Set());
      if ("migrate" in instance && typeof instance.migrate === "function" && instance._type !== "Account" && !migratedCoValues.has(instance.id)) {
        migratedCoValues.add(instance.id);
        const result = (_a = instance.migrate) == null ? void 0 : _a.call(instance, instance);
        if (result && "then" in result) {
          throw new Error("Migration function cannot be async");
        }
      }
    }
    var CoValueCoreSubscription = class {
      constructor(node, id2, listener, skipRetry) {
        this.node = node;
        this.id = id2;
        this.listener = listener;
        this.skipRetry = skipRetry;
        this._unsubscribe = () => {
        };
        this.unsubscribed = false;
        const entry = this.node.getCoValue(this.id);
        if (entry == null ? void 0 : entry.isAvailable()) {
          this.subscribe(entry.getCurrentContent());
        } else {
          this.node.loadCoValueCore(this.id, void 0, skipRetry).then((value) => {
            if (this.unsubscribed) return;
            if (value.isAvailable()) {
              this.subscribe(value.getCurrentContent());
            } else {
              this.subscribeToState();
              this.listener("unavailable");
            }
          }).catch((error2) => {
            console.error("Unexpected error loading CoValue: ", error2);
            this.listener("unavailable");
          });
        }
      }
      subscribeToState() {
        const entry = this.node.getCoValue(this.id);
        const handleStateChange = (core2, unsubFromStateChange2) => {
          if (this.unsubscribed) {
            unsubFromStateChange2();
            return;
          }
          if (core2.isAvailable()) {
            this.subscribe(core2.getCurrentContent());
            unsubFromStateChange2();
          }
        };
        const unsubFromStateChange = entry.subscribe(handleStateChange);
        this._unsubscribe = () => {
          unsubFromStateChange();
        };
      }
      subscribe(value) {
        if (this.unsubscribed) return;
        this._unsubscribe = value.subscribe((value2) => {
          this.listener(value2);
        });
        this.listener(value);
      }
      unsubscribe() {
        if (this.unsubscribed) return;
        this.unsubscribed = true;
        this._unsubscribe();
      }
    };
    var JazzError = class _JazzError {
      constructor(id2, type, issues) {
        this.id = id2;
        this.type = type;
        this.issues = issues;
      }
      toString() {
        return this.issues.map((issue2) => {
          let message = `${issue2.message}`;
          if (this.id) {
            message += ` from ${this.id}`;
          }
          if (issue2.path.length > 0) {
            message += ` on path ${issue2.path.join(".")}`;
          }
          return message;
        }).join("\n");
      }
      prependPath(item) {
        if (this.issues.length === 0) {
          return this;
        }
        const issues = this.issues.map((issue2) => {
          return {
            ...issue2,
            path: [item].concat(issue2.path)
          };
        });
        return new _JazzError(this.id, this.type, issues);
      }
    };
    function getOwnerFromRawValue(raw) {
      const owner = raw.group;
      return coValuesCache.get(
        owner,
        () => owner instanceof RawAccount ? anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(owner) : RegisteredSchemas["Group"].fromRaw(owner)
      );
    }
    function createCoValue(ref2, raw, subscriptionScope) {
      const freshValueInstance = instantiateRefEncoded(ref2, raw);
      Object.defineProperty(freshValueInstance, "_subscriptionScope", {
        value: subscriptionScope,
        writable: false,
        enumerable: false,
        configurable: false
      });
      return {
        type: "loaded",
        value: freshValueInstance,
        id: subscriptionScope.id
      };
    }
    var SubscriptionScope = class _SubscriptionScope {
      constructor(node, resolve, id2, schema, skipRetry) {
        this.node = node;
        this.id = id2;
        this.schema = schema;
        this.skipRetry = skipRetry;
        this.childNodes = /* @__PURE__ */ new Map();
        this.childValues = /* @__PURE__ */ new Map();
        this.childErrors = /* @__PURE__ */ new Map();
        this.validationErrors = /* @__PURE__ */ new Map();
        this.dirty = false;
        this.idsSubscribed = /* @__PURE__ */ new Set();
        this.autoloaded = /* @__PURE__ */ new Set();
        this.autoloadedKeys = /* @__PURE__ */ new Set();
        this.skipInvalidKeys = /* @__PURE__ */ new Set();
        this.totalValidTransactions = 0;
        this.migrated = false;
        this.migrating = false;
        this.silenceUpdates = false;
        this.handleChildUpdate = (id3, value, key) => {
          if (value.type === "unloaded") {
            return;
          }
          this.childValues.set(id3, value);
          if (value.type === "unavailable" || value.type === "unauthorized") {
            this.childErrors.set(id3, value.prependPath(key ?? id3));
            this.errorFromChildren = this.computeChildErrors();
          } else if (this.errorFromChildren && this.childErrors.has(id3)) {
            this.childErrors.delete(id3);
            this.errorFromChildren = this.computeChildErrors();
          }
          if (this.shouldSendUpdates()) {
            if (this.value.type === "loaded") {
              this.updateValue(
                createCoValue(this.schema, this.value.value._raw, this)
              );
            }
          }
          this.triggerUpdate();
        };
        this.subscribers = /* @__PURE__ */ new Set();
        this.resolve = resolve;
        this.value = { type: "unloaded", id: id2 };
        let lastUpdate;
        this.subscription = new CoValueCoreSubscription(
          node,
          id2,
          (value) => {
            lastUpdate = value;
            if (skipRetry && value === "unavailable") {
              this.handleUpdate(value);
              this.destroy();
              return;
            }
            if (!this.migrated && value !== "unavailable") {
              if (this.migrating) {
                return;
              }
              this.migrating = true;
              applyCoValueMigrations(instantiateRefEncoded(this.schema, value));
              this.migrated = true;
              this.handleUpdate(lastUpdate);
              return;
            }
            this.handleUpdate(value);
          },
          skipRetry
        );
      }
      updateValue(value) {
        this.value = value;
        this.dirty = true;
      }
      handleUpdate(update) {
        if (update === "unavailable") {
          if (this.value.type === "unloaded") {
            this.updateValue(
              new JazzError(this.id, "unavailable", [
                {
                  code: "unavailable",
                  message: "The value is unavailable",
                  params: {
                    id: this.id
                  },
                  path: []
                }
              ])
            );
          }
          this.triggerUpdate();
          return;
        }
        const ruleset = update.core.verified.header.ruleset;
        const hasAccess = ruleset.type !== "ownedByGroup" || getOwnerFromRawValue(update).myRole() !== void 0;
        if (!hasAccess) {
          if (this.value.type !== "unauthorized") {
            this.updateValue(
              new JazzError(this.id, "unauthorized", [
                {
                  code: "unauthorized",
                  message: `The current user (${this.node.getCurrentAgent().id}) is not authorized to access this value`,
                  params: {
                    id: this.id
                  },
                  path: []
                }
              ])
            );
            this.triggerUpdate();
          }
          return;
        }
        this.silenceUpdates = true;
        if (this.value.type !== "loaded") {
          this.updateValue(createCoValue(this.schema, update, this));
          this.loadChildren();
        } else {
          const hasChanged = update.totalValidTransactions !== this.totalValidTransactions || // Checking the identity of the _raw value makes us cover the cases where the group
          // has been updated and the coValues that don't update the totalValidTransactions value (e.g. FileStream)
          this.value.value._raw !== update;
          if (this.loadChildren()) {
            this.updateValue(createCoValue(this.schema, update, this));
          } else if (hasChanged) {
            this.updateValue(createCoValue(this.schema, update, this));
          }
        }
        this.totalValidTransactions = update.totalValidTransactions;
        this.silenceUpdates = false;
        this.triggerUpdate();
      }
      computeChildErrors() {
        let issues = [];
        let errorType = "unavailable";
        if (this.childErrors.size === 0 && this.validationErrors.size === 0) {
          return void 0;
        }
        for (const [key, value] of this.childErrors.entries()) {
          if (this.autoloaded.has(key)) {
            continue;
          }
          if (this.skipInvalidKeys.has(key)) {
            continue;
          }
          errorType = value.type;
          if (value.issues) {
            issues.push(...value.issues);
          }
        }
        for (const [key, value] of this.validationErrors.entries()) {
          if (this.skipInvalidKeys.has(key)) {
            continue;
          }
          errorType = value.type;
          if (value.issues) {
            issues.push(...value.issues);
          }
        }
        if (issues.length) {
          return new JazzError(this.id, errorType, issues);
        }
        return void 0;
      }
      shouldSendUpdates() {
        if (this.value.type === "unloaded") return false;
        if (this.value.type !== "loaded") return true;
        if (this.isStreaming() && !this.isFileStream()) {
          return false;
        }
        for (const value of this.childValues.values()) {
          if (value.type === "unloaded" && !this.autoloaded.has(value.id)) {
            return false;
          }
        }
        return true;
      }
      getCurrentValue() {
        if (this.value.type === "unauthorized" || this.value.type === "unavailable") {
          console.error(this.value.toString());
          return null;
        }
        if (!this.shouldSendUpdates()) {
          return void 0;
        }
        if (this.errorFromChildren) {
          console.error(this.errorFromChildren.toString());
          return null;
        }
        if (this.value.type === "loaded") {
          return this.value.value;
        }
        return void 0;
      }
      isStreaming() {
        if (this.value.type !== "loaded") {
          return false;
        }
        return this.value.value._raw.core.verified.isStreaming();
      }
      isFileStream() {
        var _a;
        if (this.value.type !== "loaded") {
          return false;
        }
        return ((_a = this.value.value._raw.core.verified.header.meta) == null ? void 0 : _a.type) === "binary";
      }
      triggerUpdate() {
        if (!this.shouldSendUpdates()) return;
        if (!this.dirty) return;
        if (this.subscribers.size === 0) return;
        if (this.silenceUpdates) return;
        const error2 = this.errorFromChildren;
        const value = this.value;
        if (error2) {
          this.subscribers.forEach((listener) => listener(error2));
        } else if (value.type !== "unloaded") {
          this.subscribers.forEach((listener) => listener(value));
        }
        this.dirty = false;
      }
      subscribe(listener) {
        this.subscribers.add(listener);
        return () => {
          this.subscribers.delete(listener);
        };
      }
      setListener(listener) {
        this.subscribers.add(listener);
        this.triggerUpdate();
      }
      subscribeToKey(key) {
        if (this.resolve === true || !this.resolve) {
          this.resolve = {};
        }
        if (this.resolve.$each || key in this.resolve) {
          return;
        }
        const resolve = this.resolve;
        resolve[key] = true;
        this.autoloadedKeys.add(key);
        if (this.value.type !== "loaded") {
          return;
        }
        const value = this.value.value;
        this.silenceUpdates = true;
        if (value._type === "CoMap" || value._type === "Account") {
          const map2 = value;
          this.loadCoMapKey(map2, key, true);
        } else if (value._type === "CoList") {
          const list = value;
          this.loadCoListKey(list, key, true);
        }
        this.silenceUpdates = false;
      }
      subscribeToId(id2, descriptor) {
        if (this.idsSubscribed.has(id2) || this.childValues.has(id2)) {
          return;
        }
        this.idsSubscribed.add(id2);
        this.autoloaded.add(id2);
        this.silenceUpdates = true;
        this.childValues.set(id2, { type: "unloaded", id: id2 });
        const child = new _SubscriptionScope(
          this.node,
          true,
          id2,
          descriptor
        );
        this.childNodes.set(id2, child);
        child.setListener((value) => this.handleChildUpdate(id2, value));
        this.silenceUpdates = false;
      }
      loadChildren() {
        const { resolve } = this;
        if (this.value.type !== "loaded") {
          return false;
        }
        const value = this.value.value;
        const depth = typeof resolve !== "object" || resolve === null ? {} : resolve;
        let hasChanged = false;
        const idsToLoad = new Set(this.idsSubscribed);
        const coValueType = value._type;
        if (Object.keys(depth).length > 0) {
          if (coValueType === "CoMap" || coValueType === "Account") {
            const map2 = value;
            const keys = "$each" in depth ? map2._raw.keys() : Object.keys(depth);
            for (const key of keys) {
              const id2 = this.loadCoMapKey(map2, key, depth[key] ?? depth.$each);
              if (id2) {
                idsToLoad.add(id2);
              }
            }
          } else if (value._type === "CoList") {
            const list = value;
            const descriptor = list.getItemsDescriptor();
            if (descriptor && isRefEncoded(descriptor)) {
              list._raw.processNewTransactions();
              const entries = list._raw.entries();
              const keys = "$each" in depth ? Object.keys(entries) : Object.keys(depth);
              for (const key of keys) {
                const id2 = this.loadCoListKey(list, key, depth[key] ?? depth.$each);
                if (id2) {
                  idsToLoad.add(id2);
                }
              }
            }
          } else if (value._type === "CoStream") {
            const stream = value;
            const descriptor = stream.getItemsDescriptor();
            if (descriptor && isRefEncoded(descriptor)) {
              for (const session of stream._raw.sessions()) {
                const values = stream._raw.items[session] ?? [];
                for (const [i, item] of values.entries()) {
                  const key = `${session}/${i}`;
                  if (!depth.$each && !depth[key]) {
                    continue;
                  }
                  const id2 = item.value;
                  if (id2) {
                    idsToLoad.add(id2);
                    this.loadChildNode(id2, depth[key] ?? depth.$each, descriptor);
                    this.validationErrors.delete(key);
                  } else if (!descriptor.optional) {
                    this.validationErrors.set(
                      key,
                      new JazzError(void 0, "unavailable", [
                        {
                          code: "validationError",
                          message: `The ref on position ${key} requested on ${stream.constructor.name} is missing`,
                          params: {},
                          path: [key]
                        }
                      ])
                    );
                  }
                }
              }
            }
          }
        }
        this.errorFromChildren = this.computeChildErrors();
        for (const id2 of this.childNodes.keys()) {
          if (!idsToLoad.has(id2)) {
            hasChanged = true;
            const childNode = this.childNodes.get(id2);
            if (childNode) {
              childNode.destroy();
            }
            this.childNodes.delete(id2);
            this.childValues.delete(id2);
          }
        }
        return hasChanged;
      }
      loadCoMapKey(map2, key, depth) {
        if (key === "$onError") {
          return void 0;
        }
        const id2 = map2._raw.get(key);
        const descriptor = map2.getDescriptor(key);
        if (!descriptor) {
          this.childErrors.set(
            key,
            new JazzError(void 0, "unavailable", [
              {
                code: "validationError",
                message: `The ref ${key} requested on ${map2.constructor.name} is not defined in the schema`,
                params: {},
                path: [key]
              }
            ])
          );
          return void 0;
        }
        if (isRefEncoded(descriptor)) {
          if (id2) {
            this.loadChildNode(id2, depth, descriptor, key);
            this.validationErrors.delete(key);
            return id2;
          } else if (!descriptor.optional) {
            this.validationErrors.set(
              key,
              new JazzError(void 0, "unavailable", [
                {
                  code: "validationError",
                  message: `The ref ${key} requested on ${map2.constructor.name} is missing`,
                  params: {},
                  path: [key]
                }
              ])
            );
          }
        }
        return void 0;
      }
      loadCoListKey(list, key, depth) {
        const descriptor = list.getItemsDescriptor();
        if (!descriptor || !isRefEncoded(descriptor)) {
          return void 0;
        }
        const entries = list._raw.entries();
        const entry = entries[Number(key)];
        if (!entry) {
          return void 0;
        }
        const id2 = entry.value;
        if (id2) {
          this.loadChildNode(id2, depth, descriptor, key);
          this.validationErrors.delete(key);
          return id2;
        } else if (!descriptor.optional) {
          this.validationErrors.set(
            key,
            new JazzError(void 0, "unavailable", [
              {
                code: "validationError",
                message: `The ref on position ${key} requested on ${list.constructor.name} is missing`,
                params: {},
                path: [key]
              }
            ])
          );
        }
        return void 0;
      }
      loadChildNode(id2, query, descriptor, key) {
        if (this.childValues.has(id2)) {
          return;
        }
        if (key && this.autoloadedKeys.has(key)) {
          this.autoloaded.add(id2);
        }
        const skipInvalid = typeof query === "object" && query.$onError === null;
        if (skipInvalid) {
          if (key) {
            this.skipInvalidKeys.add(key);
          }
          this.skipInvalidKeys.add(id2);
        }
        const resolve = typeof query === "object" && query !== null ? { ...query } : query;
        this.childValues.set(id2, { type: "unloaded", id: id2 });
        const child = new _SubscriptionScope(
          this.node,
          resolve,
          id2,
          descriptor
        );
        this.childNodes.set(id2, child);
        child.setListener((value) => this.handleChildUpdate(id2, value, key));
      }
      destroy() {
        this.subscription.unsubscribe();
        this.subscribers.clear();
        this.childNodes.forEach((child) => child.destroy());
      }
    };
    function getSubscriptionScope(value) {
      const subscriptionScope = value._subscriptionScope;
      if (subscriptionScope) {
        return subscriptionScope;
      }
      const node = value._raw.core.node;
      const resolve = true;
      const id2 = value.id;
      const newSubscriptionScope = new SubscriptionScope(node, resolve, id2, {
        ref: value.constructor,
        optional: false
      });
      Object.defineProperty(value, "_subscriptionScope", {
        value: subscriptionScope,
        writable: false,
        enumerable: false,
        configurable: false
      });
      return newSubscriptionScope;
    }
    function accessChildByKey(parent, childId, key) {
      const subscriptionScope = getSubscriptionScope(parent);
      if (!subscriptionScope.childValues.has(childId)) {
        subscriptionScope.subscribeToKey(key);
      }
      const value = subscriptionScope.childValues.get(childId);
      if ((value == null ? void 0 : value.type) === "loaded") {
        return value.value;
      } else {
        return null;
      }
    }
    function accessChildById(parent, childId, schema) {
      const subscriptionScope = getSubscriptionScope(parent);
      subscriptionScope.subscribeToId(childId, schema);
      const value = subscriptionScope.childValues.get(childId);
      if ((value == null ? void 0 : value.type) === "loaded") {
        return value.value;
      } else {
        return null;
      }
    }
    async function createJazzContextFromExistingCredentials({
      credentials,
      peersToLoadFrom,
      crypto: crypto2,
      storage,
      AccountSchema: PropsAccountSchema,
      sessionProvider,
      onLogOut
    }) {
      const { sessionID, sessionDone } = await sessionProvider(
        credentials.accountID,
        crypto2
      );
      const CurrentAccountSchema = PropsAccountSchema ?? RegisteredSchemas["Account"];
      const AccountClass = anySchemaToCoSchema(CurrentAccountSchema);
      const node = await LocalNode.withLoadedAccount({
        accountID: credentials.accountID,
        accountSecret: credentials.secret,
        sessionID,
        peersToLoadFrom,
        crypto: crypto2,
        storage,
        migration: async (rawAccount, _node, creationProps) => {
          const account2 = AccountClass.fromRaw(rawAccount);
          activeAccountContext.set(account2);
          await account2.applyMigration(creationProps);
        }
      });
      const account = AccountClass.fromNode(node);
      activeAccountContext.set(account);
      return {
        node,
        account,
        done: () => {
          node.gracefulShutdown();
          sessionDone();
        },
        logOut: async () => {
          node.gracefulShutdown();
          sessionDone();
          await (onLogOut == null ? void 0 : onLogOut());
        }
      };
    }
    async function createJazzContextForNewAccount({
      creationProps,
      initialAgentSecret,
      peersToLoadFrom,
      crypto: crypto2,
      AccountSchema: PropsAccountSchema,
      onLogOut,
      storage
    }) {
      const CurrentAccountSchema = PropsAccountSchema ?? RegisteredSchemas["Account"];
      const AccountClass = anySchemaToCoSchema(CurrentAccountSchema);
      const { node } = await LocalNode.withNewlyCreatedAccount({
        creationProps,
        peersToLoadFrom,
        crypto: crypto2,
        initialAgentSecret,
        storage,
        migration: async (rawAccount, _node, creationProps2) => {
          const account2 = AccountClass.fromRaw(rawAccount);
          activeAccountContext.set(account2);
          await account2.applyMigration(creationProps2);
        }
      });
      const account = AccountClass.fromNode(node);
      activeAccountContext.set(account);
      return {
        node,
        account,
        done: () => {
          node.gracefulShutdown();
        },
        logOut: async () => {
          node.gracefulShutdown();
          await (onLogOut == null ? void 0 : onLogOut());
        }
      };
    }
    async function createJazzContext(options) {
      var _a, _b;
      const crypto2 = options.crypto;
      let context;
      const authSecretStorage = options.authSecretStorage;
      await authSecretStorage.migrate();
      const credentials = options.credentials ?? await authSecretStorage.get();
      if (credentials && !options.newAccountProps) {
        context = await createJazzContextFromExistingCredentials({
          credentials: {
            accountID: credentials.accountID,
            secret: credentials.accountSecret
          },
          peersToLoadFrom: options.peersToLoadFrom,
          crypto: crypto2,
          AccountSchema: options.AccountSchema,
          sessionProvider: options.sessionProvider,
          onLogOut: () => {
            authSecretStorage.clearWithoutNotify();
          },
          storage: options.storage
        });
      } else {
        const secretSeed = options.crypto.newRandomSecretSeed();
        const initialAgentSecret = ((_a = options.newAccountProps) == null ? void 0 : _a.secret) ?? crypto2.agentSecretFromSecretSeed(secretSeed);
        const creationProps = ((_b = options.newAccountProps) == null ? void 0 : _b.creationProps) ?? {
          name: options.defaultProfileName ?? "Anonymous user"
        };
        context = await createJazzContextForNewAccount({
          creationProps,
          initialAgentSecret,
          peersToLoadFrom: options.peersToLoadFrom,
          crypto: crypto2,
          AccountSchema: options.AccountSchema,
          onLogOut: async () => {
            await authSecretStorage.clearWithoutNotify();
          },
          storage: options.storage
        });
        if (!options.newAccountProps) {
          await authSecretStorage.setWithoutNotify({
            accountID: context.account.id,
            secretSeed,
            accountSecret: context.node.getCurrentAgent().agentSecret,
            provider: "anonymous"
          });
        }
      }
      return {
        ...context,
        authSecretStorage
      };
    }
    function createAnonymousJazzContext({
      peersToLoadFrom,
      crypto: crypto2,
      storage
    }) {
      const agentSecret = crypto2.newRandomAgentSecret();
      const node = new LocalNode(
        agentSecret,
        crypto2.newRandomSessionID(crypto2.getAgentID(agentSecret)),
        crypto2
      );
      for (const peer of peersToLoadFrom) {
        node.syncManager.addPeer(peer);
      }
      if (storage) {
        node.setStorage(storage);
      }
      activeAccountContext.setGuestMode();
      return {
        agent: new AnonymousJazzAgent(node),
        done: () => {
        },
        logOut: async () => {
        }
      };
    }
    function isZodObject(schema) {
      var _a;
      return ((_a = schema.def) == null ? void 0 : _a.type) === "object";
    }
    function isZodArray(schema) {
      var _a;
      return ((_a = schema.def) == null ? void 0 : _a.type) === "array";
    }
    function isZodCustom(schema) {
      var _a;
      return ((_a = schema.def) == null ? void 0 : _a.type) === "custom";
    }
    function getDef(schema) {
      return schema.def;
    }
    function enrichRichTextSchema(schema, coValueClass) {
      return Object.assign(schema, {
        create: (...args) => {
          return coValueClass.create(...args);
        },
        load: (...args) => {
          return coValueClass.load(...args);
        },
        subscribe: (...args) => {
          return coValueClass.subscribe(...args);
        },
        getCoValueClass: () => {
          return coValueClass;
        }
      });
    }
    function schemaUnionDiscriminatorFor(schema) {
      if (isUnionOfCoMapsDeeply(schema)) {
        if (!schema._zod.disc || schema._zod.disc.size == 0) {
          throw new Error(
            "z.union() of collaborative types is not supported, use co.discriminatedUnion() instead"
          );
        }
        const discriminator = schema._zod.def.discriminator;
        const field = schema._zod.disc.get(discriminator);
        if (!field) {
          throw new Error(
            "co.discriminatedUnion() of collaborative types with non-existent discriminator key is not supported"
          );
        }
        for (const value of field.values) {
          if (typeof value !== "string" && typeof value !== "number") {
            throw new Error(
              "co.discriminatedUnion() of collaborative types with non-string or non-number discriminator value is not supported"
            );
          }
        }
        const availableOptions = [];
        for (const option of schema._zod.def.options) {
          if (option._zod.def.type === "object") {
            availableOptions.push(option);
          } else if (option._zod.def.type === "union") {
            for (const subOption of option._zod.def.options) {
              if (subOption._zod.def.type === "object") {
                availableOptions.push(subOption);
              }
            }
          } else {
            throw new Error(
              "Unsupported zod type in co.discriminatedUnion() of collaborative types"
            );
          }
        }
        const determineSchema = (_raw) => {
          if (_raw instanceof RawCoList) {
            throw new Error(
              "co.discriminatedUnion() of collaborative types is not supported for CoLists"
            );
          }
          for (const option of availableOptions) {
            let match = true;
            for (const key of schema._zod.disc.keys()) {
              const discriminatorDef = option._zod.def.shape[key];
              const discriminatorValue = _raw.get(key);
              if (discriminatorValue && typeof discriminatorValue === "object") {
                throw new Error("Discriminator must be a primitive value");
              }
              if (!discriminatorDef) {
                if (key === discriminator) {
                  match = false;
                  break;
                } else {
                  continue;
                }
              }
              if (discriminatorDef._zod.def.type !== "literal") {
                break;
              }
              const literalDef = discriminatorDef._zod.def;
              if (!Array.from(literalDef.values).includes(discriminatorValue)) {
                match = false;
                break;
              }
            }
            if (match) {
              const coValueSchema = zodSchemaToCoSchema(option);
              return coValueSchema.getCoValueClass();
            }
          }
          throw new Error(
            "co.discriminatedUnion() of collaborative types with no matching discriminator value found"
          );
        };
        return determineSchema;
      } else {
        throw new Error(
          "z.discriminatedUnion() of non-collaborative types is not supported"
        );
      }
    }
    function isUnionOfCoMapsDeeply(schema) {
      if (schema instanceof $ZodUnion) {
        return schema._zod.def.options.every(isCoMapOrUnionOfCoMapsDeeply);
      } else {
        return false;
      }
    }
    function isCoMapOrUnionOfCoMapsDeeply(schema) {
      if (schema instanceof $ZodObject && isAnyCoValueSchema(schema)) {
        return true;
      } else if (schema instanceof $ZodUnion) {
        return schema._zod.def.options.every(isCoMapOrUnionOfCoMapsDeeply);
      } else {
        return false;
      }
    }
    function isUnionOfPrimitivesDeeply(schema) {
      if (schema instanceof $ZodUnion) {
        return schema._zod.def.options.every(isUnionOfPrimitivesDeeply);
      } else {
        return !isAnyCoValueSchema(schema);
      }
    }
    function schemaFieldToCoFieldDef(schema) {
      var _a, _b;
      if (isCoValueClass(schema)) {
        return coField.ref(schema);
      } else if (isCoValueSchema(schema)) {
        if (isAnyCoOptionalSchema(schema)) {
          return coField.ref(schema.getCoValueClass(), {
            optional: true
          });
        }
        return coField.ref(schema.getCoValueClass());
      } else {
        if ("_zod" in schema) {
          if (schema._zod.def.type === "optional") {
            const inner = zodSchemaToCoSchemaOrKeepPrimitive(
              schema._zod.def.innerType
            );
            if (isCoValueClass(inner)) {
              return coField.ref(inner, { optional: true });
            } else {
              return schemaFieldToCoFieldDef(inner);
            }
          } else if (schema._zod.def.type === "string") {
            return coField.string;
          } else if (schema._zod.def.type === "number") {
            return coField.number;
          } else if (schema._zod.def.type === "boolean") {
            return coField.boolean;
          } else if (schema._zod.def.type === "null") {
            return coField.null;
          } else if (schema._zod.def.type === "enum") {
            return coField.string;
          } else if (schema._zod.def.type === "readonly") {
            return schemaFieldToCoFieldDef(
              schema.def.innerType
            );
          } else if (schema._zod.def.type === "date") {
            return coField.optional.Date;
          } else if (schema._zod.def.type === "template_literal") {
            return coField.string;
          } else if (schema._zod.def.type === "lazy") {
            return schemaFieldToCoFieldDef(
              schema.unwrap()
            );
          } else if (schema._zod.def.type === "default" || schema._zod.def.type === "catch") {
            console.warn(
              "z.default()/z.catch() are not supported in collaborative schemas. They will be ignored."
            );
            return schemaFieldToCoFieldDef(
              schema.def.innerType
            );
          } else if (schema._zod.def.type === "literal") {
            if (schema._zod.def.values.some(
              (literal2) => typeof literal2 === "undefined"
            )) {
              throw new Error("z.literal() with undefined is not supported");
            }
            if (schema._zod.def.values.some((literal2) => literal2 === null)) {
              throw new Error("z.literal() with null is not supported");
            }
            if (schema._zod.def.values.some((literal2) => typeof literal2 === "bigint")) {
              throw new Error("z.literal() with bigint is not supported");
            }
            return coField.literal(
              ...schema._zod.def.values
            );
          } else if (schema._zod.def.type === "object" || schema._zod.def.type === "array" || schema._zod.def.type === "tuple") {
            return coField.json();
          } else if (schema._zod.def.type === "custom") {
            if ("builtin" in schema) {
              return schemaFieldToCoFieldDef(schema.builtin);
            } else {
              throw new Error(`Unsupported custom zod type`);
            }
          } else if (schema._zod.def.type === "union") {
            if (isUnionOfPrimitivesDeeply(schema)) {
              return coField.json();
            } else if (isUnionOfCoMapsDeeply(schema)) {
              return coField.ref(
                schemaUnionDiscriminatorFor(schema)
              );
            } else {
              throw new Error(
                "z.union()/z.discriminatedUnion() of mixed collaborative and non-collaborative types is not supported"
              );
            }
          } else {
            throw new Error(
              `Unsupported zod type: ${((_b = (_a = schema._zod) == null ? void 0 : _a.def) == null ? void 0 : _b.type) || JSON.stringify(schema)}`
            );
          }
        } else {
          throw new Error(`Unsupported zod type: ${schema}`);
        }
      }
    }
    var coSchemasForZodSchemas = /* @__PURE__ */ new Map();
    function isAnyCoValueSchema(schema) {
      return "collaborative" in schema && schema.collaborative === true;
    }
    function isCoValueSchema(schema) {
      return isAnyCoValueSchema(schema) && "getCoValueClass" in schema;
    }
    function tryZodSchemaToCoSchema(schema) {
      var _a, _b;
      if (isAnyCoValueSchema(schema)) {
        if (coSchemasForZodSchemas.has(schema)) {
          return coSchemasForZodSchemas.get(
            schema
          );
        }
        if (isAnyCoOptionalSchema(schema)) {
          return null;
        } else if (isZodObject(schema)) {
          const def = getDef(schema);
          const ClassToExtend = "builtin" in schema && schema.builtin === "Account" ? Account : CoMap;
          const coValueClass = class ZCoMap extends ClassToExtend {
            constructor(options) {
              super(options);
              for (const [field, fieldType] of Object.entries(
                def.shape
              )) {
                this[field] = schemaFieldToCoFieldDef(
                  zodSchemaToCoSchemaOrKeepPrimitive(fieldType)
                );
              }
              if (def.catchall) {
                this[coField.items] = schemaFieldToCoFieldDef(
                  zodSchemaToCoSchemaOrKeepPrimitive(def.catchall)
                );
              }
            }
          };
          const coValueSchema = ClassToExtend === Account ? enrichAccountSchema(schema, coValueClass) : enrichCoMapSchema(schema, coValueClass);
          coSchemasForZodSchemas.set(schema, coValueSchema);
          return coValueSchema;
        } else if (isZodArray(schema)) {
          const def = getDef(schema);
          const coValueClass = class ZCoList extends CoList {
            constructor(options) {
              super(options);
              this[coField.items] = schemaFieldToCoFieldDef(
                zodSchemaToCoSchemaOrKeepPrimitive(def.element)
              );
            }
          };
          const coValueSchema = enrichCoListSchema(schema, coValueClass);
          coSchemasForZodSchemas.set(schema, coValueSchema);
          return coValueSchema;
        } else if (isZodCustom(schema)) {
          if ("builtin" in schema) {
            if (schema.builtin === "CoFeed" && "element" in schema) {
              const coValueClass = CoFeed.Of(
                schemaFieldToCoFieldDef(
                  zodSchemaToCoSchemaOrKeepPrimitive(
                    schema.element
                  )
                )
              );
              const coValueSchema = enrichCoFeedSchema(schema, coValueClass);
              return coValueSchema;
            } else if (schema.builtin === "FileStream") {
              const coValueClass = FileStream;
              const coValueSchema = enrichFileStreamSchema(schema, coValueClass);
              return coValueSchema;
            } else if (schema.builtin === "CoPlainText") {
              const coValueClass = CoPlainText;
              const coValueSchema = enrichPlainTextSchema(schema, coValueClass);
              return coValueSchema;
            } else if (schema.builtin === "CoRichText") {
              const coValueClass = CoRichText;
              const coValueSchema = enrichRichTextSchema(schema, coValueClass);
              return coValueSchema;
            } else {
              throw new Error(`Unsupported builtin type: ${schema.builtin}`);
            }
          } else {
            throw new Error(`Unsupported custom zod type`);
          }
        } else {
          throw new Error(
            `Unsupported zod CoValue type for top-level schema: ${((_b = (_a = schema._zod) == null ? void 0 : _a.def) == null ? void 0 : _b.type) || JSON.stringify(schema, void 0, 2)}`
          );
        }
      } else if (schema instanceof $ZodDiscriminatedUnion) {
        if (isUnionOfCoMapsDeeply(schema)) {
          const coValueClass = SchemaUnion.Of(schemaUnionDiscriminatorFor(schema));
          const coValueSchema = enrichCoDiscriminatedUnionSchema(
            schema,
            coValueClass
          );
          return coValueSchema;
        } else {
          throw new Error(
            "z.discriminatedUnion() of non-collaborative types is not supported as a top-level schema"
          );
        }
      } else {
        return null;
      }
    }
    function zodSchemaToCoSchema(schema) {
      var _a, _b;
      const coSchema = tryZodSchemaToCoSchema(schema);
      if (!coSchema) {
        throw new Error(
          `Unsupported zod type: ${((_b = (_a = schema._zod) == null ? void 0 : _a.def) == null ? void 0 : _b.type) || JSON.stringify(schema)}`
        );
      }
      return coSchema;
    }
    function anySchemaToCoSchema(schema) {
      var _a;
      if (isCoValueClass(schema)) {
        return schema;
      } else if (isCoValueSchema(schema)) {
        return schema.getCoValueClass();
      } else if ("def" in schema) {
        const coSchema = tryZodSchemaToCoSchema(
          schema
        );
        if (!coSchema) {
          throw new Error(
            `Unsupported zod type: ${((_a = schema.def) == null ? void 0 : _a.type) || JSON.stringify(schema)}`
          );
        }
        return coSchema.getCoValueClass();
      }
      throw new Error(`Unsupported schema: ${JSON.stringify(schema)}`);
    }
    function zodSchemaToCoSchemaOrKeepPrimitive(schema) {
      const coSchema = tryZodSchemaToCoSchema(schema);
      if (!coSchema) {
        return schema;
      }
      return coSchema;
    }
    function createCoOptionalSchema(schema) {
      return Object.assign(optional(schema), {
        collaborative: true,
        getCoValueClass: () => {
          return schema.getCoValueClass();
        }
      });
    }
    function isAnyCoOptionalSchema(schema) {
      return isAnyCoValueSchema(schema) && schema._zod.def.type === "optional";
    }
    var coMapDefiner = (shape) => {
      const objectSchema = object(shape).meta({
        collaborative: true
      });
      const enrichedSchema = Object.assign(objectSchema, {
        collaborative: true
      });
      return zodSchemaToCoSchema(enrichedSchema);
    };
    var coAccountDefiner = (shape = {
      profile: coMapDefiner({
        name: string(),
        inbox: optional(string()),
        inboxInvite: optional(string())
      }),
      root: coMapDefiner({})
    }) => {
      const schema = object(shape).meta({
        collaborative: true
      });
      const enrichedSchema = Object.assign(schema, {
        collaborative: true,
        builtin: "Account"
      });
      return zodSchemaToCoSchema(enrichedSchema);
    };
    var coRecordDefiner = (_keyType, valueType) => {
      return coMapDefiner({}).catchall(valueType);
    };
    var coListDefiner = (element) => {
      const schema = array$1(element).meta({
        collaborative: true
      });
      const enrichedSchema = Object.assign(schema, {
        collaborative: true
      });
      return zodSchemaToCoSchema(enrichedSchema);
    };
    var coProfileDefiner = (shape = {}) => {
      const ehnancedShape = Object.assign(shape, {
        name: string(),
        inbox: optional(string()),
        inboxInvite: optional(string())
      });
      return coMapDefiner(ehnancedShape);
    };
    var coFeedDefiner = (element) => {
      const schema = _instanceof(CoFeed);
      const enrichedSchema = Object.assign(schema, {
        collaborative: true,
        builtin: "CoFeed",
        element
      });
      return zodSchemaToCoSchema(enrichedSchema);
    };
    var coFileStreamDefiner = () => {
      const schema = _instanceof(FileStream);
      const enrichedSchema = Object.assign(schema, {
        collaborative: true,
        builtin: "FileStream"
      });
      return zodSchemaToCoSchema(enrichedSchema);
    };
    var coPlainTextDefiner = () => {
      const schema = _instanceof(CoPlainText);
      const enrichedSchema = Object.assign(schema, {
        collaborative: true,
        builtin: "CoPlainText"
      });
      return zodSchemaToCoSchema(enrichedSchema);
    };
    var coRichTextDefiner = () => {
      const schema = _instanceof(CoRichText);
      const enrichedSchema = Object.assign(schema, {
        collaborative: true,
        builtin: "CoRichText"
      });
      return zodSchemaToCoSchema(enrichedSchema);
    };
    var coImageDefiner = () => {
      return ImageDefinition;
    };
    var coOptionalDefiner = (schema) => {
      return createCoOptionalSchema(schema);
    };
    var coDiscriminatedUnionDefiner = (discriminator, schemas) => {
      const schema = discriminatedUnion(discriminator, schemas);
      return zodSchemaToCoSchema(schema);
    };
    var coExport_exports = {};
    __export(coExport_exports, {
      account: () => coAccountDefiner,
      discriminatedUnion: () => coDiscriminatedUnionDefiner,
      feed: () => coFeedDefiner,
      fileStream: () => coFileStreamDefiner,
      image: () => coImageDefiner,
      list: () => coListDefiner,
      map: () => coMapDefiner,
      optional: () => coOptionalDefiner,
      plainText: () => coPlainTextDefiner,
      profile: () => coProfileDefiner,
      record: () => coRecordDefiner,
      richText: () => coRichTextDefiner
    });
    function enrichCoMapSchema(schema, coValueClass) {
      const baseCatchall = schema.catchall;
      const coValueSchema = Object.assign(schema, {
        create: (...args) => {
          return coValueClass.create(...args);
        },
        load: (...args) => {
          return coValueClass.load(...args);
        },
        subscribe: (...args) => {
          return coValueClass.subscribe(...args);
        },
        findUnique: (...args) => {
          return coValueClass.findUnique(...args);
        },
        upsertUnique: (...args) => {
          return coValueClass.upsertUnique(...args);
        },
        loadUnique: (...args) => {
          return coValueClass.loadUnique(...args);
        },
        catchall: (index2) => {
          const newSchema = baseCatchall(index2);
          const enrichedSchema = Object.assign(newSchema, {
            collaborative: true
          });
          return zodSchemaToCoSchema(enrichedSchema);
        },
        withHelpers: (helpers) => {
          return Object.assign(schema, helpers(schema));
        },
        withMigration: (migration) => {
          coValueClass.prototype.migrate = migration;
          return coValueSchema;
        },
        getCoValueClass: () => {
          return coValueClass;
        }
      });
      return coValueSchema;
    }
    function enrichCoDiscriminatedUnionSchema(schema, coValueClass) {
      return Object.assign(schema, {
        load: (...args) => {
          return coValueClass.load(...args);
        },
        subscribe: (...args) => {
          return coValueClass.subscribe(...args);
        },
        getCoValueClass: () => {
          return coValueClass;
        }
      });
    }
    function enrichCoListSchema(schema, coValueClass) {
      return Object.assign(schema, {
        create: (...args) => {
          return coValueClass.create(...args);
        },
        load: (...args) => {
          return coValueClass.load(...args);
        },
        subscribe: (...args) => {
          return coValueClass.subscribe(...args);
        },
        withHelpers: (helpers) => {
          return Object.assign(schema, helpers(schema));
        },
        getCoValueClass: () => {
          return coValueClass;
        }
      });
    }
    function enrichCoFeedSchema(schema, coValueClass) {
      return Object.assign(schema, {
        create: (...args) => {
          return coValueClass.create(...args);
        },
        load: (...args) => {
          return coValueClass.load(...args);
        },
        subscribe: (...args) => {
          return coValueClass.subscribe(...args);
        },
        withHelpers: (helpers) => {
          return Object.assign(schema, helpers(schema));
        },
        getCoValueClass: () => {
          return coValueClass;
        }
      });
    }
    function enrichAccountSchema(schema, coValueClass) {
      const enrichedSchema = Object.assign(schema, {
        create: (...args) => {
          return coValueClass.create(...args);
        },
        createAs: (...args) => {
          return coValueClass.createAs(...args);
        },
        getMe: (...args) => {
          return coValueClass.getMe(...args);
        },
        load: (...args) => {
          return coValueClass.load(...args);
        },
        subscribe: (...args) => {
          return coValueClass.subscribe(...args);
        },
        withHelpers: (helpers) => {
          return Object.assign(schema, helpers(schema));
        },
        fromRaw: (...args) => {
          return coValueClass.fromRaw(...args);
        },
        withMigration: (migration) => {
          coValueClass.prototype.migrate = async function(creationProps) {
            await migration(this, creationProps);
          };
          return enrichedSchema;
        },
        getCoValueClass: () => {
          return coValueClass;
        }
      });
      return enrichedSchema;
    }
    function enrichFileStreamSchema(schema, coValueClass) {
      return Object.assign(schema, {
        create: (...args) => {
          return coValueClass.create(...args);
        },
        createFromBlob: (...args) => {
          return coValueClass.createFromBlob(...args);
        },
        load: (...args) => {
          return coValueClass.load(...args);
        },
        loadAsBlob: (...args) => {
          return coValueClass.loadAsBlob(...args);
        },
        subscribe: (...args) => {
          return coValueClass.subscribe(...args);
        },
        getCoValueClass: () => {
          return coValueClass;
        }
      });
    }
    function enrichPlainTextSchema(schema, coValueClass) {
      return Object.assign(schema, {
        create: (...args) => {
          return coValueClass.create(...args);
        },
        load: (...args) => {
          return coValueClass.load(...args);
        },
        subscribe: (...args) => {
          return coValueClass.subscribe(...args);
        },
        fromRaw: (...args) => {
          return coValueClass.fromRaw(...args);
        },
        getCoValueClass: () => {
          return coValueClass;
        }
      });
    }
    var ImageDefinitionBase = coMapDefiner({
      originalSize: tuple$1([number(), number()]),
      placeholderDataURL: string().optional()
    }).catchall(coFileStreamDefiner());
    var ImageDefinition = ImageDefinitionBase.withHelpers((Self) => ({
      highestResAvailable(imageDef, options) {
        var _a;
        const resolutions = Object.keys(imageDef).filter(
          (key) => key.match(/^\d+x\d+$/)
        );
        let maxWidth = options == null ? void 0 : options.maxWidth;
        if (options == null ? void 0 : options.targetWidth) {
          const targetWidth = options.targetWidth;
          const widths = resolutions.map((res) => Number(res.split("x")[0]));
          maxWidth = Math.min(...widths.filter((w) => w >= targetWidth));
        }
        const validResolutions = resolutions.filter(
          (key) => maxWidth === void 0 || Number(key.split("x")[0]) <= maxWidth
        );
        validResolutions.sort((a, b) => {
          const aWidth = Number(a.split("x")[0]);
          const bWidth = Number(b.split("x")[0]);
          return aWidth - bWidth;
        });
        let highestAvailableResolution;
        for (const resolution of validResolutions) {
          if (imageDef[resolution] && ((_a = imageDef[resolution]) == null ? void 0 : _a.getChunks())) {
            highestAvailableResolution = resolution;
          }
        }
        return highestAvailableResolution && {
          res: highestAvailableResolution,
          stream: imageDef[highestAvailableResolution]
        };
      }
    }));
    var KvStoreContext = class _KvStoreContext {
      constructor() {
        this.storageInstance = null;
      }
      static getInstance() {
        if (!_KvStoreContext.instance) {
          _KvStoreContext.instance = new _KvStoreContext();
        }
        return _KvStoreContext.instance;
      }
      isInitialized() {
        return this.storageInstance !== null;
      }
      initialize(store) {
        if (!this.storageInstance) {
          this.storageInstance = store;
        }
      }
      getStorage() {
        if (!this.storageInstance) {
          throw new Error("Storage instance is not initialized.");
        }
        return this.storageInstance;
      }
    };
    var KvStoreContext_default = KvStoreContext;
    var STORAGE_KEY = "jazz-logged-in-secret";
    var AuthSecretStorage = class {
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
        this.isAuthenticated = false;
      }
      async migrate() {
        const kvStore = KvStoreContext_default.getInstance().getStorage();
        if (!await kvStore.get(STORAGE_KEY)) {
          const demoAuthSecret = await kvStore.get("demo-auth-logged-in-secret");
          if (demoAuthSecret) {
            const parsed = JSON.parse(demoAuthSecret);
            await kvStore.set(
              STORAGE_KEY,
              JSON.stringify({
                accountID: parsed.accountID,
                accountSecret: parsed.accountSecret,
                provider: "demo"
              })
            );
            await kvStore.delete("demo-auth-logged-in-secret");
          }
          const clerkAuthSecret = await kvStore.get("jazz-clerk-auth");
          if (clerkAuthSecret) {
            const parsed = JSON.parse(clerkAuthSecret);
            await kvStore.set(
              STORAGE_KEY,
              JSON.stringify({
                accountID: parsed.accountID,
                accountSecret: parsed.secret,
                provider: "clerk"
              })
            );
            await kvStore.delete("jazz-clerk-auth");
          }
        }
        const value = await kvStore.get(STORAGE_KEY);
        if (value) {
          const parsed = JSON.parse(value);
          if ("secret" in parsed) {
            await kvStore.set(
              STORAGE_KEY,
              JSON.stringify({
                accountID: parsed.accountID,
                secretSeed: parsed.secretSeed,
                accountSecret: parsed.secret,
                provider: parsed.provider
              })
            );
          }
        }
      }
      async get() {
        const kvStore = KvStoreContext_default.getInstance().getStorage();
        const data2 = await kvStore.get(STORAGE_KEY);
        if (!data2) return null;
        const parsed = JSON.parse(data2);
        if (!parsed.accountID || !parsed.accountSecret) {
          throw new Error("Invalid auth secret storage data");
        }
        return {
          accountID: parsed.accountID,
          secretSeed: parsed.secretSeed ? new Uint8Array(parsed.secretSeed) : void 0,
          accountSecret: parsed.accountSecret,
          provider: parsed.provider
        };
      }
      async setWithoutNotify(payload) {
        const kvStore = KvStoreContext_default.getInstance().getStorage();
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: payload.accountID,
            secretSeed: payload.secretSeed ? Array.from(payload.secretSeed) : void 0,
            accountSecret: payload.accountSecret,
            provider: payload.provider
          })
        );
      }
      async set(payload) {
        this.setWithoutNotify(payload);
        this.emitUpdate(payload);
      }
      getIsAuthenticated(data2) {
        if (!data2) return false;
        return data2.provider !== "anonymous";
      }
      onUpdate(handler) {
        this.listeners.add(handler);
        return () => {
          this.listeners.delete(handler);
        };
      }
      emitUpdate(data2) {
        const isAuthenticated = this.getIsAuthenticated(data2);
        if (this.isAuthenticated === isAuthenticated) return;
        this.isAuthenticated = isAuthenticated;
        for (const listener of this.listeners) {
          listener(this.isAuthenticated);
        }
      }
      async clearWithoutNotify() {
        const kvStore = KvStoreContext_default.getInstance().getStorage();
        await kvStore.delete(STORAGE_KEY);
      }
      async clear() {
        await this.clearWithoutNotify();
        this.emitUpdate(null);
      }
    };
    var InMemoryKVStore = class {
      constructor() {
        this.store = {};
      }
      async get(key) {
        const data2 = this.store[key];
        if (!data2) return null;
        return data2;
      }
      async set(key, value) {
        this.store[key] = value;
      }
      async delete(key) {
        delete this.store[key];
      }
      async clearAll() {
        this.store = {};
      }
    };
    function getAnonymousFallback() {
      const context = createAnonymousJazzContext({
        peersToLoadFrom: [],
        crypto: new PureJSCrypto()
      });
      return {
        guest: context.agent,
        node: context.agent.node,
        done: () => {
        },
        logOut: async () => {
        },
        isAuthenticated: false,
        authenticate: async () => {
        },
        register: async () => {
          throw new Error("Not implemented");
        }
      };
    }
    var JazzContextManager = class {
      constructor(opts) {
        this.authSecretStorage = new AuthSecretStorage();
        this.keepContextOpen = false;
        this.logOut = async () => {
          var _a, _b;
          if (!this.context || !this.props) {
            return;
          }
          await ((_b = (_a = this.props).onLogOut) == null ? void 0 : _b.call(_a));
          if (this.props.logOutReplacement) {
            await this.props.logOutReplacement();
          } else {
            await this.context.logOut();
            return this.createContext(this.props);
          }
        };
        this.done = () => {
          if (!this.context) {
            return;
          }
          this.context.done();
        };
        this.shouldMigrateAnonymousAccount = async () => {
          var _a;
          if (!((_a = this.props) == null ? void 0 : _a.onAnonymousAccountDiscarded)) {
            return false;
          }
          const prevCredentials = await this.authSecretStorage.get();
          const wasAnonymous = this.authSecretStorage.getIsAuthenticated(prevCredentials) === false;
          return wasAnonymous;
        };
        this.authenticate = async (credentials) => {
          if (!this.props) {
            throw new Error("Props required");
          }
          const prevContext = this.context;
          const migratingAnonymousAccount = await this.shouldMigrateAnonymousAccount();
          this.keepContextOpen = migratingAnonymousAccount;
          await this.createContext(this.props, { credentials }).finally(() => {
            this.keepContextOpen = false;
          });
          if (migratingAnonymousAccount) {
            await this.handleAnonymousAccountMigration(prevContext);
          }
        };
        this.register = async (accountSecret, creationProps) => {
          if (!this.props) {
            throw new Error("Props required");
          }
          const prevContext = this.context;
          const migratingAnonymousAccount = await this.shouldMigrateAnonymousAccount();
          this.keepContextOpen = migratingAnonymousAccount;
          await this.createContext(this.props, {
            newAccountProps: {
              secret: accountSecret,
              creationProps
            }
          }).finally(() => {
            this.keepContextOpen = false;
          });
          if (migratingAnonymousAccount) {
            await this.handleAnonymousAccountMigration(prevContext);
          }
          if (this.context && "me" in this.context) {
            return this.context.me.id;
          }
          throw new Error("The registration hasn't created a new account");
        };
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = (callback) => {
          this.listeners.add(callback);
          return () => {
            this.listeners.delete(callback);
          };
        };
        KvStoreContext.getInstance().initialize(this.getKvStore());
        if (opts == null ? void 0 : opts.useAnonymousFallback) {
          this.value = getAnonymousFallback();
        }
      }
      getKvStore() {
        return new InMemoryKVStore();
      }
      async createContext(props, authProps) {
        this.props = props;
        const { promise: promise2, resolve } = createResolvablePromise();
        const prevPromise = this.contextPromise;
        this.contextPromise = promise2;
        await prevPromise;
        try {
          const result = await this.getNewContext(props, authProps);
          await this.updateContext(props, result, authProps);
          resolve();
        } catch (error2) {
          resolve();
          throw error2;
        }
      }
      async getNewContext(props, authProps) {
        throw new Error("Not implemented");
      }
      async updateContext(props, context, authProps) {
        var _a;
        if (!this.keepContextOpen) {
          (_a = this.context) == null ? void 0 : _a.done();
        }
        this.context = context;
        this.props = props;
        this.value = {
          ...context,
          node: context.node,
          authenticate: this.authenticate,
          register: this.register,
          logOut: this.logOut
        };
        if (authProps == null ? void 0 : authProps.credentials) {
          this.authSecretStorage.emitUpdate(authProps.credentials);
        } else {
          this.authSecretStorage.emitUpdate(await this.authSecretStorage.get());
        }
        this.notify();
      }
      propsChanged(props) {
        throw new Error("Not implemented");
      }
      getCurrentValue() {
        return this.value;
      }
      setCurrentValue(value) {
        this.value = value;
      }
      getAuthSecretStorage() {
        return this.authSecretStorage;
      }
      async handleAnonymousAccountMigration(prevContext) {
        var _a, _b;
        if (!this.props) {
          throw new Error("Props required");
        }
        const currentContext = this.context;
        if (prevContext && currentContext && "me" in prevContext && "me" in currentContext) {
          const [prevAccountAsPeer, currentAccountAsPeer] = cojsonInternals.connectedPeers(
            prevContext.me.id,
            currentContext.me.id,
            {
              peer1role: "client",
              peer2role: "server"
            }
          );
          prevContext.node.removeStorage();
          currentContext.node.syncManager.addPeer(prevAccountAsPeer);
          prevContext.node.syncManager.addPeer(currentAccountAsPeer);
          try {
            await ((_b = (_a = this.props).onAnonymousAccountDiscarded) == null ? void 0 : _b.call(_a, prevContext.me));
            await prevContext.me.waitForAllCoValuesSync();
          } catch (error2) {
            console.error("Error onAnonymousAccountDiscarded", error2);
          }
          prevAccountAsPeer.outgoing.close();
          currentAccountAsPeer.outgoing.close();
        }
        prevContext == null ? void 0 : prevContext.done();
      }
      notify() {
        for (const listener of this.listeners) {
          listener();
        }
      }
    };
    function createResolvablePromise() {
      let resolve;
      const promise2 = new Promise((res) => {
        resolve = res;
      });
      return { promise: promise2, resolve };
    }
    globalThis.devtoolsFormatters = [
      {
        header: (object2) => {
          var _a;
          if (object2._type === "CoMap") {
            return ["div", {}, ["span", {}, object2.constructor.name]];
          } else if (object2._type === "CoList") {
            return [
              "div",
              {},
              ["span", {}, object2.constructor.name + "(" + object2.length + ") "]
            ];
          } else if (object2._type === "Account") {
            return [
              "div",
              {},
              [
                "span",
                {},
                object2.constructor.name + "(" + ((_a = object2._refs.profile.value) == null ? void 0 : _a.name) + (object2.isMe ? " ME" : "") + ")"
              ]
            ];
          } else {
            return null;
          }
        },
        hasBody: function() {
          return true;
        },
        body: function(object2) {
          if (object2._type === "CoMap" || object2._type === "Account") {
            return [
              "div",
              { style: "margin-left: 15px" },
              ["div", "id: ", ["object", { object: object2.id }]],
              ...Object.entries(object2).map(([k, v]) => [
                "div",
                { style: "white-space: nowrap;" },
                ["span", { style: "font-weight: bold; opacity: 0.6" }, k, ": "],
                ["object", { object: v }],
                ...typeof object2._schema[k] === "function" ? v === null ? [
                  [
                    "span",
                    { style: "opacity: 0.5" },
                    ` (pending ${object2._schema[k].name} `,
                    ["object", { object: object2._refs[k] }],
                    ")"
                  ]
                ] : [] : []
              ])
            ];
          } else if (object2._type === "CoList") {
            return [
              "div",
              { style: "margin-left: 15px" },
              ["div", "id: ", ["object", { object: object2.id }]],
              ...object2.map((v, i) => [
                "div",
                { style: "white-space: nowrap;" },
                ["span", { style: "font-weight: bold; opacity: 0.6" }, i, ": "],
                ["object", { object: v }],
                ...typeof object2._schema[ItemsSym] === "function" ? v === null ? [
                  [
                    "span",
                    { style: "opacity: 0.5" },
                    ` (pending ${object2._schema[ItemsSym].name} `,
                    ["object", { object: object2._refs[i] }],
                    ")"
                  ]
                ] : [] : []
              ])
            ];
          }
        }
      }
    ];
    function isCoValueClass(value) {
      return typeof value === "function" && value.fromRaw !== void 0;
    }
    function loadCoValueWithoutMe(cls, id2, options) {
      return loadCoValue(cls, id2, {
        ...options,
        loadAs: (options == null ? void 0 : options.loadAs) ?? activeAccountContext.get()
      });
    }
    function loadCoValue(cls, id2, options) {
      return new Promise((resolve) => {
        subscribeToCoValue(
          cls,
          id2,
          {
            resolve: options.resolve,
            loadAs: options.loadAs,
            syncResolution: true,
            skipRetry: options.skipRetry,
            onUnavailable: () => {
              resolve(null);
            },
            onUnauthorized: () => {
              resolve(null);
            }
          },
          (value, unsubscribe) => {
            resolve(value);
            unsubscribe();
          }
        );
      });
    }
    async function ensureCoValueLoaded(existing, options) {
      const response = await loadCoValue(
        existing.constructor,
        existing.id,
        {
          loadAs: existing._loadedAs,
          resolve: options == null ? void 0 : options.resolve
        }
      );
      if (!response) {
        throw new Error("Failed to deeply load CoValue " + existing.id);
      }
      return response;
    }
    function parseSubscribeRestArgs(args) {
      if (args.length === 2) {
        if (typeof args[0] === "object" && args[0] && typeof args[1] === "function") {
          return {
            options: {
              resolve: args[0].resolve,
              loadAs: args[0].loadAs,
              onUnauthorized: args[0].onUnauthorized,
              onUnavailable: args[0].onUnavailable
            },
            listener: args[1]
          };
        } else {
          throw new Error("Invalid arguments");
        }
      } else {
        if (typeof args[0] === "function") {
          return { options: {}, listener: args[0] };
        } else {
          throw new Error("Invalid arguments");
        }
      }
    }
    function subscribeToCoValueWithoutMe(cls, id2, options, listener) {
      return subscribeToCoValue(
        cls,
        id2,
        {
          ...options,
          loadAs: options.loadAs ?? activeAccountContext.get()
        },
        listener
      );
    }
    function subscribeToCoValue(cls, id2, options, listener) {
      const loadAs = options.loadAs ?? activeAccountContext.get();
      const node = "node" in loadAs ? loadAs.node : loadAs._raw.core.node;
      const resolve = options.resolve ?? true;
      let unsubscribed = false;
      const rootNode = new SubscriptionScope(
        node,
        resolve,
        id2,
        {
          ref: cls,
          optional: false
        },
        options.skipRetry
      );
      const handleUpdate = (value) => {
        var _a, _b;
        if (unsubscribed) return;
        if (value.type === "unavailable") {
          (_a = options.onUnavailable) == null ? void 0 : _a.call(options);
          console.error(value.toString());
        } else if (value.type === "unauthorized") {
          (_b = options.onUnauthorized) == null ? void 0 : _b.call(options);
          console.error(value.toString());
        } else if (value.type === "loaded") {
          listener(value.value, unsubscribe);
        }
      };
      let shouldDefer = !options.syncResolution;
      rootNode.setListener((value) => {
        if (shouldDefer) {
          shouldDefer = false;
          Promise.resolve().then(() => {
            handleUpdate(value);
          });
        } else {
          handleUpdate(value);
        }
      });
      function unsubscribe() {
        unsubscribed = true;
        rootNode.destroy();
      }
      return unsubscribe;
    }
    function subscribeToExistingCoValue(existing, options, listener) {
      return subscribeToCoValue(
        existing.constructor,
        existing.id,
        {
          loadAs: existing._loadedAs,
          resolve: options == null ? void 0 : options.resolve,
          onUnavailable: options == null ? void 0 : options.onUnavailable,
          onUnauthorized: options == null ? void 0 : options.onUnauthorized
        },
        listener
      );
    }
    function isAccountInstance(instance) {
      if (typeof instance !== "object" || instance === null) {
        return false;
      }
      return "_type" in instance && instance._type === "Account";
    }
    function parseCoValueCreateOptions(options) {
      const Group4 = RegisteredSchemas["Group"];
      if (!options) {
        return { owner: Group4.create(), uniqueness: void 0 };
      }
      if ("_type" in options) {
        if (options._type === "Account" || options._type === "Group") {
          return { owner: options, uniqueness: void 0 };
        }
      }
      const uniqueness = options.unique ? { uniqueness: options.unique } : void 0;
      return {
        owner: options.owner ?? Group4.create(),
        uniqueness
      };
    }
    function parseGroupCreateOptions(options) {
      if (!options) {
        return { owner: activeAccountContext.get() };
      }
      return "_type" in options && isAccountInstance(options) ? { owner: options } : { owner: options.owner ?? activeAccountContext.get() };
    }
    /* istanbul ignore file -- @preserve */
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function isArrayOf(isString, arr) {
      if (!Array.isArray(arr))
        return false;
      if (arr.length === 0)
        return true;
      if (isString) {
        return arr.every((item) => typeof item === "string");
      } else {
        return arr.every((item) => Number.isSafeInteger(item));
      }
    }
    function afn(input) {
      if (typeof input !== "function")
        throw new Error("function expected");
      return true;
    }
    function astr(label, input) {
      if (typeof input !== "string")
        throw new Error(`${label}: string expected`);
      return true;
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`invalid integer: ${n}`);
    }
    function aArr(input) {
      if (!Array.isArray(input))
        throw new Error("array expected");
    }
    function astrArr(label, input) {
      if (!isArrayOf(true, input))
        throw new Error(`${label}: array of strings expected`);
    }
    function anumArr(label, input) {
      if (!isArrayOf(false, input))
        throw new Error(`${label}: array of numbers expected`);
    }
    // @__NO_SIDE_EFFECTS__
    function chain(...args) {
      const id2 = (a) => a;
      const wrap = (a, b) => (c) => a(b(c));
      const encode = args.map((x) => x.encode).reduceRight(wrap, id2);
      const decode = args.map((x) => x.decode).reduce(wrap, id2);
      return { encode, decode };
    }
    // @__NO_SIDE_EFFECTS__
    function alphabet(letters) {
      const lettersA = typeof letters === "string" ? letters.split("") : letters;
      const len = lettersA.length;
      astrArr("alphabet", lettersA);
      const indexes = new Map(lettersA.map((l, i) => [l, i]));
      return {
        encode: (digits) => {
          aArr(digits);
          return digits.map((i) => {
            if (!Number.isSafeInteger(i) || i < 0 || i >= len)
              throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
            return lettersA[i];
          });
        },
        decode: (input) => {
          aArr(input);
          return input.map((letter) => {
            astr("alphabet.decode", letter);
            const i = indexes.get(letter);
            if (i === void 0)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
            return i;
          });
        }
      };
    }
    // @__NO_SIDE_EFFECTS__
    function join(separator = "") {
      astr("join", separator);
      return {
        encode: (from) => {
          astrArr("join.decode", from);
          return from.join(separator);
        },
        decode: (to) => {
          astr("join.decode", to);
          return to.split(separator);
        }
      };
    }
    // @__NO_SIDE_EFFECTS__
    function padding(bits, chr = "=") {
      anumber(bits);
      astr("padding", chr);
      return {
        encode(data2) {
          astrArr("padding.encode", data2);
          while (data2.length * bits % 8)
            data2.push(chr);
          return data2;
        },
        decode(input) {
          astrArr("padding.decode", input);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("padding: invalid, string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            const last = end - 1;
            const byte = last * bits;
            if (byte % 8 === 0)
              throw new Error("padding: invalid, string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function convertRadix(data2, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
      aArr(data2);
      if (!data2.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data2, (d) => {
        anumber(d);
        if (d < 0 || d >= from)
          throw new Error(`invalid integer: ${d}`);
        return d;
      });
      const dlen = digits.length;
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < dlen; i++) {
          const digit = digits[i];
          const fromCarry = from * carry;
          const digitBase = fromCarry + digit;
          if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
            throw new Error("convertRadix: carry overflow");
          }
          const div = digitBase / to;
          carry = digitBase % to;
          const rounded = Math.floor(div);
          digits[i] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i = 0; i < data2.length - 1 && data2[i] === 0; i++)
        res.push(0);
      return res.reverse();
    }
    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
    const powers = /* @__PURE__ */ (() => {
      let res = [];
      for (let i = 0; i < 40; i++)
        res.push(2 ** i);
      return res;
    })();
    function convertRadix2(data2, from, to, padding2) {
      aArr(data2);
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (/* @__PURE__ */ radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const max = powers[from];
      const mask = powers[to] - 1;
      const res = [];
      for (const n of data2) {
        anumber(n);
        if (n >= max)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        const pow = powers[pos];
        if (pow === void 0)
          throw new Error("invalid carry");
        carry &= pow - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding2 && pos >= from)
        throw new Error("Excess padding");
      if (!padding2 && carry > 0)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    // @__NO_SIDE_EFFECTS__
    function radix(num) {
      anumber(num);
      const _256 = 2 ** 8;
      return {
        encode: (bytes) => {
          if (!isBytes(bytes))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits) => {
          anumArr("radix.decode", digits);
          return Uint8Array.from(convertRadix(digits, num, _256));
        }
      };
    }
    // @__NO_SIDE_EFFECTS__
    function radix2(bits, revPadding = false) {
      anumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes) => {
          if (!isBytes(bytes))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
          anumArr("radix2.decode", digits);
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
      };
    }
    function checksum(len, fn) {
      anumber(len);
      afn(fn);
      return {
        encode(data2) {
          if (!isBytes(data2))
            throw new Error("checksum.encode: input should be Uint8Array");
          const sum = fn(data2).slice(0, len);
          const res = new Uint8Array(data2.length + len);
          res.set(data2);
          res.set(sum, data2.length);
          return res;
        },
        decode(data2) {
          if (!isBytes(data2))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data2.slice(0, -len);
          const oldChecksum = data2.slice(-len);
          const newChecksum = fn(payload).slice(0, len);
          for (let i = 0; i < len; i++)
            if (newChecksum[i] !== oldChecksum[i])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    const utils$2 = {
      alphabet,
      chain,
      checksum,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join,
      padding
    };
    /*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
    const isJapanese = (wordlist2) => wordlist2[0] === "あいこくしん";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError("invalid mnemonic type: " + typeof str);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function aentropy(ent) {
      abytes(ent, 16, 20, 24, 28, 32);
    }
    const calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([sha256(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist2) {
      if (!Array.isArray(wordlist2) || wordlist2.length !== 2048 || typeof wordlist2[0] !== "string")
        throw new Error("Wordlist: expected array of 2048 strings");
      wordlist2.forEach((i) => {
        if (typeof i !== "string")
          throw new Error("wordlist: non-string element: " + i);
      });
      return utils$2.chain(utils$2.checksum(1, calcChecksum), utils$2.radix2(11, true), utils$2.alphabet(wordlist2));
    }
    function mnemonicToEntropy(mnemonic, wordlist2) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist2).decode(words);
      aentropy(entropy);
      return entropy;
    }
    function entropyToMnemonic(entropy, wordlist2) {
      aentropy(entropy);
      const words = getCoder(wordlist2).encode(entropy);
      return words.join(isJapanese(wordlist2) ? "　" : " ");
    }
    var PassphraseAuth = class {
      constructor(crypto2, authenticate, register, authSecretStorage, wordlist2) {
        this.crypto = crypto2;
        this.authenticate = authenticate;
        this.register = register;
        this.authSecretStorage = authSecretStorage;
        this.wordlist = wordlist2;
        this.passphrase = "";
        this.logIn = async (passphrase) => {
          const { crypto: crypto3, authenticate: authenticate2 } = this;
          let secretSeed;
          try {
            secretSeed = mnemonicToEntropy(passphrase, this.wordlist);
          } catch (e) {
            throw new Error("Invalid passphrase");
          }
          const accountSecret = crypto3.agentSecretFromSecretSeed(secretSeed);
          const accountID = cojsonInternals.idforHeader(
            cojsonInternals.accountHeaderForInitialAgentSecret(accountSecret, crypto3),
            crypto3
          );
          await authenticate2({
            accountID,
            accountSecret
          });
          await this.authSecretStorage.set({
            accountID,
            secretSeed,
            accountSecret,
            provider: "passphrase"
          });
          this.passphrase = passphrase;
          this.notify();
        };
        this.signUp = async (name) => {
          const credentials = await this.authSecretStorage.get();
          if (!credentials || !credentials.secretSeed) {
            throw new Error("No credentials found");
          }
          const passphrase = entropyToMnemonic(credentials.secretSeed, this.wordlist);
          await this.authSecretStorage.set({
            accountID: credentials.accountID,
            secretSeed: credentials.secretSeed,
            accountSecret: credentials.accountSecret,
            provider: "passphrase"
          });
          if (name == null ? void 0 : name.trim()) {
            const currentAccount = await Account.getMe().ensureLoaded({
              resolve: {
                profile: true
              }
            });
            currentAccount.profile.name = name;
          }
          return passphrase;
        };
        this.registerNewAccount = async (passphrase, name) => {
          const secretSeed = mnemonicToEntropy(passphrase, this.wordlist);
          const accountSecret = this.crypto.agentSecretFromSecretSeed(secretSeed);
          const accountID = await this.register(accountSecret, { name });
          await this.authSecretStorage.set({
            accountID,
            secretSeed,
            accountSecret,
            provider: "passphrase"
          });
          return accountID;
        };
        this.getCurrentAccountPassphrase = async () => {
          const credentials = await this.authSecretStorage.get();
          if (!credentials || !credentials.secretSeed) {
            throw new Error("No credentials found");
          }
          return entropyToMnemonic(credentials.secretSeed, this.wordlist);
        };
        this.generateRandomPassphrase = () => {
          return entropyToMnemonic(this.crypto.newRandomSecretSeed(), this.wordlist);
        };
        this.loadCurrentAccountPassphrase = async () => {
          const passphrase = await this.getCurrentAccountPassphrase();
          this.passphrase = passphrase;
          this.notify();
        };
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = (callback) => {
          this.listeners.add(callback);
          return () => {
            this.listeners.delete(callback);
          };
        };
      }
      notify() {
        for (const listener of this.listeners) {
          listener();
        }
      }
    };
    function createInviteLink$1(value, role, baseURL, valueHint) {
      const coValueCore = value._raw.core;
      let currentCoValue = coValueCore;
      while (currentCoValue.verified.header.ruleset.type === "ownedByGroup") {
        currentCoValue = currentCoValue.getGroup().core;
      }
      const { ruleset, meta } = currentCoValue.verified.header;
      if (ruleset.type !== "group" || (meta == null ? void 0 : meta.type) === "account") {
        throw new Error("Can't create invite link for object without group");
      }
      const group = cojsonInternals.expectGroup(currentCoValue.getCurrentContent());
      const inviteSecret = group.createInvite(role);
      return `${baseURL}#/invite/${valueHint ? valueHint + "/" : ""}${value.id}/${inviteSecret}`;
    }
    function parseInviteLink(inviteURL) {
      const url2 = new URL(inviteURL);
      const parts = url2.hash.split("/");
      let valueHint;
      let valueID;
      let inviteSecret;
      if (parts[0] === "#" && parts[1] === "invite") {
        if (parts.length === 5) {
          valueHint = parts[2];
          valueID = parts[3];
          inviteSecret = parts[4];
        } else if (parts.length === 4) {
          valueID = parts[2];
          inviteSecret = parts[3];
        }
        if (!valueID || !inviteSecret) {
          return void 0;
        }
        return { valueID, inviteSecret, valueHint };
      }
    }
    function consumeInviteLink({
      inviteURL,
      as = Account.getMe(),
      forValueHint,
      invitedObjectSchema
    }) {
      return new Promise((resolve, reject) => {
        const result = parseInviteLink(inviteURL);
        if (result && result.valueHint === forValueHint) {
          as.acceptInvite(result.valueID, result.inviteSecret, invitedObjectSchema).then(() => {
            resolve(result);
          }).catch(reject);
        } else {
          resolve(void 0);
        }
      });
    }
    class CoJsonIDBTransaction {
      constructor(db) {
        this.pendingRequests = [];
        this.rejectHandlers = [];
        this.id = Math.random();
        this.running = false;
        this.failed = false;
        this.done = false;
        this.startedAt = performance.now();
        this.db = db;
        this.refresh();
      }
      refresh() {
        this.tx = this.db.transaction(["coValues", "sessions", "transactions", "signatureAfter"], "readwrite");
        this.tx.oncomplete = () => {
          this.done = true;
        };
        this.tx.onabort = () => {
          this.done = true;
        };
      }
      isReusable() {
        const delta = performance.now() - this.startedAt;
        return !this.done && !this.failed && delta <= 100;
      }
      getObjectStore(name) {
        try {
          return this.tx.objectStore(name);
        } catch (error2) {
          this.refresh();
          return this.tx.objectStore(name);
        }
      }
      pushRequest(handler) {
        const next = () => {
          const next2 = this.pendingRequests.shift();
          if (next2) {
            next2(this);
          } else {
            this.running = false;
            this.done = true;
          }
        };
        if (this.running) {
          return new Promise((resolve, reject) => {
            this.rejectHandlers.push(reject);
            this.pendingRequests.push(async () => {
              try {
                const result = await handler(this, next);
                resolve(result);
              } catch (error2) {
                reject(error2);
              }
            });
          });
        }
        this.running = true;
        return handler(this, next);
      }
      handleRequest(handler) {
        return this.pushRequest((txEntry, next) => {
          return new Promise((resolve, reject) => {
            const request = handler(txEntry);
            request.onerror = () => {
              this.failed = true;
              this.tx.abort();
              console.error(request.error);
              reject(request.error);
              for (const handler2 of this.rejectHandlers) {
                handler2();
              }
            };
            request.onsuccess = () => {
              resolve(request.result);
              next();
            };
          });
        });
      }
      commit() {
        if (!this.done) {
          this.tx.commit();
        }
      }
    }
    class IDBClient {
      constructor(db) {
        this.db = db;
      }
      makeRequest(handler) {
        var _a;
        if (this.activeTransaction) {
          return this.activeTransaction.handleRequest(handler);
        }
        if ((_a = this.autoBatchingTransaction) == null ? void 0 : _a.isReusable()) {
          return this.autoBatchingTransaction.handleRequest(handler);
        }
        const tx = new CoJsonIDBTransaction(this.db);
        this.autoBatchingTransaction = tx;
        return tx.handleRequest(handler);
      }
      async getCoValue(coValueId) {
        return this.makeRequest((tx) => tx.getObjectStore("coValues").index("coValuesById").get(coValueId));
      }
      async getCoValueSessions(coValueRowId) {
        return this.makeRequest((tx) => tx.getObjectStore("sessions").index("sessionsByCoValue").getAll(coValueRowId));
      }
      async getSingleCoValueSession(coValueRowId, sessionID) {
        return this.makeRequest((tx) => tx.getObjectStore("sessions").index("uniqueSessions").get([coValueRowId, sessionID]));
      }
      async getNewTransactionInSession(sessionRowId, fromIdx, toIdx) {
        return this.makeRequest((tx) => tx.getObjectStore("transactions").getAll(IDBKeyRange.bound([sessionRowId, fromIdx], [sessionRowId, toIdx])));
      }
      async getSignatures(sessionRowId, firstNewTxIdx) {
        return this.makeRequest((tx) => tx.getObjectStore("signatureAfter").getAll(IDBKeyRange.bound([sessionRowId, firstNewTxIdx], [sessionRowId, Number.POSITIVE_INFINITY])));
      }
      async addCoValue(msg) {
        if (!msg.header) {
          throw new Error(`Header is required, coId: ${msg.id}`);
        }
        return await this.makeRequest((tx) => tx.getObjectStore("coValues").put({
          id: msg.id,
          // biome-ignore lint/style/noNonNullAssertion: TODO(JAZZ-561): Review
          header: msg.header
        }));
      }
      async addSessionUpdate({ sessionUpdate, sessionRow }) {
        return this.makeRequest((tx) => tx.getObjectStore("sessions").put((sessionRow == null ? void 0 : sessionRow.rowID) ? {
          rowID: sessionRow.rowID,
          ...sessionUpdate
        } : sessionUpdate));
      }
      async addTransaction(sessionRowID, idx, newTransaction) {
        await this.makeRequest((tx) => tx.getObjectStore("transactions").add({
          ses: sessionRowID,
          idx,
          tx: newTransaction
        }));
      }
      async addSignatureAfter({ sessionRowID, idx, signature }) {
        return this.makeRequest((tx) => tx.getObjectStore("signatureAfter").put({
          ses: sessionRowID,
          idx,
          signature
        }));
      }
      closeTransaction(tx) {
        tx.commit();
        if (tx === this.activeTransaction) {
          this.activeTransaction = void 0;
        }
      }
      async transaction(operationsCallback) {
        const tx = new CoJsonIDBTransaction(this.db);
        this.activeTransaction = tx;
        try {
          await operationsCallback();
          tx.commit();
        } finally {
          this.activeTransaction = void 0;
        }
      }
    }
    let DATABASE_NAME = "jazz-storage";
    async function getIndexedDBStorage(name = DATABASE_NAME) {
      const dbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(name, 4);
        request.onerror = () => {
          reject(request.error);
        };
        request.onsuccess = () => {
          resolve(request.result);
        };
        request.onupgradeneeded = async (ev) => {
          const db2 = request.result;
          if (ev.oldVersion === 0) {
            const coValues = db2.createObjectStore("coValues", {
              autoIncrement: true,
              keyPath: "rowID"
            });
            coValues.createIndex("coValuesById", "id", {
              unique: true
            });
            const sessions = db2.createObjectStore("sessions", {
              autoIncrement: true,
              keyPath: "rowID"
            });
            sessions.createIndex("sessionsByCoValue", "coValue");
            sessions.createIndex("uniqueSessions", ["coValue", "sessionID"], {
              unique: true
            });
            db2.createObjectStore("transactions", {
              keyPath: ["ses", "idx"]
            });
          }
          if (ev.oldVersion <= 1) {
            db2.createObjectStore("signatureAfter", {
              keyPath: ["ses", "idx"]
            });
          }
        };
      });
      const db = await dbPromise;
      return new StorageApiAsync(new IDBClient(db));
    }
    function addMessageToBacklog(backlog, message) {
      if (!backlog) {
        return JSON.stringify(message);
      }
      return `${backlog}
${JSON.stringify(message)}`;
    }
    function deserializeMessages(messages) {
      if (typeof messages !== "string") {
        return {
          ok: false,
          error: new Error("Expected a string")
        };
      }
      try {
        return {
          ok: true,
          messages: messages.split("\n").map((msg) => JSON.parse(msg))
        };
      } catch (e) {
        logger.error("Error while deserializing messages", { err: e });
        return {
          ok: false,
          error: e
        };
      }
    }
    const BUFFER_LIMIT = 1e5;
    const BUFFER_LIMIT_POLLING_INTERVAL = 10;
    function isWebSocketOpen(websocket) {
      return websocket.readyState === 1;
    }
    function hasWebSocketTooMuchBufferedData(websocket) {
      return websocket.bufferedAmount > BUFFER_LIMIT && isWebSocketOpen(websocket);
    }
    function waitForWebSocketOpen(websocket) {
      return new Promise((resolve) => {
        if (websocket.readyState === 1) {
          resolve();
        } else {
          websocket.addEventListener("open", () => resolve(), { once: true });
        }
      });
    }
    async function waitForWebSocketBufferedAmount(websocket) {
      while (hasWebSocketTooMuchBufferedData(websocket)) {
        await new Promise((resolve) => setTimeout(resolve, BUFFER_LIMIT_POLLING_INTERVAL));
      }
    }
    const { CO_VALUE_PRIORITY } = cojsonInternals;
    const MAX_OUTGOING_MESSAGES_CHUNK_BYTES = 25e3;
    class BatchedOutgoingMessages {
      constructor(websocket, batching, peerRole) {
        this.websocket = websocket;
        this.batching = batching;
        this.backlog = "";
        this.processing = false;
        this.closed = false;
        this.closeListeners = /* @__PURE__ */ new Set();
        this.queue = new PriorityBasedMessageQueue(CO_VALUE_PRIORITY.HIGH, "outgoing", {
          peerRole
        });
      }
      push(msg) {
        if (msg === "Disconnected") {
          this.close();
          return;
        }
        this.queue.push(msg);
        if (this.processing) {
          return;
        }
        this.processQueue().catch((e) => {
          logger.error("Error while processing sendMessage queue", { err: e });
        });
      }
      async processQueue() {
        const { websocket } = this;
        this.processing = true;
        await new Promise((resolve) => setTimeout(resolve, 5));
        let msg = this.queue.pull();
        while (msg) {
          if (this.closed) {
            return;
          }
          if (!isWebSocketOpen(websocket)) {
            await waitForWebSocketOpen(websocket);
          }
          if (hasWebSocketTooMuchBufferedData(websocket)) {
            await waitForWebSocketBufferedAmount(websocket);
          }
          if (isWebSocketOpen(websocket)) {
            this.processMessage(msg);
            msg = this.queue.pull();
          }
        }
        this.sendMessagesInBulk();
        this.processing = false;
      }
      processMessage(msg) {
        if (!this.batching) {
          this.websocket.send(JSON.stringify(msg));
          return;
        }
        const payload = addMessageToBacklog(this.backlog, msg);
        const maxChunkSizeReached = payload.length >= MAX_OUTGOING_MESSAGES_CHUNK_BYTES;
        const backlogExists = this.backlog.length > 0;
        if (maxChunkSizeReached && backlogExists) {
          this.sendMessagesInBulk();
          this.backlog = addMessageToBacklog("", msg);
        } else if (maxChunkSizeReached) {
          this.backlog = payload;
          this.sendMessagesInBulk();
        } else {
          this.backlog = payload;
        }
      }
      sendMessagesInBulk() {
        if (this.backlog.length > 0 && isWebSocketOpen(this.websocket)) {
          this.websocket.send(this.backlog);
          this.backlog = "";
        }
      }
      setBatching(enabled) {
        this.batching = enabled;
      }
      onClose(callback) {
        this.closeListeners.add(callback);
      }
      close() {
        if (this.closed) {
          return;
        }
        let msg = this.queue.pull();
        while (msg) {
          this.processMessage(msg);
          msg = this.queue.pull();
        }
        this.closed = true;
        this.sendMessagesInBulk();
        for (const listener of this.closeListeners) {
          listener();
        }
        this.closeListeners.clear();
      }
    }
    const { ConnectedPeerChannel } = cojsonInternals;
    function createPingTimeoutListener(enabled, timeout, callback) {
      if (!enabled) {
        return {
          reset() {
          },
          clear() {
          }
        };
      }
      let pingTimeout = null;
      return {
        reset() {
          pingTimeout && clearTimeout(pingTimeout);
          pingTimeout = setTimeout(() => {
            callback();
          }, timeout);
        },
        clear() {
          pingTimeout && clearTimeout(pingTimeout);
        }
      };
    }
    function createClosedEventEmitter(callback = () => {
    }) {
      let disconnected = false;
      return () => {
        if (disconnected)
          return;
        disconnected = true;
        callback();
      };
    }
    function createWebSocketPeer({ id: id2, websocket, role, expectPings = true, batchingByDefault = true, deletePeerStateOnClose = false, pingTimeout = 1e4, onSuccess, onClose }) {
      const incoming = new ConnectedPeerChannel();
      const emitClosedEvent = createClosedEventEmitter(onClose);
      function handleClose() {
        incoming.push("Disconnected");
        emitClosedEvent();
      }
      websocket.addEventListener("close", handleClose);
      websocket.addEventListener("error", (err2) => {
        if (err2.message) {
          logger.warn("WebSocket error", { err: err2 });
        }
        handleClose();
      });
      const pingTimeoutListener = createPingTimeoutListener(expectPings, pingTimeout, () => {
        incoming.push("Disconnected");
        logger.error("Ping timeout from peer", {
          peerId: id2,
          peerRole: role
        });
        emitClosedEvent();
      });
      const outgoing = new BatchedOutgoingMessages(websocket, batchingByDefault, role);
      let isFirstMessage = true;
      function handleIncomingMsg(event) {
        pingTimeoutListener.reset();
        if (event.data === "") {
          return;
        }
        const result = deserializeMessages(event.data);
        if (!result.ok) {
          logger.warn("Error while deserializing messages", { err: result.error });
          return;
        }
        if (isFirstMessage) {
          onSuccess == null ? void 0 : onSuccess();
          isFirstMessage = false;
        }
        const { messages } = result;
        if (messages.length > 1) {
          outgoing.setBatching(true);
        }
        for (const msg of messages) {
          if (msg && "action" in msg) {
            incoming.push(msg);
          }
        }
      }
      websocket.addEventListener("message", handleIncomingMsg);
      outgoing.onClose(() => {
        websocket.removeEventListener("message", handleIncomingMsg);
        websocket.removeEventListener("close", handleClose);
        pingTimeoutListener.clear();
        emitClosedEvent();
        if (websocket.readyState === 0) {
          websocket.addEventListener("open", function handleClose2() {
            websocket.close();
          }, { once: true });
        } else if (websocket.readyState === 1) {
          websocket.close();
        }
      });
      return {
        id: id2,
        incoming,
        outgoing,
        role,
        deletePeerStateOnClose
      };
    }
    class WebSocketPeerWithReconnection {
      constructor(opts) {
        this.enabled = false;
        this.closed = true;
        this.currentPeer = void 0;
        this.unsubscribeNetworkChange = void 0;
        this.reconnectionAttempts = 0;
        this.onConnectionChangeListeners = /* @__PURE__ */ new Set();
        this.waitUntilConnected = async () => {
          if (this.closed) {
            return new Promise((resolve) => {
              const listener = (connected) => {
                if (connected) {
                  resolve();
                  this.onConnectionChangeListeners.delete(listener);
                }
              };
              this.onConnectionChangeListeners.add(listener);
            });
          }
        };
        this.subscribe = (listener) => {
          this.onConnectionChangeListeners.add(listener);
          listener(!this.closed);
        };
        this.unsubscribe = (listener) => {
          this.onConnectionChangeListeners.delete(listener);
        };
        this.startConnection = async () => {
          if (!this.enabled)
            return;
          if (this.currentPeer) {
            this.removePeer(this.currentPeer);
            this.currentPeer.outgoing.close();
            this.reconnectionAttempts++;
            const timeout = this.reconnectionTimeout * this.reconnectionAttempts;
            logger.debug(`Websocket disconnected, trying to reconnect in ${timeout}ms`);
            await this.waitForOnline(timeout);
          }
          if (!this.enabled)
            return;
          this.currentPeer = createWebSocketPeer({
            websocket: new this.WebSocketConstructor(this.peer),
            pingTimeout: this.pingTimeout,
            id: this.peer,
            role: "server",
            onClose: () => {
              this.closed = true;
              for (const listener of this.onConnectionChangeListeners) {
                listener(false);
              }
              this.startConnection();
            },
            onSuccess: () => {
              this.closed = false;
              for (const listener of this.onConnectionChangeListeners) {
                listener(true);
              }
              logger.debug("Websocket connection successful");
              this.reconnectionAttempts = 0;
            }
          });
          this.addPeer(this.currentPeer);
        };
        this.enable = () => {
          if (this.enabled)
            return;
          this.enabled = true;
          this.startConnection();
        };
        this.disable = () => {
          var _a;
          if (!this.enabled)
            return;
          this.enabled = false;
          this.reconnectionAttempts = 0;
          (_a = this.unsubscribeNetworkChange) == null ? void 0 : _a.call(this);
          this.unsubscribeNetworkChange = void 0;
          if (this.currentPeer) {
            this.removePeer(this.currentPeer);
            this.currentPeer.outgoing.close();
            this.currentPeer = void 0;
          }
        };
        this.peer = opts.peer;
        this.reconnectionTimeout = opts.reconnectionTimeout || 500;
        this.addPeer = opts.addPeer;
        this.removePeer = opts.removePeer;
        this.WebSocketConstructor = opts.WebSocketConstructor || WebSocket;
        this.pingTimeout = opts.pingTimeout || 1e4;
      }
      // Basic implementation for environments that don't support network change events (e.g. Node.js)
      // Needs to be extended to handle platform specific APIs
      onNetworkChange(callback) {
        return () => {
        };
      }
      waitForOnline(timeout) {
        return new Promise((resolve) => {
          const unsubscribeNetworkChange = this.onNetworkChange((connected) => {
            if (connected) {
              handleTimeoutOrOnline();
            }
          });
          function handleTimeoutOrOnline() {
            clearTimeout(timer);
            unsubscribeNetworkChange == null ? void 0 : unsubscribeNetworkChange();
            resolve();
          }
          const timer = setTimeout(handleTimeoutOrOnline, timeout);
        });
      }
    }
    let wasm;
    const heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    function getObject(idx) {
      return heap[idx];
    }
    let heap_next = heap.length;
    function addHeapObject(obj) {
      if (heap_next === heap.length) heap.push(heap.length + 1);
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj;
      return idx;
    }
    function handleError(f, args) {
      try {
        return f.apply(this, args);
      } catch (e) {
        wasm.__wbindgen_export_0(addHeapObject(e));
      }
    }
    const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
      throw Error("TextDecoder not available");
    } };
    if (typeof TextDecoder !== "undefined") {
      cachedTextDecoder.decode();
    }
    let cachedUint8ArrayMemory0 = null;
    function getUint8ArrayMemory0() {
      if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
      }
      return cachedUint8ArrayMemory0;
    }
    function getStringFromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
    }
    function dropObject(idx) {
      if (idx < 132) return;
      heap[idx] = heap_next;
      heap_next = idx;
    }
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    let WASM_VECTOR_LEN = 0;
    const cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
      throw Error("TextEncoder not available");
    } };
    const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len, 1) >>> 0;
      const mem = getUint8ArrayMemory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 127) break;
        mem[ptr + offset] = code;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    let cachedDataViewMemory0 = null;
    function getDataViewMemory0() {
      if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
      }
      return cachedDataViewMemory0;
    }
    function isLikeNone(x) {
      return x === void 0 || x === null;
    }
    function passArray8ToWasm0(arg, malloc) {
      const ptr = malloc(arg.length * 1, 1) >>> 0;
      getUint8ArrayMemory0().set(arg, ptr / 1);
      WASM_VECTOR_LEN = arg.length;
      return ptr;
    }
    function getArrayU8FromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
    }
    function blake3_hash_once(data2) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(data2, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.blake3_hash_once(retptr, ptr0, len0);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v2 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_1(r0, r1 * 1, 1);
        return v2;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function blake3_hash_once_with_context(data2, context) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(data2, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(context, wasm.__wbindgen_export_2);
        const len1 = WASM_VECTOR_LEN;
        wasm.blake3_hash_once_with_context(retptr, ptr0, len0, ptr1, len1);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v3 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_1(r0, r1 * 1, 1);
        return v3;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function blake3_empty_state() {
      const ret = wasm.blake3_empty_state();
      return Blake3Hasher.__wrap(ret);
    }
    function new_ed25519_signing_key() {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.new_ed25519_signing_key(retptr);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_1(r0, r1 * 1, 1);
        return v1;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function encrypt(value, key_secret, nonce_material) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(value, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(key_secret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_export_2);
        const len2 = WASM_VECTOR_LEN;
        wasm.decrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
        if (r3) {
          throw takeObject(r2);
        }
        var v4 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_1(r0, r1 * 1, 1);
        return v4;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function decrypt(ciphertext, key_secret, nonce_material) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(ciphertext, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(key_secret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_export_2);
        const len2 = WASM_VECTOR_LEN;
        wasm.decrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
        if (r3) {
          throw takeObject(r2);
        }
        var v4 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_1(r0, r1 * 1, 1);
        return v4;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function seal(message, sender_secret, recipient_id, nonce_material) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(sender_secret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(recipient_id, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_export_2);
        const len3 = WASM_VECTOR_LEN;
        wasm.seal(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
        if (r3) {
          throw takeObject(r2);
        }
        var v5 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_1(r0, r1 * 1, 1);
        return v5;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function unseal(sealed_message, recipient_secret, sender_id, nonce_material) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(sealed_message, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(recipient_secret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(sender_id, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passArray8ToWasm0(nonce_material, wasm.__wbindgen_export_2);
        const len3 = WASM_VECTOR_LEN;
        wasm.unseal(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
        if (r3) {
          throw takeObject(r2);
        }
        var v5 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_1(r0, r1 * 1, 1);
        return v5;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function sign(message, secret) {
      let deferred4_0;
      let deferred4_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(secret, wasm.__wbindgen_export_2);
        const len1 = WASM_VECTOR_LEN;
        wasm.sign(retptr, ptr0, len0, ptr1, len1);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
        var ptr3 = r0;
        var len3 = r1;
        if (r3) {
          ptr3 = 0;
          len3 = 0;
          throw takeObject(r2);
        }
        deferred4_0 = ptr3;
        deferred4_1 = len3;
        return getStringFromWasm0(ptr3, len3);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_1(deferred4_0, deferred4_1, 1);
      }
    }
    function verify(signature, message, id2) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(message, wasm.__wbindgen_export_2);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passArray8ToWasm0(id2, wasm.__wbindgen_export_2);
        const len2 = WASM_VECTOR_LEN;
        wasm.verify(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        if (r2) {
          throw takeObject(r1);
        }
        return r0 !== 0;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function get_signer_id(secret) {
      let deferred3_0;
      let deferred3_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(secret, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.get_signer_id(retptr, ptr0, len0);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
          ptr2 = 0;
          len2 = 0;
          throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_1(deferred3_0, deferred3_1, 1);
      }
    }
    function new_x25519_private_key() {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.new_x25519_private_key(retptr);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_1(r0, r1 * 1, 1);
        return v1;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function get_sealer_id(secret) {
      let deferred3_0;
      let deferred3_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(secret, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.get_sealer_id(retptr, ptr0, len0);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
          ptr2 = 0;
          len2 = 0;
          throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_1(deferred3_0, deferred3_1, 1);
      }
    }
    const Blake3HasherFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm.__wbg_blake3hasher_free(ptr >>> 0, 1));
    class Blake3Hasher {
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Blake3Hasher.prototype);
        obj.__wbg_ptr = ptr;
        Blake3HasherFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Blake3HasherFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_blake3hasher_free(ptr, 0);
      }
      constructor() {
        const ret = wasm.blake3_empty_state();
        this.__wbg_ptr = ret >>> 0;
        Blake3HasherFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {Uint8Array} data
       */
      update(data2) {
        const ptr0 = passArray8ToWasm0(data2, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.blake3_update_state(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {Uint8Array}
       */
      finalize() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.blake3hasher_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var v1 = getArrayU8FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_1(r0, r1 * 1, 1);
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {Blake3Hasher}
       */
      clone() {
        const ret = wasm.blake3hasher_clone(this.__wbg_ptr);
        return Blake3Hasher.__wrap(ret);
      }
    }
    async function __wbg_load(module2, imports) {
      if (typeof Response === "function" && module2 instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === "function") {
          try {
            return await WebAssembly.instantiateStreaming(module2, imports);
          } catch (e) {
            if (module2.headers.get("Content-Type") != "application/wasm") {
              console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
            } else {
              throw e;
            }
          }
        }
        const bytes = await module2.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);
      } else {
        const instance = await WebAssembly.instantiate(module2, imports);
        if (instance instanceof WebAssembly.Instance) {
          return { instance, module: module2 };
        } else {
          return instance;
        }
      }
    }
    function __wbg_get_imports() {
      const imports = {};
      imports.wbg = {};
      imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
        const ret = getObject(arg0).buffer;
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_call_672a4d21634d4a24 = function() {
        return handleError(function(arg0, arg1) {
          const ret = getObject(arg0).call(getObject(arg1));
          return addHeapObject(ret);
        }, arguments);
      };
      imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
        return handleError(function(arg0, arg1, arg2) {
          const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
          return addHeapObject(ret);
        }, arguments);
      };
      imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {
        const ret = getObject(arg0).crypto;
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
        let deferred0_0;
        let deferred0_1;
        try {
          deferred0_0 = arg0;
          deferred0_1 = arg1;
          console.error(getStringFromWasm0(arg0, arg1));
        } finally {
          wasm.__wbindgen_export_1(deferred0_0, deferred0_1, 1);
        }
      };
      imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
        return handleError(function(arg0, arg1) {
          getObject(arg0).getRandomValues(getObject(arg1));
        }, arguments);
      };
      imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {
        const ret = getObject(arg0).msCrypto;
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
        const ret = new Error();
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
        const ret = new Uint8Array(getObject(arg0));
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
        const ret = new Function(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {
        const ret = getObject(arg0).node;
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {
        const ret = getObject(arg0).process;
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
        return handleError(function(arg0, arg1) {
          getObject(arg0).randomFillSync(takeObject(arg1));
        }, arguments);
      };
      imports.wbg.__wbg_require_79b1e9274cde3c87 = function() {
        return handleError(function() {
          const ret = module.require;
          return addHeapObject(ret);
        }, arguments);
      };
      imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
        getObject(arg0).set(getObject(arg1), arg2 >>> 0);
      };
      imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
        const ret = getObject(arg1).stack;
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
      };
      imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
        const ret = typeof global === "undefined" ? null : global;
        return isLikeNone(ret) ? 0 : addHeapObject(ret);
      };
      imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
        const ret = typeof globalThis === "undefined" ? null : globalThis;
        return isLikeNone(ret) ? 0 : addHeapObject(ret);
      };
      imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
        const ret = typeof self === "undefined" ? null : self;
        return isLikeNone(ret) ? 0 : addHeapObject(ret);
      };
      imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
        const ret = typeof window === "undefined" ? null : window;
        return isLikeNone(ret) ? 0 : addHeapObject(ret);
      };
      imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
        return addHeapObject(ret);
      };
      imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {
        const ret = getObject(arg0).versions;
        return addHeapObject(ret);
      };
      imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      };
      imports.wbg.__wbindgen_is_function = function(arg0) {
        const ret = typeof getObject(arg0) === "function";
        return ret;
      };
      imports.wbg.__wbindgen_is_object = function(arg0) {
        const val = getObject(arg0);
        const ret = typeof val === "object" && val !== null;
        return ret;
      };
      imports.wbg.__wbindgen_is_string = function(arg0) {
        const ret = typeof getObject(arg0) === "string";
        return ret;
      };
      imports.wbg.__wbindgen_is_undefined = function(arg0) {
        const ret = getObject(arg0) === void 0;
        return ret;
      };
      imports.wbg.__wbindgen_memory = function() {
        const ret = wasm.memory;
        return addHeapObject(ret);
      };
      imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
        const ret = getObject(arg0);
        return addHeapObject(ret);
      };
      imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
        takeObject(arg0);
      };
      imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
      };
      imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
      };
      return imports;
    }
    function __wbg_finalize_init(instance, module2) {
      wasm = instance.exports;
      __wbg_init.__wbindgen_wasm_module = module2;
      cachedDataViewMemory0 = null;
      cachedUint8ArrayMemory0 = null;
      wasm.__wbindgen_start();
      return wasm;
    }
    async function __wbg_init(module_or_path) {
      if (wasm !== void 0) return wasm;
      if (typeof module_or_path !== "undefined") {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
          ({ module_or_path } = module_or_path);
        } else {
          console.warn("using deprecated parameters for the initialization function; pass a single object instead");
        }
      }
      if (typeof module_or_path === "undefined") {
        throw new Error();
      }
      const imports = __wbg_get_imports();
      if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
        module_or_path = fetch(module_or_path);
      }
      const { instance, module: module2 } = await __wbg_load(await module_or_path, imports);
      return __wbg_finalize_init(instance, module2);
    }
    const data = "data:application/wasm;base64,AGFzbQEAAAAByQEbYAN/f38Bf2ACf38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAABf2AFf39/f38AYAd/f39/f39/AGAEf39/fwBgBX9/f39/AX9gAABgBn9/f39/fwBgBH9/f38Bf2AJf39/f39/f39/AGAGf39/f39/AX9gBX9/f35/AGAHf39/fn9/fwF/YAJ/fgBgB39/f39/f38Bf2ADfn9/AX9gBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf35/fwAC5AkiA3diZxRfX3diaW5kZ2VuX2Vycm9yX25ldwABA3diZxpfX3diZ19uZXdfOGE2ZjIzOGE2ZWNlODZlYQAGA3diZxxfX3diZ19zdGFja18wZWQ3NWQ2ODU3NWIwZjNjAAIDd2JnHF9fd2JnX2Vycm9yXzc1MzRiOGU5YTM2ZjFhYjQAAgN3YmcaX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYABAN3YmcbX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmAAUDd2JnHV9fd2JnX2NyeXB0b19lZDU4YjhlMTBhMjkyODM5AAUDd2JnFF9fd2JpbmRnZW5faXNfb2JqZWN0AAUDd2JnHl9fd2JnX3Byb2Nlc3NfNWMxZDY3MGJjNTM2MTRiOAAFA3diZx9fX3diZ192ZXJzaW9uc19jNzFhYTE2MjZhOTNlMGExAAUDd2JnG19fd2JnX25vZGVfMDI5OTk1MzNjNGVhMDJlMwAFA3diZxRfX3diaW5kZ2VuX2lzX3N0cmluZwAFA3diZx5fX3diZ19yZXF1aXJlXzc5YjFlOTI3NGNkZTNjODcABgN3YmcWX193YmluZGdlbl9pc19mdW5jdGlvbgAFA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAAQN3YmcbX193YmdfY2FsbF83Y2NjZGQ2OWUwNzkxYWUyAAADd2JnH19fd2JnX21zQ3J5cHRvXzBhMzZlMmVjM2EzNDNkMjYABQN3YmckX193YmdfbmV3d2l0aGxlbmd0aF9hMzgxNjM0ZTkwYzI3NmQ0AAUDd2JnF19fd2JpbmRnZW5faXNfdW5kZWZpbmVkAAUDd2JnIF9fd2JnX25ld25vYXJnc18xMDVlZDQ3MTQ3NWFhZjUwAAEDd2JnG19fd2JnX2NhbGxfNjcyYTRkMjE2MzRkNGEyNAABA3diZy1fX3diZ19zdGF0aWNfYWNjZXNzb3JfR0xPQkFMXzg4YTkwMmQxM2E1NTdkMDcABgN3YmcyX193Ymdfc3RhdGljX2FjY2Vzc29yX0dMT0JBTF9USElTXzU2NTc4YmU3ZTlmODMyYjAABgN3YmctX193Ymdfc3RhdGljX2FjY2Vzc29yX1dJTkRPV181ZGUzNzA0M2E5MWE5YzQwAAYDd2JnK19fd2JnX3N0YXRpY19hY2Nlc3Nvcl9TRUxGXzM3YzVkNDE4ZTRiZjU4MTkABgN3YmcRX193YmluZGdlbl9tZW1vcnkABgN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgABQN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZDk3ZTYzN2ViZTE0NWE5YQAAA3diZyVfX3diZ19yYW5kb21GaWxsU3luY19hYjJjZmU3OWViYmYyNzQwAAIDd2JnH19fd2JnX3N1YmFycmF5X2FhOTA2NWZhOWRjNWRmOTYAAAN3YmcmX193YmdfZ2V0UmFuZG9tVmFsdWVzX2JjYjQ5MTJmMTYwMDBkYzQAAgN3YmcaX193YmdfbmV3X2ExMjAwMmE3ZjkxYzc1YmUABQN3YmcaX193Ymdfc2V0XzY1NTk1YmRkODY4YjMwMDkAAwN3YmcQX193YmluZGdlbl90aHJvdwACA8IBwAEIAwMHEAUMDgMOAgACAwcRAgMIAgMCAAcDAgMDAggDAwgDAgQCAwcCDRICBQQDBwIDCAMDAg8AAAcDBAECCQMDAwMDAgQAAQQCAgMDAgoTAQIBBhQBAQEBAwEBAgEBAQECAgAGDAECAQEBBAMDDAkJAQIHBAQDAwMDAwIBAQEBAAADCgICCwELDQEPCgcVFxkJAAEBAQQEBAQEAQEBBQEBAQcBAgEBAgECAgICAgIEBAEBBQELAgsBAQEAAAEAAgMEBQFwAVdXBQMBABEGCQF/AUGAgMAACwfPBikGbWVtb3J5AgAOZ2VuZXJhdGVfbm9uY2UAYxBibGFrZTNfaGFzaF9vbmNlAGIdYmxha2UzX2hhc2hfb25jZV93aXRoX2NvbnRleHQAWhdfX3diZ19ibGFrZTNoYXNoZXJfZnJlZQCCARVibGFrZTNoYXNoZXJfZmluYWxpemUAchJibGFrZTNoYXNoZXJfY2xvbmUATRJibGFrZTNfZW1wdHlfc3RhdGUAdBNibGFrZTNfdXBkYXRlX3N0YXRlAHoXYmxha2UzX2RpZ2VzdF9mb3Jfc3RhdGUAahduZXdfZWQyNTUxOV9zaWduaW5nX2tleQBcDGVkMjU1MTlfc2lnbgBIDmVkMjU1MTlfdmVyaWZ5AFMeZWQyNTUxOV9zaWduaW5nX2tleV9mcm9tX2J5dGVzAGwdZWQyNTUxOV9zaWduaW5nX2tleV90b19wdWJsaWMAWyBlZDI1NTE5X3ZlcmlmeWluZ19rZXlfZnJvbV9ieXRlcwBtHGVkMjU1MTlfc2lnbmF0dXJlX2Zyb21fYnl0ZXMAZAdkZWNyeXB0AD8Ec2VhbAApBnVuc2VhbAArBHNpZ24AMAZ2ZXJpZnkANA1nZXRfc2lnbmVyX2lkADYWbmV3X3gyNTUxOV9wcml2YXRlX2tleQBOEXgyNTUxOV9wdWJsaWNfa2V5AEMVeDI1NTE5X2RpZmZpZV9oZWxsbWFuADkNZ2V0X3NlYWxlcl9pZAAvEGRlY3J5cHRfeHNhbHNhMjAAQgVzdGFydACpARhlZDI1NTE5X3NpZ25pbmdfa2V5X3NpZ24ASBBlbmNyeXB0X3hzYWxzYTIwAEIVZWQyNTUxOV92ZXJpZnlpbmdfa2V5AFsTYmxha2UzaGFzaGVyX3VwZGF0ZQB6B2VuY3J5cHQAPxBibGFrZTNoYXNoZXJfbmV3AHQTX193YmluZGdlbl9leHBvcnRfMADQARNfX3diaW5kZ2VuX2V4cG9ydF8xAJsBE19fd2JpbmRnZW5fZXhwb3J0XzIAnwETX193YmluZGdlbl9leHBvcnRfMwCqAR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyANQBEF9fd2JpbmRnZW5fc3RhcnQAqQEJpgEBAEEBC1bSAXyAAbwBtQHCAccBXYkBtAHTAZ4BigHGAZIByQHHAagBtgF5casBrQGGAa4BrQGsAbMBsgGuAa4BrwGwAbEBxAGWAaEBdtUBvQG+AZYBiwHAAZYBoQF22QG9AXidAZ0BlgGiAXfBAcgBWaAB2gGHAX/gAcoBzAHhAYUBuAG6AbkBtwGBAXPLAZYBogF32wHPAc4BpQHNAZUBiAGTAbsBCp6BCcABhH0CLH8QfiMAQbAgayIHJAACQAJAAkACQAJAAkACQCACQSBGBEAgAUEGai0AACEIIAFBAmotAAAhCSABLwAEIQ0gAS0AByECIAEvAAAhCiABLQADIREgASkACCEzIAEtABUhFiABKAAQIRkgAS0AFCEXIAEtABghGCABLQAXIRogAS0AFiEdIAEtABshGyABLQAaIRwgAS0AGSEjIAcgAS0AHyIfQRJ0rUKAgPAPgyABLQAdIimtQv8Bg0IChiABLQAcIiGtQsABg0IGiIQgAS0AHiIqrUL/AYNCCoaEhD4ChCAgByAhQRR0rUKAgMAfgyAcrUL/AYNCBIYgI61C8AGDQgSIhCAbrUL/AYNCDIaEhD4CgCAgByAjQRV0rUKAgIAPgyAarUL/AYNCBYYgHa1C+AGDQgOIhCAYrUL/AYNCDYaEhD4C/B8gByAdQRd0rUKAgIAcgyAZQRl2rSAXrUL/AYNCB4aEIBatQv8Bg0IPhoSEPgL4HyAHIBlB////D3E2AvQfIAcgM0ImiEKAgPAfgyAzQiiIQv8BgyI1QgKGIDNCIIhC/wGDIjdCBoiEIDNCMIhC/wGDIjxCCoaEhD4C8B8gByAzQg2IQoCA4A+DIDNCEIhC/wGDIj1CA4YgM0IIiEL/AYMiOEIFiIQgM0IYiEL/AYMiP0ILhoSEPgLsHyAHIAogCUEQdHIgEUEYdHIiK0H///8fcTYC4B8gByAzQg2GQoCAgB+DIAhBEHQiAUETdq0gAq1C/wGDQgWGhCAzQv8BgyJAQg2GhIQ+AugfIAcgASANciIIQQZ0IgFBgICADnEgAUGAgP8BcSABQcD/AHEgEUECdnJycjYC5B8gB0GIEWoiCyAHQeAfahBWIAcgBykDqBEiNEL///8fgyAHKQOgESAHKQOYESAHKQOQESAHKQOIESI5QhqIfCI2QhmIfCI6QhqIfCI+QhmIfCI7p0H///8fcSIBNgKYICAHIAcpA7ARIDRCGoh8IjRC////D4MgO0IaiHwiOz4CnCAgByAHKQO4ESA0QhmIfCI0p0H///8fcSIRNgKgICAHIDZC////D4MgBykD0BEgBykDyBEgBykDwBEgNEIaiHwiNEIZiHwiNkIaiHwiQUIZiEITfiA5Qv///x+DfCI5QhqIfCJCPgKMICAHIDmnQf///x9xIgk2AoggIAcgPqdB////D3EiDTYClCAgByBBp0H///8PcSIKNgKsICAHIDqnQf///x9xIgw2ApAgIAcgNqdB////H3EiDjYCqCAgByA0p0H///8PcSIPNgKkICAHIBFB8P///wNqrSA7IAFB8P///wNqrSI0QhqIfELw////AXwiOUIZiHwiNqdB////H3E2AkAgByAPQfD///8Baq0gNkIaiHwiNqdB////D3E2AkQgByAOQfD///8Daq0gNkIZiHwiNqdB////H3E2AkggByAMQfD///8Daq0gQiAJQc/9//8Daq0iOkIaiHxC8P///wF8Ij5CGYh8IjunQf///x9xNgIwIAcgCkHw////AWqtIDZCGoh8IjanQf///w9xNgJMIAcgDUHw////AWqtIDtCGoh8IjunQf///w9xNgI0IAcgOUL///8PgyA0Qv///x+DIDtCGYh8IjRCGoh8PgI8IAcgNKdB////H3E2AjggByA+Qv///w+DIDZCGYhCE34gOkL///8fg3wiNEIaiHw+AiwgByA0p0H///8fcTYCKCALIAdBiCBqQdy6wAAQQSAHIAcoAqwRNgJ8IAcgBykCpBE3AnQgByAHKQKcETcCbCAHIAcpApQRNwJkIAcgBykCjBE3AlwgByAHKAKIEUEBajYCWCALIAdB2ABqIgkQViAHIAcpA7gRIAcpA7ARIAcpA6gRIjRCGoh8IjlCGYh8IjanQf///x9xNgKgAyAHIAcpA5gRIAcpA5ARIAcpA4gRIjpCGoh8Ij5CGYh8IjunQf///x9xNgKQAyAHIAcpA8ARIDZCGoh8IjanQf///w9xNgKkAyAHIAcpA6ARIDtCGoh8IjunQf///w9xNgKUAyAHIAcpA8gRIDZCGYh8IjanQf///x9xNgKoAyAHIDlC////D4MgNEL///8fgyA7QhmIfCI0QhqIfD4CnAMgByA0p0H///8fcTYCmAMgByAHKQPQESA2QhqIfCI0p0H///8PcTYCrAMgByA+Qv///w+DIDRCGYhCE34gOkL///8fg3wiNEIaiHw+AowDIAcgNKdB////H3E2AogDIAdB6AFqIgogB0GIA2oiASAJEEEgCyAKEFYgByAHKQO4ESAHKQOwESAHKQOoESI0QhqIfCI5QhmIfCI2p0H///8fcTYCoAMgByAHKQOYESAHKQOQESAHKQOIESI6QhqIfCI+QhmIfCI7p0H///8fcTYCkAMgByAHKQPAESA2QhqIfCI2p0H///8PcTYCpAMgByAHKQOgESA7QhqIfCI7p0H///8PcTYClAMgByAHKQPIESA2QhmIfCI2p0H///8fcTYCqAMgByA5Qv///w+DIDRC////H4MgO0IZiHwiNEIaiHw+ApwDIAcgNKdB////H3E2ApgDIAcgBykD0BEgNkIaiHwiNKdB////D3E2AqwDIAcgPkL///8PgyA0QhmIQhN+IDpC////H4N8IjRCGoh8PgKMAyAHIDSnQf///x9xNgKIAyAHQYgbaiIOIAEgCRBBIAdByB1qIg8gB0EoaiINIAoQQSAHQYgPaiIMIA0gDhBBIAsgDBA7IAdBqANqIAdBqBFqKQIANwMAIAdBoANqIAdBoBFqKQIANwMAIAdBmANqIAdBmBFqKQIANwMAIAdBkANqIAdBkBFqKQIANwMAIAcgBykCiBE3A4gDIAsgAUECEFUgB0GIDWoiCiAMIAsQQSAHQagcaiIMIA8gChBBIAsgDBBWIAcgBykDuBEgBykDsBEgBykDqBEiNEIaiHwiOUIZiHwiNqdB////H3E2AqADIAcgBykDmBEgBykDkBEgBykDiBEiOkIaiHwiPkIZiHwiO6dB////H3E2ApADIAcgBykDwBEgNkIaiHwiNqdB////D3E2AqQDIAcgBykDoBEgO0IaiHwiO6dB////D3E2ApQDIAcgBykDyBEgNkIZiHwiNqdB////H3E2AqgDIAcgOUL///8PgyA0Qv///x+DIDtCGYh8IjRCGoh8PgKcAyAHIDSnQf///x9xNgKYAyAHIAcpA9ARIDZCGoh8IjSnQf///w9xNgKsAyAHID5C////D4MgNEIZiEITfiA6Qv///x+DfCI0QhqIfD4CjAMgByA0p0H///8fcTYCiAMgAkEYdCAIciEsIAogCSABEEEgASAKEEwgCyANEExBACEBQQEhAgNAIAdBiANqIhAgAWotAAAgB0GIEWoiEiABai0AAEYQvwEgAnEhAiABQQFqIgFBIEcNAAsgAhC/ASEiIAdB8P///wMgBygCQGutQfD///8BIAcoAjxrrUHw////AyAHKAI4a60iNEIaiHwiOUIZiHwiNqdB////H3EiETYCoBEgB0Hw////AyAHKAIwa61B8P///wEgBygCLGutQdD9//8DIAcoAihrrSI6QhqIfCI+QhmIfCI7p0H///8fcSIINgKQESAHQfD///8BIAcoAkRrrSA2QhqIfCI2p0H///8PcSIJNgKkESAHQfD///8BIAcoAjRrrSA7QhqIfCI7p0H///8PcSINNgKUESAHQfD///8DIAcoAkhrrSA2QhmIfCI2p0H///8fcSIKNgKoESAHIDRC////H4MgO0IZiHwiNKdB////H3EiDDYCmBEgByA5Qv///w+DIDRCGoh8pyIONgKcESAHQfD///8BIAcoAkxrrSA2QhqIfCI0p0H///8PcSIPNgKsESAHIDRCGYhCE34gOkL///8fg3wiNKdB////H3EiCzYCiBEgByA+Qv///w+DIDRCGoh8pyITNgKMESAHQYgPaiAHQYgNahBMIBAgEhBMQQAhAUEBIQIDQCAHQYgPaiISIAFqLQAAIAdBiANqIhAgAWotAABGEL8BIAJxIQIgAUEBaiIBQSBHDQALIAIQvwEhICAHIA82AqwRIAcgCjYCqBEgByAJNgKkESAHIBE2AqARIAcgDjYCnBEgByAMNgKYESAHIA02ApQRIAcgCDYCkBEgByATNgKMESAHIAs2AogRIBAgB0GIEWpBhLvAABBBIAdByB1qIAdBiA1qEEwgEiAQEExBACEBQQEhAgNAIAdByB1qIAFqLQAAIAdBiA9qIgggAWotAABGEL8BIAJxIQIgAUEBaiIBQSBHDQALIAIQvwEhASAIQYS7wAAgB0GoHGoiFRBBIAdBsBxqIgJBACABICByEL8BQf8BcWsiASACKAIAIhEgBygCkA9zcSARcyIRNgIAIAdBuBxqIgggCCgCACIJIAcoApgPcyABcSAJcyIJNgIAIAdBwBxqIg0gDSgCACIKIAcoAqAPcyABcSAKcyIKNgIAIAcgBygCtBwiDCAHKAKUD3MgAXEgDHMiDDYCtBwgByAHKAKsHCIOIAcoAowPcyABcSAOcyIONgKsHCAHIAcoAqgcIg8gBygCiA9zIAFxIA9zIg82AqgcIAcgBygCvBwiCyAHKAKcD3MgAXEgC3MiCzYCvBwgByAHKALEHCITIAcoAqQPcyABcSATcyITNgLEHCAHQcgcaiISIBIoAgAiECAHKAKoD3MgAXEgEHMiEDYCACAHIAEgBygCzBwiASAHKAKsD3NxIAFzIhQ2AswcIAdBiBFqIBUQTCASQQAgBy0AiBFBAXEQvwFB/wFxayIBQfD///8DIBBrrUHw////ASATa61B8P///wMgCmutQfD///8BIAtrrUHw////AyAJa60iNEIaiHwiOUIZiHwiNkIaiHwiOkIZiHwiPqdB////H3EgEHNxIBBzNgIAIA0gNqdB////H3EgCnMgAXEgCnM2AgAgCCA0Qv///x+DQfD///8BIAxrrUHw////AyARa61B8P///wEgDmutQdD9//8DIA9rrSI0QhqIfCI2QhmIfCI7QhqIfCJBQhmIfCJCp0H///8fcSAJcyABcSAJczYCACACIDunQf///x9xIBFzIAFxIBFzNgIAIAdB8P///wEgFGutID5CGoh8Ij6nQf///w9xIBRzIAFxIBRzNgLMHCAHIDqnQf///w9xIBNzIAFxIBNzNgLEHCAHIAsgOUL///8PgyBCQhqIfKdzIAFxIAtzNgK8HCAHIEGnQf///w9xIAxzIAFxIAxzNgK0HCAHID5CGYhCE34gNEL///8fg3wiNKdB////H3EgD3MgAXEgD3M2AqgcIAcgDiA2Qv///w+DIDRCGoh8p3MgAXEgDnM2AqwcICAgInIQvwEhASAHQasDaiASKQIAIjQ3AAAgB0GjA2ogDSkCACI5NwAAIAdBmwNqIAgpAgAiNjcAACAHQZMDaiACKQIAIjo3AAAgB0GQEWoiAiA6NwMAIAdBmBFqIhEgNjcDACAHQaARaiIIIDk3AwAgB0GoEWoiLSIJIDQ3AwAgByAHKQKoHCI0NwCLAyAHIDQ3A4gRIAdB0BFqIg8gB0GAIGopAgA3AwAgB0HIEWoiCyAHQfgfaikCADcDACAHQcARaiIuIhMgB0HwH2opAgA3AwAgB0G4EWoiLyISIAdB6B9qKQIANwMAIAcgBykC4B83A7ARIAdBsB9qIg0gCSkDADcDACAHQagfaiIKIAgpAwA3AwAgB0GgH2oiDCARKQMANwMAIAdBmB9qIg4gAikDADcDACAHIAcpA4gRNwOQHyAHQdgfaiIQIA8pAwA3AwAgB0HQH2oiFCALKQMANwMAIAdByB9qIiAgEykDADcDACAHQcAfaiIiIBIpAwA3AwAgByAHKQOwETcDuB8CQAJAAkACQCABQf8BcQRAIA1BACAfQYABcUEHdhC/AUH/AXFrIgFB8P///wMgDSgCACIVa61B8P///wEgBygCrB8iJmutQfD///8DIAooAgAiJGutQfD///8BIAcoAqQfIidrrUHw////AyAMKAIAIihrrSI0QhqIfCI5QhmIfCI2QhqIfCI6QhmIfCI+p0H///8fcSAVc3EgFXM2AgAgDkHw////AyAOKAIAIhVrrUHw////ASAHKAKUHyIla61B0P3//wMgBygCkB8iHmutIjtCGoh8IkFCGYh8IkKnQf///x9xIBVzIAFxIBVzNgIAIAogJCAkIDanQf///x9xcyABcXM2AgAgDCAoICggNEL///8fg0Hw////ASAHKAKcHyIVa60gQkIaiHwiNEIZiHwiNqdB////H3FzIAFxczYCACAHQfD///8BIAcoArQfIiRrrSA+QhqIfCI+p0H///8PcSAkcyABcSAkczYCtB8gByAVIBUgNKdB////D3FzIAFxczYCnB8gByAmICYgOqdB////D3FzIAFxczYCrB8gByAnICcgOUL///8PgyA2QhqIfKdzIAFxczYCpB8gByAeIB4gPkIZiEITfiA7Qv///x+DfCI0p0H///8fcXMgAXFzNgKQHyAHICUgJSBBQv///w+DIDRCGoh8p3MgAXFzNgKUHyAJIA0pAwA3AwAgCCAKKQMANwMAIBEgDCkDADcDACACIA4pAwA3AwAgByAHKQOQHzcDiBEgB0GAEmogB0GQH2ogB0G4H2oQQSAPIBApAwA3AwAgCyAUKQMANwMAIBMgICkDADcDACASICIpAwA3AwAgB0HgEWpBlLrAACkCADcDACAHQegRakGcusAAKQIANwMAIAdB8BFqQaS6wAApAgA3AwAgB0H4EWpBrLrAACkCADcDACAHIAcpA7gfNwOwESAHQYy6wAApAgA3A9gRIAdBCGogIikDADcDACAHQRBqICApAwA3AwAgB0EYaiAUKQMANwMAIAdBIGogECkDADcDACAHIAcpA7gfNwMAIAZBwABHDQYgM0KAgICAgICAgH+DIDxCMIaEIDVCKIaEIDdCIIaEID9CGIaEID1CEIaEIDhCCIaEIECEITMgCSgCACEJIAgoAgAhCCARKAIAIQ0gAigCACEKIAcoAqwRIQwgBygCpBEhDiAHKAKcESEPIAcoApQRIQsgBygCjBEhEyAHKAKIESESIAcoAqQSIRAgBygCoBIh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AmogB0EQaikDADcCACAHQZgCaiAHQQhqKQMANwIAIAdBwAJqQZS6wAApAgA3AgAgB0HIAmpBnLrAACkCADcCACAHQdACakGkusAAKQIANwIAIAdB2AJqQay6wAApAgA3AgAgByAHKQMANwKQAiAHQYy6wAApAgA3ArgCIAdB8P///wMgImutQfD///8BIBVrrUHw////AyAma60iM0IaiHwiNUIZiHwiN6dB////H3E2AvgCIAdB8P///wMgJ2utQfD///8BIChrrUHQ/f//AyAla60iPEIaiHwiPUIZiHwiOKdB////H3E2AugCIAdB8P///wMgCGutQfD///8BIA9rrUHw////AyANa60iP0IaiHwiQEIZiHwiNKdB////H3EiBDYCgAIgB0Hw////AyAKa61B8P///wEgE2utQdD9//8DIBJrrSI5QhqIfCI2QhmIfCI6p0H///8fcSIZNgLwASAHQfD///8BICBrrSA3QhqIfCI3p0H///8PcTYC/AIgB0Hw////ASAka60gOEIaiHwiOKdB////D3E2AuwCIAdB8P///wEgDmutIDRCGoh8IjSnQf///w9xIh02AoQCIAdB8P///wEgC2utIDpCGoh8IjqnQf///w9xIiM2AvQBIAdB8P///wMgFGutIDdCGYh8IjenQf///x9xNgKAAyAHIDVC////D4MgM0L///8fgyA4QhmIfCIzQhqIfD4C9AIgByAzp0H///8fcTYC8AIgB0Hw////AyAJa60gNEIZiHwiM6dB////H3EiETYCiAIgByA/Qv///x+DIDpCGYh8IjWnQf///x9xIgg2AvgBIAcgQEL///8PgyA1QhqIfKciCTYC/AEgB0Hw////ASAQa60gN0IaiHwiNadB////D3E2AoQDIAdB8P///wEgDGutIDNCGoh8IjOnQf///w9xIg02AowCIAcgPUL///8PgyA1QhmIQhN+IDxC////H4N8IjVCGoh8PgLkAiAHIDWnQf///x9xNgLgAiAHIDNCGYhCE34gOUL///8fg3wiM6dB////H3EiCjYC6AEgByA2Qv///w+DIDNCGoh8pyIMNgLsASAHQYgNakGAAhDeARpCACEzIAdCADcDqA8gB0H4AGohAyAHQeACaiEOQQAhAQNAQQAgAWshAgJAA0AgAUEGdiEFAn4gAUE/cSIGQTtPBEAgB0GID2ogBUEDdGoiBUEIaikDACACQT9xrYYgBSkDACAGrYiEDAELIAdBiA9qIAVBA3RqKQMAIAatiAtCH4MgM3wiNUIBg1AEQCACQQFrIQIgAUEBaiIBQYACRw0BDAILCyAHQYgNaiABaiA1p0FgQQAgNUIPViICG2o6AAAgAUH7AUkgAq0hMyABQQVqIQENAQsLIAdBiA9qQYACEN4BGiAHQZARaiADQQhqKQAANwMAIAdBmBFqIANBEGopAAA3AwAgB0GgEWogA0EYaikAADcDAEIAITMgB0IANwOoESAHIAMpAAA3A4gRQQAhAQNAQQAgAWshAgJAA0AgAUEGdiEDAn4gAUE/cSIFQThPBEAgB0GIEWogA0EDdGoiA0EIaikDACACQT9xrYYgAykDACAFrYiEDAELIAdBiBFqIANBA3RqKQMAIAWtiAtC/wGDIDN8IjVCAYNQBEAgAkEBayECIAFBAWoiAUGAAkcNAQwCCwsgB0GID2ogAWogNTwAACABQfgBSSA1Qv8AVq0hMyABQQhqIQENAQsLQf8BIQEDQCABIgIgB0GIDWpqLQAAIgMNBkEAIQMgAUUNBiABQQFrIQEgB0GID2ogAmotAABFDQALDAULQez1wgBBLkGc9sIAEKMBAAtBrfXCAEEuQdz1wgAQowEAC0GEmsAAQTcgB0GIEWpBvIPAAEGYm8AAEJQBAAsgAEEANgIADAMLIABBAzYCAAwCCyAHIAcoAqgCIgEgBGtB8P///wNqrSAHKAKkAiIPIAlrQfD///8Baq0gBygCoAIiCyAIa0Hw////A2qtIjNCGoh8IjVCGYh8IjenQf///x9xNgLIAyAHIAcoApgCIhMgGWtB8P///wNqrSAHKAKUAiISIAxrQfD///8Baq0gBygCkAIiECAKa0HQ/f//A2qtIjxCGoh8Ij1CGYh8IjinQf///x9xNgK4AyAHIAcoAqwCIhQgHWtB8P///wFqrSA3QhqIfCI3p0H///8PcTYCzAMgByAHKAKcAiIWICNrQfD///8Baq0gOEIaiHwiOKdB////D3E2ArwDIAcgBygCsAIiFyARa0Hw////A2qtIDdCGYh8IjenQf///x9xNgLQAyAHIDVC////D4MgM0L///8fgyA4QhmIfCIzQhqIfD4CxAMgByAzp0H///8fcTYCwAMgByAHKAK0AiIYIA1rQfD///8Baq0gN0IaiHwiM6dB////D3E2AtQDIAcgPUL///8PgyAzQhmIQhN+IDxC////H4N8IjNCGoh8PgK0AyAHIDOnQf///x9xNgKwA0EAIQYgB0H4A2pBrLrAACkCACIzNwIAIAdB8ANqQaS6wAApAgAiNTcCACAHQegDakGcusAAKQIAIjc3AgAgB0HgA2pBlLrAACkCACI8NwIAIAdBjLrAACkCACI9NwLYAyAHQYAEaiIFIA5BtLrAABBBIAcgDSAYajYCrAMgByARIBdqNgKoAyAHIBQgHWo2AqQDIAcgASAEajYCoAMgByAJIA9qNgKcAyAHIAggC2o2ApgDIAcgFiAjajYClAMgByATIBlqNgKQAyAHIAwgEmo2AowDIAcgCiAQajYCiAMgB0GIEWogB0GIA2oiAUGgARDfARogB0GoEmogAUGgARDfARogB0HIE2ogAUGgARDfARogB0HoFGogAUGgARDfARogB0GIFmogAUGgARDfARogB0GoF2ogAUGgARDfARogB0HIGGogAUGgARDfARogB0HoGWogAUGgARDfARogB0GQHmogB0EgaikDADcDACAHQYgeaiAHQRhqKQMANwMAIAdBgB5qIAdBEGopAwA3AwAgB0H4HWogB0EIaikDADcDACAHQaAeaiA8NwMAIAdBqB5qIDc3AwAgB0GwHmogNTcDACAHQbgeaiAzNwMAIAcgBykDADcD8B0gByA9NwOYHiAHQegdaiAHQYgCaikCADcDACAHQeAdaiAHQYACaikCADcDACAHQdgdaiAHQfgBaikCADcDACAHQdAdaiAHQfABaikCADcDACAHIAcpAugBNwPIHSABIAdByB1qEC4gB0GIG2ogASAFEEEgB0GwG2ogB0GwA2oiGSAHQdgDaiIdEEEgB0HYG2ogHSAFEEEgB0GAHGogASAZEEEgB0GgHWohISAHQfgcaiEEIAdBwB5qISMgB0GYHmohASAHQfAdaiEgA0AgB0GIA2oiFSAHQYgbaiAHQYgRaiIeIAZqIiIQPCAHQcgdaiAVIAUQQSAgIBkgHRBBIAEgHSAFEEEgIyAVIBkQQSAHKALsHSERIAcoApQeIQggBygC6B0hCSAHKAKQHiENIAcoAtQdIQogBygC/B0hDCAHKALkHSEOIAcoAoweIQ8gBygC0B0hCyAHKAL4HSETIAcoAswdIRIgBygC9B0hECAHKALIHSEUIAcoAvAdIRYgBygC4B0hFyAHKAKIHiEYIAcoAtwdIRogBygChB4hGyAHKALYHSEcIAcoAoAeIR8gBCABKQIANwIAIARBCGogAUEIaikCADcCACAEQRBqIAFBEGopAgA3AgAgBEEYaiABQRhqKQIANwIAIARBIGogAUEgaikCADcCACAHIBggF2tB8P///wNqrSAbIBprQfD///8Baq0gHyAca0Hw////A2qtIjNCGoh8IjVCGYh8IjenQf///x9xNgLoHCAHIBMgC2tB8P///wNqrSAQIBJrQfD///8Baq0gFiAUa0HQ/f//A2qtIjxCGoh8Ij1CGYh8IjinQf///x9xNgLYHCAHIA8gDmtB8P///wFqrSA3QhqIfCI3p0H///8PcTYC7BwgByAMIAprQfD///8Baq0gOEIaiHwiOKdB////D3E2AtwcIAcgDSAJa0Hw////A2qtIDdCGYh8IjenQf///x9xNgLwHCAHIDVC////D4MgM0L///8fgyA4QhmIfCIzQhqIfD4C5BwgByAzp0H///8fcTYC4BwgByAIIBFrQfD///8Baq0gN0IaiHwiM6dB////D3E2AvQcIAcgPUL///8PgyAzQhmIQhN+IDxC////H4N8IjNCGoh8PgLUHCAHIDOnQf///x9xNgLQHCAhICNBtLrAABBBIAcgCCARajYCzBwgByAJIA1qNgLIHCAHIA4gD2o2AsQcIAcgFyAYajYCwBwgByAaIBtqNgK8HCAHIBwgH2o2ArgcIAcgCiAMajYCtBwgByALIBNqNgKwHCAHIBAgEmo2AqwcIAcgFCAWajYCqBwgIkGgAWogB0GoHGpBoAEQ3wEaIAZBoAFqIgZB4AhHDQALIBUgHkGAChDfARogB0HIHGpCADcDACAHQcAcakIANwMAIAdBuBxqQgA3AwAgB0GwHGpCADcDACAHQdgcakGUusAAKQIAIjM3AwAgB0HgHGpBnLrAACkCACI1NwMAIAdB6BxqQaS6wAApAgAiNzcDACAHQfAcakGsusAAKQIAIjw3AwAgB0GAHWogMzcDACAHQYgdaiA1NwMAIAdBkB1qIDc3AwAgB0GYHWogPDcDACAHQgA3A6gcIAdBjLrAACkCACIzNwPQHCAHIDM3A/gcIAdB2BFqIQYg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Goh8IjZCGYh8IjqnQf///x9xNgKgHiAHICQgJmtB8P///wFqrSA3QhqIfCI3p0H///8PcTYC5B0gByAbIBprQfD///8Baq0gOEIaiHwiOKdB////D3E2AtQdIAcgLiAPa0Hw////AWqtIDRCGoh8IjSnQf///w9xNgK0HiAHICogDWtB8P///wFqrSA6QhqIfCI6p0H///8PcTYCpB4gByAoICdrQfD///8Daq0gN0IZiHwiN6dB////H3E2AugdIAcgNUL///8PgyAzQv///x+DIDhCGYh8IjNCGoh8PgLcHSAHIDOnQf///x9xNgLYHSAHIC8gC2tB8P///wNqrSA0QhmIfCIzp0H///8fcTYCuB4gByBAQv///w+DID9C////H4MgOkIZiHwiNUIaiHw+AqweIAcgNadB////H3E2AqgeIAcgMiAxa0Hw////AWqtIDdCGoh8IjWnQf///w9xNgLsHSAHIDAgE2tB8P///wFqrSAzQhqIfCIzp0H///8PcTYCvB4gByA9Qv///w+DIDVCGYhCE34gPEL///8fg3wiNUIaiHw+AswdIAcgNadB////H3E2AsgdIAcgNkL///8PgyAzQhmIQhN+IDlC////H4N8IjNCGoh8PgKcHiAHIDOnQf///x9xNgKYHgwBCyAHQcgdaiAHQYgRaiAHQYgDaiAIQaABbGoQPAsCQAJAAkACQCAHQYgPaiACaiwAACIDQQBHQX8gA0EATiIIG0H/AXEOAgMBAAsgB0GIEWogB0HIHWoiCCAEEEEgHSAFIAEQQSAGIAEgBBBBIBkgCCAFEEFBACADa8AiCEEBdiEDIAhBAE4NASADQcAAQaT4wAAQmQEACyAHQYgRaiAHQcgdaiIJIAQQQSAdIAUgARBBIAYgASAEEEEgGSAJIAUQQSADQQF2IQMgCEUEQCADQcAAQaT4wAAQmQEACyAHQcgdaiAHQYgRaiADQfgAbEGsu8AAahA9DAELIAcoArARIQggBygCiBEhCSAHKAK0ESENIAcoAowRIQogBygCuBEhDCAHKAKQESEOIAcoArwRIQ8gBygClBEhCyAHKALAESETIAcoApgRIRIgBygCxBEhECAHKAKcESEUIAcoAsgRIRYgBygCoBEhFyAHKALMESEYIAcoAqQRIRogBygC0BEhGyAHKAKoESEcIAcgBygCrBEiHyAHKALUESIhajYCtB8gByAbIBxqNgKwHyAHIBggGmo2AqwfIAcgFiAXajYCqB8gByAQIBRqNgKkHyAHIBIgE2o2AqAfIAcgCyAPajYCnB8gByAMIA5qNgKYHyAHIAogDWo2ApQfIAcgCCAJajYCkB8gByAWIBdrQfD///8Daq0gECAUa0Hw////AWqtIBMgEmtB8P///wNqrSIzQhqIfCI1QhmIfCI3p0H///8fcTYC0B8gByAMIA5rQfD///8Daq0gDSAKa0Hw////AWqtIAggCWtB0P3//wNqrSI8QhqIfCI9QhmIfCI4p0H///8fcTYCwB8gByAYIBprQfD///8Baq0gN0IaiHwiN6dB////D3E2AtQfIAcgDyALa0Hw////AWqtIDhCGoh8IjinQf///w9xNgLEHyAHIBsgHGtB8P///wNqrSA3QhmIfCI3p0H///8fcTYC2B8gByA1Qv///w+DIDNC////H4MgOEIZiHwiM0IaiHw+AswfIAcgM6dB////H3E2AsgfIAcgISAfa0Hw////AWqtIDdCGoh8IjOnQf///w9xNgLcHyAHID1C////D4MgM0IZiEITfiA8Qv///x+DfCIzQhqIfD4CvB8gByAzp0H///8fcTYCuB8gB0HgH2ogB0GQH2ogA0H4AGwiA0HUu8AAahBBIAdBiCBqIAdBuB9qIANBrLvAAGoQQSAHQYgbaiAZIANB/LvAAGoQQSAHKAKIGyEDIAcoAtgRISUgBygCjBshCCAHKALcESEeIAcoApAbIQkgBygC4BEhKSAHKAKUGyENIAcoAuQRISogBygCmBshCiAHKALoESErIAcoApwbIQwgBygC7BEhLCAHKAKgGyEOIAcoAvARIS0gBygCpBshDyAHKAL0ESEuIAcoAqgbIQsgBygC+BEhLyAHKAKsGyETIAcoAvwRITAgBygCiCAhEiAHKALgHyEQIAcoAowgIRQgBygC5B8hFiAHKAKQICEXIAcoAugfIRggBygClCAhGiAHKALsHyEbIAcoApggIRwgBygC8B8hHyAHKAKcICEhIAcoAvQfISAgBygCoCAhIiAHKAL4HyEVIAcoAqQgISYgBygC/B8hJCAHKAKoICEnIAcoAoAgISggByAHKAKsICIxIAcoAoQgIjJqNgKUHiAHICcgKGo2ApAeIAcgJCAmajYCjB4gByAVICJqNgKIHiAHICAgIWo2AoQeIAcgHCAfajYCgB4gByAaIBtqNgL8HSAHIBcgGGo2AvgdIAcgFCAWajYC9B0gByAQIBJqNgLwHSAHIBMgMEEBdCIwajYC5B4gByALIC9BAXQiL2o2AuAeIAcgDyAuQQF0Ii5qNgLcHiAHIA4gLUEBdCItajYC2B4gByAMICxBAXQiLGo2AtQeIAcgCiArQQF0IitqNgLQHiAHIA0gKkEBdCIqajYCzB4gByAJIClBAXQiKWo2AsgeIAcgCCAeQQF0Ih5qNgLEHiAHIAMgJUEBdCIlajYCwB4gByAVICJrQfD///8Daq0gICAha0Hw////AWqtIB8gHGtB8P///wNqrSIzQhqIfCI1QhmIfCI3p0H///8fcTYC4B0gByAYIBdrQfD///8Daq0gFiAUa0Hw////AWqtIBAgEmtB0P3//wNqrSI8QhqIfCI9QhmIfCI4p0H///8fcTYC0B0gByAtIA5rQfD///8Daq0gLCAMa0Hw////AWqtICsgCmtB8P///wNqrSI/QhqIfCJAQhmIfCI0p0H///8fcTYCsB4gByApIAlrQfD///8Daq0gHiAIa0Hw////AWqtICUgA2tB0P3//wNqrSI5QhqIfCI2QhmIfCI6p0H///8fcTYCoB4gByAkICZrQfD///8Baq0gN0IaiHwiN6dB////D3E2AuQdIAcgGyAaa0Hw////AWqtIDhCGoh8IjinQf///w9xNgLUHSAHIC4gD2tB8P///wFqrSA0QhqIfCI0p0H///8PcTYCtB4gByAqIA1rQfD///8Baq0gOkIaiHwiOqdB////D3E2AqQeIAcgKCAna0Hw////A2qtIDdCGYh8IjenQf///x9xNgLoHSAHIDVC////D4MgM0L///8fgyA4QhmIfCIzQhqIfD4C3B0gByAzp0H///8fcTYC2B0gByAvIAtrQfD///8Daq0gNEIZiHwiM6dB////H3E2ArgeIAcgQEL///8PgyA/Qv///x+DIDpCGYh8IjVCGoh8PgKsHiAHIDWnQf///x9xNgKoHiAHIDIgMWtB8P///wFqrSA3QhqIfCI1p0H///8PcTYC7B0gByAwIBNrQfD///8Baq0gM0IaiHwiM6dB////D3E2ArweIAcgPUL///8PgyA1QhmIQhN+IDxC////H4N8IjVC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aq0iREIaiHwiSUIZiHwiRadB////H3E2AuABIAMgJCAla0Hw////A2qtICYgJ2tB8P///wFqrSApICtrQdD9//8Daq0iR0IaiHwiSEIZiHwiRqdB////H3E2AtABIAMgDyAQa0Hw////AWqtIEVCGoh8IkWnQf///w9xNgLkASADICIgI2tB8P///wFqrSBGQhqIfCJGp0H///8PcTYC1AEgAyACIAVrQfD///8Daq0gRUIZiHwiRadB////H3E2AugBIAMgSUL///8PgyBEQv///x+DIEZCGYh8IkRCGoh8PgLcASADIESnQf///x9xNgLYASADIC0gLGtB8P///wFqrSBFQhqIfCJEp0H///8PcTYC7AEgAyBIQv///w+DIERCGYhCE34gR0L///8fg3wiREIaiHw+AswBIAMgRKdB////H3E2AsgBIAMgCiAxcyICIBggMHMiGGo2ApQCIAMgCyBCcyIKIBkgQ3MiGWo2ApACIAMgDCBAcyILIBogQXMiGmo2AowCIAMgDSA+cyIMIAggP3MiCGo2AogCIAMgDiA8cyINIBYgPXMiFmo2AoQCIAMgHSA6cyIOIBsgO3MiG2o2AoACIAMgHiA4cyIdIBwgOXMiHGo2AvwBIAMgHyA2cyIeIAcgN3MiB2o2AvgBIAMgICA0cyIfIAkgNXMiCWo2AvQBIAMgKCAycyIgIBcgM3MiF2o2AvABIAMgGCACa0Hw////AWqtIBkgCmtB8P///wNqrSAaIAtrQfD///8Baq0gCCAMa0Hw////A2qtIBYgDWtB8P///wFqrSAbIA5rQfD///8Daq0iREIaiHwiSUIZiHwiRUIaiHwiR0IZiHwiSEIaiHwiRqdB////D3E2ArwCIAMgSKdB////H3E2ArgCIAMgR6dB////D3E2ArQCIAMgRadB////H3E2ArACIAMgSUL///8PgyBEQv///x+DIBwgHWtB8P///wFqrSAHIB5rQfD///8Daq0gCSAfa0Hw////AWqtIBcgIGtB0P3//wNqrSJEQhqIfCJJQhmIfCJFQhqIfCJHQhmIfCJIQhqIfD4CrAIgAyBIp0H///8fcTYCqAIgAyBHp0H///8PcTYCpAIgAyBFp0H///8fcTYCoAIgAyBJQv///w+DIEZCGYhCE34gREL///8fg3wiREIaiHw+ApwCIAMgRKdB////H3E2ApgCIANB0AVqIgYgA0GgAWoiBBBWIAMgAykDmAYgAykDkAYgAykDiAYgAykDgAYgAykD+AUgAykD8AUiREIaiHwiSUIZiHwiRUIaiHwiR0IZiHwiSEIaiHwiRkIZiEITfiADKQPQBSJLQv///x+DfCJMp0H///8fcSIHNgLAAiADIAMpA9gFIEtCGoh8IktC////D4MgTEIaiHwiTD4CxAIgAyBEQv///x+DIAMpA+gFIAMpA+AFIEtCGYh8IkRCGoh8IktCGYh8Ik2nQf///x9xIgg2AtACIAMgSUL///8PgyBNQhqIfCJJPgLUAiADIEunQf///w9xIgk2AswCIAMgRqdB////D3EiCjYC5AIgAyBEp0H///8fcSILNgLIAiADIEinQf///x9xIgw2AuACIAMgR6dB////D3EiDTYC3AIgAyBFp0H///8fcSIONgLYAiAGIANByAFqIgUQViADKQP4BSFEIAMgAykD8AUiRUL///8fgyADKQPoBSADKQPgBSADKQPYBSADKQPQBSJHQhqIfCJIQhmIfCJGQhqIfCJLQhmIfCJNp0H///8fcSICNgL4AiADIAMpA4AGIEQgRUIaiHwiREIZiHwiRadB////H3EiFjYCgAMgAyBIQv///w+DIAMpA5gGIAMpA5AGIAMpA4gGIEVCGoh8IkVCGYh8IkhCGoh8Ik5CGYhCE34gR0L///8fg3wiR0IaiHwiSqciEjYC7AIgAyBEQv///w+DIE1CGoh8IkSnIhM2AvwCIAMgR6dB////H3EiFzYC6AIgAyBLp0H///8PcSIYNgL0AiADIE6nQf///w9xIhk2AowDIAMgRqdB////H3EiGjYC8AIgAyBIp0H///8fcSIbNgKIAyADIEWnQf///w9xIhw2AoQDIAMgDiAWa0Hw////A2qtIEkgRH0gCCACa0Hw////A2qtIkRCGoh8QvD///8BfCJJQhmIfCJFp0H///8fcTYCqAMgAyANIBxrQfD///8Baq0gRUIaiHwiRadB////D3E2AqwDIAMgDCAba0Hw////A2qtIEVCGYh8IkWnQf///x9xNgKwAyADIAsgGmtB8P///wNqrSBMIEp9IAcgF2tB0P3//wNqrSJHQhqIfELw////AXwiSEIZiHwiRqdB////H3E2ApgDIAMgCiAZa0Hw////AWqtIEVCGoh8IkWnQf///w9xNgK0AyADIAkgGGtB8P///wFqrSBGQhqIfCJGp0H///8PcTYCnAMgAyBJQv///w+DIERC////H4MgRkIZiHwiREIaiHw+AqQDIAMgRKdB////H3E2AqADIAMgSEL///8PgyBFQhmIQhN+IEdC////H4N8IkRCGoh8PgKUAyADIESnQf///x9xNgKQAyADQbgDaiAEIANBmAJqEEEgA0HgA2ogBSADQfABahBBIAMoArgDIQcgAygC4AMhCCADKAK8AyEJIAMoAuQDIQogAygCwAMhCyADKALoAyEMIAMoAsQDIQ0gAygC7AMhDiADKALIAyEdIAMoAvADIR4gAygCzAMhHyADKAL0AyEgIAMoAtADISggAygC+AMhBCADKALUAyEFIAMoAvwDIQ8gAygC2AMhECADKAKABCERIAMgAygChAQiFCADKALcAyIVajYCrAQgAyAQIBFqNgKoBCADIAUgD2o2AqQEIAMgBCAoajYCoAQgAyAfICBqNgKcBCADIB0gHmo2ApgEIAMgDSAOajYClAQgAyALIAxqNgKQBCADIAkgCmo2AowEIAMgByAIajYCiAQgAyAoIARrQfD///8Daq0gHyAga0Hw////AWqtIB0gHmtB8P///wNqrSJEQhqIfCJJQhmIfCJFp0H///8fcTYCyAQgAyALIAxrQfD///8Daq0gCSAKa0Hw////AWqtIAcgCGtB0P3//wNqrSJHQhqIfCJIQhmIfCJGp0H///8fcTYCuAQgAyAFIA9rQfD///8Baq0gRUIaiHwiRadB////D3E2AswEIAMgDSAOa0Hw////AWqtIEZCGoh8IkanQf///w9xNgK8BCADIBAgEWtB8P///wNqrSBFQhmIfCJFp0H///8fcTYC0AQgAyBJQv///w+DIERC////H4MgRkIZiHwiREIaiHw+AsQEIAMgRKdB////H3E2AsAEIAMgFSAUa0Hw////AWqtIEVCGoh8IkSnQf///w9xNgLUBCADIEhC////D4MgREIZiEITfiBHQv///x+DfCJEQhqIfD4CtAQgAyBEp0H///8fcTYCsAQgBiADQYgEahBWIAMpA5gGIAMpA5AGIAMpA4gGIAMpA4AGIAMpA/gFIAMpA+gFIUwgAykD4AUhTSADKQPYBSFOIAMpA9AFIUQgAykD8AUhSSAGIANBsARqEFYgAyADKQOABiADKQP4BSADKQPwBSJKQhqIfCJRQhmIfCJPp0H///8fcTYC8AQgAyADKQPgBSADKQPYBSADKQPQBSJSQhqIfCJTQhmIfCJQp0H///8fcTYC4AQgAyADKQOIBiBPQhqIfCJPp0H///8PcTYC9AQgAyADKQPoBSBQQhqIfCJQp0H///8PcTYC5AQgAyADKQOQBiBPQhmIfCJPp0H///8fcTYC+AQgAyBRQv///w+DIEpC////H4MgUEIZiHwiSkIaiHw+AuwEIAMgSqdB////H3E2AugEIAMgAykDmAYgT0IaiHwiSqdB////D3E2AvwEIAMgU0L///8PgyBKQhmIQhN+IFJC////H4N8IkpCGoh8PgLcBCADIEqnQf///x9xNgLYBCADQYAFakG0+MAAIANBkANqIgQQQSADQcgAaiADQcACaiADQegCahBBIAMgAygCpAUgGWo2AswFIAMgAygCoAUgG2o2AsgFIAMgAygCnAUgHGo2AsQFIAMgAygCmAUgFmo2AsAFIAMgAygClAUgE2o2ArwFIAMgAygCkAUgAmo2ArgFIAMgAygCjAUgGGo2ArQFIAMgAygCiAUgGmo2ArAFIAMgAygChAUgEmo2AqwFIAMgAygCgAUgF2o2AqgFIC4gBCADQagFahBBIElC////H4MgTCBNIE4gREIaiHwiTkIZiHwiTUIaiHwiTEIZiHwiSqdB////H3EhGyBJQhqIfCJJQhmIfCJGQhqIfCJIQhmIfCJHQhqIfCJFQhmIQhN+IERC////H4N8IkSnQf///x9xIRcgSUL///8PgyBKQhqIfKchFiBOQv///w+DIERCGoh8pyEJIC9BAXEhAiBGp0H///8fcSEIIE2nQf///x9xIQcgSKdB////D3EhGiBMp0H///8PcSEcIEenQf///x9xIRkgRadB////D3EhGCAGIANBIGogA0HYBGoQQSADKAL0BSEKIAMoAvAFIQsgAygC7AUhDCADKALoBSENIAMoAuQFIQ4gAygC4AUhHSADKALcBSEeIAMoAtgFIR8gAygC1AUhICADKALQBSEoDAELCyACEL8BIQEgAygCSCECIAMoAkwhISADKAJQIQQgAygCVCEqIAMoAlghBSADKAJcIQ8gAygCYCEQIAMoAmQhESADKAJoIRIgAygCbCETIAMoAnAhFCADKAJ0IRUgAygCeCEGIAMoAnwhIiADKAKAASEjIAMoAoQBISQgAygCiAEhJSADKAKMASEmIAMoApABIScgA0EAIAFB/wFxayIBIAogAygClAEiKXNxIClzNgKUASADICcgCyAncyABcXM2ApABIAMgJiAMICZzIAFxczYCjAEgAyAlIA0gJXMgAXFzNgKIASADICQgDiAkcyABcXM2AoQBIAMgIyAdICNzIAFxczYCgAEgAyAiIB4gInMgAXFzNgJ8IAMgBiAGIB9zIAFxczYCeCADIBUgFSAgcyABcXM2AnQgAyAUIBQgKHMgAXFzNgJwIAMgEyATIBhzIAFxczYCbCADIBIgEiAZcyABcXM2AmggAyARIBEgGnMgAXFzNgJkIAMgECAIIBBzIAFxczYCYCADIA8gDyAWcyABcXM2AlwgAyAFIAUgG3MgAXFzNgJYIAMgKiAcICpzIAFxczYCVCADIAQgBCAHcyABcXM2AlAgAyAhIAkgIXMgAXFzNgJMIAMgAiACIBdzIAFxczYCSCADQQA6AJ8BIANB0AVqIgEgLhA7IANBoAVqIANB8AVqKQIANwMAIANBmAVqIANB6AVqKQIANwMAIANBkAVqIANB4AVqKQIANwMAIANBiAVqIANB2AVqKQIANwMAIAMgAykC0AU3A4AFIANByAVqIANBmAZqKQIANwMAIANBwAVqIANBkAZqKQIANwMAIANBuAVqIANBiAZqKQIANwMAIANBsAVqIANBgAZqKQIANwMAIAMgAykC+AU3A6gFIAEgA0GABWpBBRBVIANB2ARqIgIgASADQagFahBBIAEgA0HIAGogAhBBIAAgARBMIANBoAZqJAAPCyAEQSBB/LnAABCZAQALkD4CIX8kfiMAQaAHayIFJAACQCACQSBGBEAgBUEGaiABQQJqIgctAAA6AAAgBUETaiABQQ9qIggpAAA3AAAgBUEjaiABQR9qIgktAAA6AAAgBSABLwAAOwEEIAUgASgAAyIKNgAHIAUgASkABzcACyAFIAEpABc3ABsgBUHIAmoiBiAFQQRqED4gBUEkaiICIAYQNyAFQYAFaiILIAIQZSAFQaAFaiACQaABEN8BGiAGEGkgBUHmAWogBy0AADoAACAFQfMBaiAIKQAANwAAIAVBgwJqIAktAAA6AAAgBSAKNgDn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CyACQfgBaiIBIAIoAlAiBkEGdCACKAJMIgRBGnZyQf////8BcTYCACACQYACaiIDIAIoAlgiC0EMdCACKAJUIgxBFHZyQf////8BcTYCACACQYgCaiIIIAIoAmAiCUESdCACKAJcIg1BDnZyQf////8BcTYCACACQZACaiIFIAIoAmgiDkEYdCACKAJkIgpBCHZyQf////8BcTYCACACIAIoAkgiB0H/////AXE2AvABIAIgBEEDdCAHQR12ckH/////AXE2AvQBIAIgDEEJdCAGQRd2ckH/////AXE2AvwBIAIgDUEPdCALQRF2ckH/////AXE2AoQCIAIgCkEVdCAJQQt2ckH/////AXE2AowCIAJBuAJqIgYgAigChAEiCUENdjYCACACQaACaiINIAIoAnAiCkEBdCACKAJsIgRBH3ZyQf////8BcTYCACACQagCaiILIAIoAngiB0EHdCACKAJ0Ig9BGXZyQf////8BcTYCACACQbACaiIMIAIoAoABIhBBDXQgAigCfCIRQRN2ckH/////AXE2AgAgAiAEQQJ2Qf////8BcTYCnAIgAiAEQRt0IA5BBXZyQf////8BcTYCmAIgAiAPQQR0IApBHHZyQf////8BcTYCpAIgAiARQQp0IAdBFnZyQf////8BcTYCrAIgAiAJQRB0IBBBEHZyQf////8BcTYCtAIgAkG8AmoiByACQfABakHwuMAAEDogBSACQdwCaiIEKAIANgIAIAggAkHUAmoiCSkCADcDACADIAJBzAJqIg4pAgA3AwAgASACQcQCaiIKKQIANwMAIAIgAikCvAI3A/ABIAcgAkGYAmpB1PnAABA6IAYgBCgCADYCACAMIAkpAgA3AwAgCyAOKQIANwMAIA0gCikCACISNwMAIAIgAikCvAIiEzcDmAIgAiACKALwASATp2oiBEH/////AXE2ArwCIAIgAigC9AEgAigCnAIgBEEddmpqIgRB/////wFxNgLAAiACIAEoAgAgEqcgBEEddmpqIgFB/////wFxNgLEAiACIAIoAvwBIAIoAqQCIAFBHXZqaiIBQf////8BcTYCyAIgAiADKAIAIAsoAgAgAUEddmpqIgFB/////wFxNgLMAiACIAIoAoQCIAIoAqwCIAFBHXZqaiIBQf////8BcTYC0AIgAiAIKAIAIAwoAgAgAUEddmpqIgFB/////wFxNgLUAiACIAIoAowCIAIoArQCIAFBHXZqaiIBQf////8BcTYC2AIgAiAFKAIAIAYoAgAgAUEddmpqQf////8BcTYC3AIgAkHMAWogBxBeIAAgAigC7AEiAUEQdjoAHyAAIAFBCHY6AB4gACABOgAdIAAgAigC6AEiAUEVdjoAHCAAIAFBDXY6ABsgACABQQV2OgAaIAAgAUEDdCACKALkASIBQRp2cjoAGSAAIAFBEnY6ABggACABQQp2OgAXIAAgAUECdjoAFiAAIAFBBnQgAigC4AEiAUEXdnI6ABUgACABQQ92OgAUIAAgAUEHdjoAEyAAIAFBAXQgAigC3AEiAUEcdnI6ABIgACABQRR2OgARIAAgAUEMdjoAECAAIAFBBHY6AA8gACABQQR0IAIoAtgBIgFBGXZyOgAOIAAgAUERdjoADSAAIAFBCXY6AAwgACABQQF2OgALIAAgAUEHdCACKALUASIBQRZ2cjoACiAAIAFBDnY6AAkgACABQQZ2OgAIIAAgAUECdCACKALQASIBQRt2cjoAByAAIAFBE3Y6AAYgACABQQt2OgAFIAAgAUEDdjoABCAAIAFBBXQgAigCzAEiAUEYdnI6AAMgACABQRB2OgACIAAgAUEIdjoAASAAIAE6AAAgAkHgAmokAAv8FAIYfwN+IwBBkAJrIgMkAAJAIAApA5ABIhtC/////////x+DIhxQBEAgAC0AiAEhBSAALQCJASEEDAELIAApA4ABIR0gA0KACCAceoYiHDcDACACrSAbIB19QgqGIBx8IAAtAIgBIgWtQv8BgyAALQCJASIErUL/AYNCBoZ8fVgNACADIBtCCoY3A/ABIANBBDYCFCADQeSVwAA2AhAgA0IDNwIcIAMgA0EMaq1CgICAgBCENwOQASADQoCAgICwASIbIAOthDcDiAEgAyAbIANB8AFqrYQ3A4ABIAMgAjYCDCADIANBgAFqNgIYIANBEGpBhJbAABCmAQALIABBIGohEwJAAkACQAJAAkACQAJAAkACQCAEQf8BcUEGdCAFaiIFRQ0AIBMgAUGACCAFayIFIAIgAiAFSxsiBBBnIQUgAiAEayICRQ0BIANByAFqIg8gAEHoAGoiCCkDADcDACADQdABaiIQIABB8ABqIgspAwA3AwAgA0HYAWoiESAAQfgAaiIMKQMANwMAIANBiAFqIhIgBUEIaikDADcDACADQZABaiIUIAVBEGopAwA3AwAgA0GYAWoiFSAFQRhqKQMANwMAIANBoAFqIhYgBUEgaikDADcDACADQagBaiIXIAVBKGopAwA3AwAgA0GwAWoiGCAFQTBqKQMANwMAIANBuAFqIhkgBUE4aikDADcDACADIAApA2A3A8ABIAMgBSkDADcDgAEgAC0AigEhDSAALQCJASEGIAMgAC0AiAEiCToA6AEgAyAAKQOAASIbNwPgASADIA0gBkVyQQJyIg06AOkBIANBKGoiBiAMKQIANwMAIANBIGoiDCALKQIANwMAIANBGGoiByAIKQIANwMAIAMgACkCYDcDECADQRBqIANBgAFqIhogCSAbIA0QJiAGKAIAIQggDCgCACELIAcoAgAhDCADKAIsIQ0gAygCJCEGIAMoAhwhCSADKAIUIQcgAygCECEKIAAgGxBLIAAoApgBIg5BN0kEQCABIARqIQEgACAOQQV0aiIEQbgBaiANNgIAIARBtAFqIAg2AgAgBEGwAWogBjYCACAEQawBaiALNgIAIARBqAFqIAk2AgAgBEGkAWogDDYCACAEQaABaiAHNgIAIARBnAFqIAo2AgAgACAOQQFqNgKYASASQgA3AwAgFEIANwMAIBVCADcDACAWQgA3AwAgF0IANwMAIBhCADcDACAZQgA3AwAgDyAAQQhqKQMANwMAIBAgAEEQaikDADcDACARIABBGGopAwA3AwAgA0IANwOAASADIAApAwA3A8ABIAApA4ABIRsgBSAaQeAAEN8BGiAAQQA7AYgBIAAgG0IBfDcDgAEMAQsgAyANNgKcASADIAg2ApgBIAMgBjYClAEgAyALNgKQASADIAk2AowBIAMgDDYCiAEgAyAHNgKEASADIAo2AoABDAgLIAJBgQhPBEAgAEGcAWohDSAAKQOAASEbIANB0ABqIQwgA0HAAWohCyADQTBqIQgDQCAbQgqGIRxBfyACQQF2Z3ZBAWohBANAIAQiBUEBdiEEIBwgBUEBa62DQgBSDQALIAVBCnatIRwCQCAFQYEITwRAIAIgBUkNBSAALQCKASEEIANBuAFqIgZCADcDACADQbABaiIJQgA3AwAgA0GoAWoiB0IANwMAIANBoAFqIgpCADcDACADQZgBaiIOQgA3AwAgA0GQAWoiD0IANwMAIANBiAFqIhBCADcDACADQgA3A4ABIAEgBSAAIBsgBCADQYABakHAABAxQQNGDQYgA0HIAGogBikDADcDACADQUBrIAkpAwA3AwAgA0E4aiAHKQMANwMAIAggCikDADcDACADQShqIgkgDikDADcDACADQSBqIgcgDykDADcDACADQRhqIgogECkDADcDACADIAMpA4ABNwMQIAAgACkDgAEQSyAAKAKYASIGQTdPDQcgDSAGQQV0aiIEQRhqIAkpAwA3AAAgBCADKQMQNwAAIARBEGogBykDADcAACAEQQhqIAopAwA3AAAgACAGQQFqNgKYASAAIAApA4ABIBxCAYh8EEsgACgCmAEiBkE3Tw0IIA0gBkEFdGoiBEEYaiAIQRhqKQAANwAAIAQgCCkAADcAACAEQRBqIAhBEGopAAA3AAAgBEEIaiAIQQhqKQAANwAAIAAgBkEBajYCmAEMAQsgA0GIAWpCADcDACADQZABakIANwMAIANBmAFqQgA3AwAgA0GgAWpCADcDACADQagBakIANwMAIANBsAFqQgA3AwAgA0G4AWpCADcDACALIAApAwA3AwAgC0EIaiIGIABBCGopAwA3AwAgC0EQaiIJIABBEGopAwA3AwAgC0EYaiIHIABBGGopAwA3AwAgA0IANwOAASADQQA7AegBIAMgGzcD4AEgAyAALQCKAToA6gEgA0GAAWogASAFEGchBCAMIAspAwA3AwAgDEEIaiAGKQMANwMAIAxBEGogCSkDADcDACAMQRhqIAcpAwA3AwAgA0EYaiAEQQhqKQMANwMAIANBIGogBEEQaikDADcDACADQShqIARBGGopAwA3AwAgCCAEQSBqKQMANwMAIANBOGogBEEoaikDADcDACADQUBrIARBMGopAwA3AwAgA0HIAGogBEE4aikDADcDACADIAQpAwA3AxAgAy0A6gEhBCADLQDpASEKIAMgAy0A6AEiDjoAeCADIAMpA+ABIhs3A3AgAyAEIApFckECciIEOgB5IANBiAJqIgogBykCADcDACADQYACaiIHIAkpAgA3AwAgA0H4AWoiDyAGKQIANwMAIAMgCykCADcD8AEgA0HwAWogA0EQaiAOIBsgBBAmIAooAgAhBiAHKAIAIQkgDygCACEHIAMoAowCIQogAygChAIhDiADKAL8ASEPIAMoAvQBIRAgAygC8AEhESAAIAApA4ABEEsgACgCmAEiEkE3Tw0IIA0gEkEFdGoiBCAKNgIcIAQgBjYCGCAEIA42AhQgBCAJNgIQIAQgDzYCDCAEIAc2AgggBCAQNgIEIAQgETYCACAAIBJBAWo2ApgBCyAAIAApA4ABIBx8Ihs3A4ABIAIgBUkNCCABIAVqIQEgAiAFayICQYAISw0ACwsgAkUNACATIAEgAhBnGiAAIAApA4ABEEsLIANBkAJqJAAgAA8LIAUgAkGUlsAAEJgBAAtB4ABBwABB7JTAABCYAQALIANBmAFqIANBKGopAwA3AwAgA0GQAWogA0EgaikDADcDACADQYgBaiADQRhqKQMANwMAIAMgAykDEDcDgAEMAwsgA0GYAWogCEEYaikAADcDACADQZABaiAIQRBqKQAANwMAIANBiAFqIAhBCGopAAA3AwAgAyAIKQAANwOAAQwCCyADIAo2AowCIAMgBjYCiAIgAyAONgKEAiADIAk2AoACIAMgDzYC/AEgAyAHNgL4ASADIBA2AvQBIAMgETYC8AFBpJLAAEErIANB8AFqQdCSwABBnJXAABCUAQALIAUgAkGklsAAEJcBAAtBpJLAAEErIANBgAFqQdCSwABBnJXAABCUAQALkBQCGn8ofiMAQYABayICJAAgAkEwaiIDIAEQViACKQNIIR0gAikDQCEiIAIpAzghKSACKQMwIRwgAikDeCEfIAIpA3AhJSACKQNoISYgAikDYCEoIAIpA1ghJyACKQNQIR4gAyABQShqEFYgAikDSCEqIAIpA0AhKyACKQM4ITEgAikDMCEgIAIpA3ghLCACKQNwIS0gAikDaCEuIAIpA2AhLyACKQNYITAgAikDUCEjIAMgAUHQAGoQViACKQN4ITIgAikDcCEzIAIpA2ghNCACKQNgITUgAikDSCE2IAIpA0AhNyACKQMwITggAikDOCE5IAIpA1AhOiACKQNYITsgASgCKCEEIAEoAgAhCyABKAIsIQUgASgCBCEGIAEoAjAhDCABKAIIIQcgASgCNCEIIAEoAgwhDSABKAI4IQkgASgCECEKIAEoAjwhDiABKAIUIQ8gASgCQCEQIAEoAhghESABKAJEIRIgASgCHCETIAEoAkghFCABKAIgIRUgAiABKAJMIAEoAiRqNgIsIAIgFCAVajYCKCACIBIgE2o2AiQgAiAQIBFqNgIgIAIgDiAPajYCHCACIAkgCmo2AhggAiAIIA1qNgIUIAIgByAMajYCECACIAUgBmo2AgwgAiAEIAtqNgIIIAMgAkEIahBWIAIpA3ghPCACKQNwIT0gAikDaCE+IAIpA2AhPyACKQNYIUAgAikDSCFBIAIpA0AhQiACKQM4IUMgAikDMCEkIAIpA1AhISAAICwgLSAuIC8gMCAjQhqIfCIwQhmIfCIvQhqIfCIuQhmIfCItQhqIfCIsp0H///8PcSIBIB8gJSAmICggJyAeQhqIfCInQhmIfCIoQhqIfCImQhmIfCIlQhqIfCIfp0H///8PcSIEaiILNgJMIAAgLadB////H3EiBSAlp0H///8fcSIGaiIMNgJIIAAgLqdB////D3EiByAmp0H///8PcSIIaiINNgJEIAAgL6dB////H3EiCSAop0H///8fcSIKaiIONgJAIAAgMEL///8PgyAjQv///x+DICogKyAxICBCGoh8IiNCGYh8IiVCGoh8IiZCGYh8IihCGoh8IiqnICdC////D4MgHkL///8fgyAdICIgKSAcQhqIfCIeQhmIfCIiQhqIfCIdQhmIfCIpQhqIfCInp2oiDzYCPCAAICinQf///x9xIhAgKadB////H3EiEWoiEjYCOCAAICanQf///w9xIhMgHadB////D3EiFGoiFTYCNCAAICWnQf///x9xIgMgIqdB////H3EiFmoiFzYCMCAAICxCGYhCE34gIEL///8fg3wiIKdB////H3EiGCAfQhmIQhN+IBxC////H4N8IhynQf///x9xIhlqIho2AiggACAjQv///w+DICBCGoh8IiCnIB5C////D4MgHEIaiHwiHKdqIhs2AiwgACAJIAprQfD///8Daq0gKiAnfSAQIBFrQfD///8Daq0iHkIaiHxC8P///wF8IiNCGYh8Ih2nQf///x9xIgk2AmggACAHIAhrQfD///8Baq0gHUIaiHwiHadB////D3EiBzYCbCAAIAUgBmtB8P///wNqrSAdQhmIfCIdp0H///8fcSIFNgJwIAAgAyAWa0Hw////A2qtICAgHH0gGCAZa0HQ/f//A2qtIhxCGoh8QvD///8BfCIgQhmIfCIip0H///8fcSIGNgJYIAAgASAEa0Hw////AWqtIB1CGoh8Ih2nQf///w9xIgE2AnQgACATIBRrQfD///8Baq0gIkIaiHwiIqdB////D3EiBDYCXCAAICNC////D4MgHkL///8fgyAiQhmIfCIeQhqIfCIjPgJkIAAgHqdB////H3EiCDYCYCAAICBC////D4MgHUIZiEITfiAcQv///x+DfCIcQhqIfCIePgJUIAAgHKdB////H3EiCjYCUCAAICFC////H4MgQSBCIEMgJEIaiHwiHEIZiHwiIEIaiHwiHUIZiHwiIqdB////H3EgEmtB8P///wNqrSIpQhqIIEAgIUIaiHwiIUL///8PgyAiQhqIfKcgD2tB8P///wFqrXwiIkIZiCA/ICFCGYh8IiGnQf///x9xIA5rQfD///8Daq18Ih+nQf///x9xNgIYIAAgPiAhQhqIfCIhp0H///8PcSANa0Hw////AWqtIB9CGoh8Ih+nQf///w9xNgIcIAAgPSAhQhmIfCIhp0H///8fcSAMa0Hw////A2qtIB9CGYh8Ih+nQf///x9xNgIgIAAgIKdB////H3EgF2tB8P///wNqrSA8ICFCGoh8IiBCGYhCE34gJEL///8fg3wiJKdB////H3EgGmtB0P3//wNqrSIhQhqIIBxC////D4MgJEIaiHynIBtrQfD///8Baq18IhxCGYh8IiSnQf///x9xNgIIIAAgIKdB////D3EgC2tB8P///wFqrSAfQhqIfCIgp0H///8PcTYCJCAAIB2nQf///w9xIBVrQfD///8Baq0gJEIaiHwiJKdB////D3E2AgwgACA7QgGGIDpCAYYiHUIaiHwiH0L///8PgyAdQv7//x+DIDZCAYYgN0IBhiA5QgGGIDhCAYYiHUIaiHwiJUIZiHwiJkIaiHwiKEIZiHwiJ0IaiHwgI30gJ6dB////H3EgCGtB8P///wNqrSIjQhqIfELw////AXwiJ0IZiCA1QgGGIB9CGYh8Ih+nQf///x9xIAlrQfD///8Daq18IiqnQf///x9xNgKQASAAICanQf///x9xIAZrQfD///8Daq0gJUL///8PgyAefSAyQgGGIDNCAYYgNEIBhiAfQhqIfCIeQhmIfCIfQhqIfCIlQhmIQhN+IB1C/v//H4N8Ih1CGoh8IB2nQf///x9xIAprQdD9//8Daq0iHUIaiHxC8P///wF8IiZCGYh8IiunQf///x9xNgKAASAAICJC////D4MgKUL///8fgyAkQhmIfCIkQhqIfD4CFCAAICSnQf///x9xNgIQIAAgHEL///8PgyAgQhmIQhN+ICFC////H4N8IhxCGoh8PgIEIAAgHKdB////H3E2AgAgACAep0H///8PcSAHa0Hw////AWqtICpCGoh8IhynQf///w9xNgKUASAAICinQf///w9xIARrQfD///8Baq0gK0IaiHwiHqdB////D3E2AoQBIAAgH6dB////H3EgBWtB8P///wNqrSAcQhmIfCIcp0H///8fcTYCmAEgACAnQv///w+DICNC////H4MgHkIZiHwiHkIaiHw+AowBIAAgHqdB////H3E2AogBIAAgJadB////D3EgAWtB8P///wFqrSAcQhqIfCIcp0H///8PcTYCnAEgACAmQv///w+DIBxCGYhCE34gHUL///8fg3wiHEIaiHw+AnwgACAcp0H///8fcTYCeCACQYABaiQAC8UOAgl/AX4jAEGgAWsiAyQAIANBkAFqIAEgAhBUAkACQAJAAkACQAJAAkACQAJAIAMoApABRQRAQQ4hBQJAIAMoApgBIgRBDk8EQEHBi8AAIAMoApQBIgZBDhDcAUUNAQtBCCEEQcGLwAAhBkGsjMAAIQkMBQsgA0GHisAANgJgIAMgBEEOazYCXCADIAZBDmo2AlggA0EQaiADQdgAaiIEEEQCQCADKAIQIghBgICAgHhHBEAgAygCFCEHIAMoAhhBIEYNASADQQA2AhQgA0HoAGogA0EkaigCADYCACADQeAAaiADQRxqKQIANwMAIAMgAykCFDcDWCADQYABaiAEEEkCQCADKAJYIgRBCE1BAEEBIAR0Qc8DcRsNACADKAJcIgRFDQAgAygCYCAEEJwBC0EFIQQgAygCiAEhCSADKAKEASEFIAMoAoABIQYgCEUNBiAHQQRrKAIAIgpBeHEiC0EEQQggCkEDcSIKGyAIakkNCiAKQQAgCyAIQSdqSxsNCyAHEEUMBgsgAykCFCEMIANBADYCYCADQoCAgIAQNwJYIAynIAxCIIinIANB2ABqEIQBDQIgAygCYCEJIAMoAlwhBSADKAJYIQZBCSEEDAULIAdBAmotAAAhBCAHKAADIQUgBy8AACEGIANB9wBqIAdBH2otAAA6AAAgA0HaAGogBDoAACADIAcpABc3AG8gA0HnAGogB0EPaikAADcAACADIAY7AVggAyAFNgBbIAMgBykABzcAXyADQRBqIglBAXIgA0HYAGoiBBBGIAQQjAEgA0GIAWogA0EgaigCACIENgIAIANB3gBqIAMtABM6AAAgA0H7AGogA0Ewai0AADoAACADQesAaiAENgAAIAMgAykCGCIMNwOAASADIAMvABE7AVwgAyADKQIoNwBzIAMgDDcAYyADKAIUIQQgAyADKAIkNgBvIAMgBDYAXyADQYeKwAA2AlggA0EANgKYASADQoCAgIAQNwKQASADQZABakEAQTAQjQEgAygClAEiBCADKAKYASIGaiIFQgA3AAAgBUEIakIANwAAIAVBEGpCADcAACAFQRhqQgA3AAAgBUEgakIANwAAIAVBKGpCADcAACADQQhqIANB3ABqQSAgBCAGQTBqIgYQUCADKAIIRQRAIAMoApABIQUgCSAEIAYgAygCDCIJIAYgCUkbIgYQVCADKAIQRQRAIAatIQwgBCEGDAULIAMpAhQhDCAFQYCAgIB4Rw0DIAQhBQwECyADKAKQASIABEAgBCAAEJwBC0GkksAAQSsgA0GfAWpB6ITAAEH4hMAAEJQBAAsgAyADKQKUATcDSCADQQE2AlwgA0H0jcAANgJYIANCATcCZCADIANByABqrUKAgICA0AGENwOAASADIANBgAFqNgJgIANBEGogA0HYAGoQayADKAIQIQUgAygCFCIGIAMoAhgQACEEIAVFDQQgBkEEaygCACIHQXhxIghBBEEIIAdBA3EiBxsgBWpJDQcgB0EAIAggBUEnaksbDQggBhBFDAQLQYSawABBNyADQZ8BakG8g8AAQZibwAAQlAEACyADIAw3AhwgAyAFNgIQIAMgBK0gBq1CIIaENwIUQaSSwABBKyADQRBqQfCFwABBgIbAABCUAQALIAMgDD4CUCADIAY2AkwgAyAFNgJIIANBATYCFCADQbyMwAA2AhAgA0IBNwIcIAMgA0HIAGqtQoCAgIDgAYQ3A0AgAyADQUBrNgIYIANBNGogA0EQahBrIAMoAkgiBARAIAMoAkwgBBCcAQsgAygCPCEFIAMoAjghBCADKAI0IQYgCEUNAiAHIAgQnAEMAgsgA0ENNgJoIAMgCTYCZCADIAU2AmAgAyAGNgJcIAMgBDYCWCADQRBqIANB2ABq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AAggBSAHKQMANwAACyABQf8HcSIMRQ0GIAdBuAFqQgA3AwAgB0GwAWpCADcDACAHQagBakIANwMAIAdBoAFqQgA3AwAgB0GYAWpCADcDACAHQZABakIANwMAIAdBiAFqQgA3AwAgB0HIAWoiCCACQQhqKQIANwMAIAdB0AFqIgogAkEQaikCADcDACAHQdgBaiILIAJBGGopAgA3AwAgB0IANwOAASAHIAQ6AOoBIAdBADsB6AEgByACKQIANwPAASAHIAmtIAN8NwPgASAHQYABaiAAIAFBgAhxaiAMEGchACAHQcgAaiAIKQMANwMAIAdB0ABqIAopAwA3AwAgB0HYAGogCykDADcDACAHQQhqIABBCGopAwA3AwAgB0EQaiAAQRBqKQMANwMAIAdBGGogAEEYaikDADcDACAHQSBqIABBIGopAwA3AwAgB0EoaiAAQShqKQMANwMAIAdBMGogAEEwaikDADcDACAHQThqIABBOGopAwA3AwAgByAHKQPAATcDQCAHIAApAwA3AwAgBy0A6gEhACAHLQDpASEBIAcgBy0A6AEiAjoAaCAHIAcpA+ABIgM3A2AgByAAIAFFckECciIAOgBpIAdBiAJqIgEgCykDADcDACAHQYACaiIEIAopAwA3AwAgB0H4AWoiCiAIKQMANwMAIAcgBykDwAE3A/ABIAdB8AFqIAcgAiADIAAQJiAJQQV0IgBBIGoiAiAGSw0BIAEoAgAhASAEKAIAIQIgCigCACEEIAcoAoQCIQYgBygC/AEhCCAHKAL0ASEKIAcoAvABIQsgACAFaiIAIAcoAowCNgAcIAAgATYAGCAAIAY2ABQgACACNgAQIAAgCDYADCAAIAQ2AAggACAKNgAEIAAgCzYAACAJQQFqIQkMBgtCfyABrUIBfEIBiEIBfXmIpyIIIAFPDQEgACAIQQFqIgkgAiADIAQgB0GAARDeASIIQSBBwAAgCUGACEYbIgoQMSELIAAgCWogASAJayACIAlBCnatIAN8IAQgCCAKakGAASAKaxAxIAtBAUYEQCAGQT9NDQMgBSAIKQAANwAAIAVBOGogCEE4aikAADcAACAFQTBqIAhBMGopAAA3AAAgBUEoaiAIQShqKQAANwAAIAVBIGogCEEgaikAADcAACAFQRhqIAhBGGopAAA3AAAgBUEQaiAIQRBqKQAA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AAshCyAGBEAgBUEEaygCACIJQXhxIgxBBEEIIAlBA3EiCRsgBmpJDQEgCUEAIAwgBkEnaksbDQIgBRBFCyAEBEAgA0EEaygCACIFQXhxIgZBBEEIIAVBA3EiBRsgBGpJDQEgBUEAIAYgBEEnaksbDQIgAxBFCyACBEAgAUEEaygCACIDQXhxIgRBBEEIIANBA3EiAxsgAmpJDQEgA0EAIAQgAkEnaksbDQIgARBFCyAAIAo2AgggACAIQf8BcSANIAsbIgFBACAKGzYCBCAAQQAgASAKGzYCACAHQdAAaiQADwtBrfXCAEEuQdz1wgAQowEAC0Hs9cIAQS5BnPbCABCjAQALQYSawABBNyAHQSRqQbyDwABBmJvAABCUAQAL8xACEn8EfiMAQeABayICJAACQAJAAkACQAJAAkAgASkDkAFQBEAgASgCmAEiA0UEQCACQcgAaiABQegAaikDADcDACACQdAAaiABQfAAaikDADcDACACQdgAaiABQfgAaikDADcDACACQQhqIAFBKGopAwA3AwAgAkEQaiABQTBqKQMANwMAIAJBGGogAUE4aikDADcDACACQSBqIAFBQGspAwA3AwAgAkEoaiABQcgAaikDADcDACACQTBqIAFB0ABqKQMANwMAIAJBOGogAUHYAGopAwA3AwAgAiABKQNgNwNAIAIgASkDIDcDACABLQCKASEFIAEtAIkBIQQgAiABLQCIASIDOgBoIAIgASkDgAE3A2AgAiAFIARFckECciIBOgBpDAYLQQAgAS0AiAEiCGsgAS0AiQEiBEEGdEcNASADQQJrIQUgA0EBRg0CIAEtAIoBIQcgAkGIAWoiCSABQZwBaiIGIAVBBXRqIgRBGGopAAA3AwAgAkGAAWoiCCAEQRBqKQAANwMAIAJB+ABqIgogBEEIaikAADcDACACQZABaiILIANBBXQgBmpBIGsiBikAADcDACACQZgBaiIMIAZBCGopAAA3AwAgAkGgAWoiDSAGQRBqKQAANwMAIAJBqAFqIg4gBkEYaikAADcDACACIAQpAAA3A3AgAkHYAGogAUEYaikDADcDACACQdAAaiABQRBqKQMANwMAIAJByABqIAFBCGopAwA3AwAgAiABKQMANwNAIAJBOGogDikDADcDACACQTBqIA0pAwA3AwAgAkEoaiAMKQMANwMAIAJB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HYh8IgOnQf////8BcTYCGCAnIARCFIYgDnwgA0IdiHwiA6dB/////wFxNgIcICcgBkIUhiAjfCADQh2IfCIDp0H/////AXE2AiAgJyAHQhSGIA18IANCHYh8IgOnQf////8BcTYCJCAnIAhCFIYgC3wgA0IdiHwiA0IdiD4CLCAnIAOnQf////8BcTYCKCAAICdBDGoQXiAnQTBqJAALhwwCBn8GfiMAQaAGayICJAAgAkHQBWoiBSABEFYgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCGCACIAIpA+AFIAIpA9gFIAIpA9AFIgxCGoh8Ig1CGYh8IgqnQf///x9xNgIIIAIgAikDiAYgCUIaiHwiCadB////D3E2AhwgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCDCACIAIpA5AGIAlCGYh8IgmnQf///x9xNgIgIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgIUIAIgCKdB////H3E2AhAgAiACKQOYBiAJQhqIfCIIp0H///8PcTYCJCACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CBCACIAinQf///x9xNgIAIAUgAhBWIAIgAikDgAYgAikD+AUgAikD8AUiCEIaiHwiC0IZiHwiCadB////H3E2AsAFIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2ArAFIAIgAikDiAYgCUIaiHwiCadB////D3E2AsQFIAIgAikD6AUgCkIaiHwiCqdB////D3E2ArQFIAIgAikDkAYgCUIZiHwiCadB////H3E2AsgFIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgK8BSACIAinQf///x9xNgK4BSACIAIpA5gGIAlCGoh8IginQf///w9xNgLMBSACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CrAUgAiAIp0H///8fcTYCqAUgBSACQagFaiIGEFYgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCQCACIAIpA+AFIAIpA9gFIAIpA9AFIgxCGoh8Ig1CGYh8IgqnQf///x9xNgIwIAIgAikDiAYgCUIaiHwiCadB////D3E2AkQgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCNCACIAIpA5AGIAlCGYh8IgmnQf///x9xNgJIIAIgC0L///8PgyAIQv///x+DIApCGYh8IghCGoh8PgI8IAIgCKdB////H3E2AjggAiACKQOYBiAJQhqIfCIIp0H///8PcTYCTCACIA1C////D4MgCEIZiEITfiAMQv///x+DfCIIQhqIfD4CLCACIAinQf///x9xNgIoIAJB0ABqIgQgASACQShqEEEgAkH4AGoiASACIAQQQSAFIAEQViACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgK4ASACIAIpA+AFIAIpA9gFIAIpA9AFIgxCGoh8Ig1CGYh8IgqnQf///x9xNgKoASACIAIpA4gGIAlCGoh8IgmnQf///w9xNgK8ASACIAIpA+gFIApCGoh8IgqnQf///w9xNgKsASACIAIpA5AGIAlCGYh8IgmnQf///x9xNgLAASACIAtC////D4MgCEL///8fgyAKQhmIfCIIQhqIfD4CtAEgAiAIp0H///8fcTYCsAEgAiACKQOYBiAJQhqIfCIIp0H///8PcTYCxAEgAiANQv///w+DIAhCGYhCE34gDEL///8fg3wiCEIaiHw+AqQBIAIgCKdB////H3E2AqABIAJByAFqIgMgBCACQaABahBBIAJB8AFqIgQgA0EFEFUgAkGYAmoiASAEIAMQQSACQcACaiIDIAFBChBVIAJB6AJqIgQgAyABEEEgAkGQA2oiAyAEQRQQVSACQbgDaiIHIAMgBBBBIAJB4ANqIgMgB0EKEFUgAkGIBGoiBCADIAEQQSACQbAEaiIDIARBMhBVIAJB2ARqIgEgAyAEEEEgAkGABWoiAyABQeQAEFUgBiADIAEQQSAFIAZBMhBVIAAgBSAEEEEgAEHIAGogAkGYAWopAgA3AgAgAEFAayACQZABaikCADcCACAAQThqIAJBiAFqKQIANwIAIABBMGogAkGAAWopAgA3AgAgACACKQJ4NwIoIAJBoAZqJAAL0wwCJ38MfiMAQfABayIDJAAgASgCACEEIAEoAighBSABKAIEIQYgASgCLCEHIAEoAgghCCABKAIwIQkgASgCDCEKIAEoAjQhCyABKAIQIQwgASgCOCENIAEoAhQhDiABKAI8IQ8gASgCGCEQIAEoAkAhESABKAIcIRIgASgCRCETIAEoAiAhFCABKAJIIRUgAyABKAIkIAEoAkxqNgIkIAMgFCAVajYCICADIBIgE2o2AhwgAyAQIBFqNgIYIAMgDiAPajYCFCADIAwgDWo2AhAgAyAKIAtqNgIMIAMgCCAJajYCCCADIAYgB2o2AgQgAyAEIAVqNgIAIANBKGoiBCABQShqIAEQYSADQdAAaiADIAIQQSADQfgAaiAEIAJBKGoQQSADQaABaiABQfgAaiACQfgAahBBIANByAFqIAFB0ABqIAJB0ABqEEEgAygCoAEhASADKALIASEWIAMoAqQBIQIgAygCzAEhFyADKAKoASEEIAMoAtABIRggAygCrAEhBSADKALUASEZIAMoArABIQYgAygC2AEhGiADKAK0ASEHIAMoAtwBIRsgAygCuAEhCCADKALgASEcIAMoArwBIQkgAygC5AEhHSADKALAASEKIAMoAugBIR4gAygCxAEhCyADKALsASEfIAMoAnghDCADKAJQIQ0gAygCfCEOIAMoAlQhDyADKAKAASEQIAMoAlghESADKAKEASESIAMoAlwhEyADKAKIASEUIAMoAmAhFSADKAKMASEgIAMoAmQhISADKAKQASEiIAMoAmghIyADKAKUASEkIAMoAmwhJSADKAKYASEmIAMoAnAhJyAAIAMoApwBIiggAygCdCIpajYCTCAAICYgJ2o2AkggACAkICVqNgJEIAAgIiAjajYCQCAAICAgIWo2AjwgACAUIBVqNgI4IAAgEiATajYCNCAAIBAgEWo2AjAgACAOIA9qNgIsIAAgDCANajYCKCAAIAsgH0EBdCIfajYCdCAAIAogHkEBdCIeajYCcCAAIAkgHUEBdCIdajYCbCAAIAggHEEBdCIcajYCaCAAIAcgG0EBdCIbajYCZCAAIAYgGkEBdCIaajYCYCAAIAUgGUEBdCIZajYCXCAAIAQgGEEBdCIYajYCWCAAIAIgF0EBdCIXajYCVCAAIAEgFkEBdCIWajYCUCAAICMgImtB8P///wNqrSAhICBrQfD///8Baq0gFSAUa0Hw////A2qtIipCGoh8IitCGYh8IiynQf///x9xNgIYIAAgESAQa0Hw////A2qtIA8gDmtB8P///wFqrSANIAxrQdD9//8Daq0iMEIaiHwiMUIZiHwiLadB////H3E2AgggACAcIAhrQfD///8Daq0gGyAHa0Hw////AWqtIBogBmtB8P///wNqrSIyQhqIfCIzQhmIfCIup0H///8fcTYCkAEgACAYIARrQfD///8Daq0gFyACa0Hw////AWqtIBYgAWtB0P3//wNqrSI0QhqIfCI1QhmIfCIvp0H///8fcTYCgAEgACAlICRrQfD///8Baq0gLEIaiHwiLKdB////D3E2AhwgACATIBJrQfD///8Baq0gLUIaiHwiLadB////D3E2AgwgACAdIAlrQfD///8Baq0gLkIaiHwiLqdB////D3E2ApQBIAAgGSAFa0Hw////AWqtIC9CGoh8Ii+nQf///w9xNgKEASAAICcgJmtB8P///wNqrSAsQhmIfCIsp0H///8fcTYCICAAICtC////D4MgKkL///8fgyAtQhmIfCIqQhqIfD4CFCAAICqnQf///x9xNgIQIAAgHiAKa0Hw////A2qtIC5CGYh8IiqnQf///x9xNgKYASAAIDNC////D4MgMkL///8fgyAvQhmIfCIrQhqIfD4CjAEgACArp0H///8fcTYCiAEgACApIChrQfD///8Baq0gLEIaiHwiK6dB////D3E2AiQgACAfIAtrQfD///8Baq0gKkIaiHwiKqdB////D3E2ApwBIAAgMUL///8PgyArQhmIQhN+IDBC////H4N8IitCGoh8PgIEIAAgK6dB////H3E2AgAgACA1Qv///w+DICpCGYhCE34gNEL///8fg3wiKkIaiHw+AnwgACAqp0H///8fcTYCeCADQfABaiQAC7oMAid/DH4jAEHQAWsiAyQAIAEoAgAhBCABKAIoIQUgASgCBCEGIAEoAiwhByABKAIIIQggASgCMCEJIAEoAgwhCiABKAI0IQsgASgCECEMIAEoAjghDSABKAIUIQ4gASgCPCEPIAEoAhghECABKAJAIREgASgCHCESIAEoAkQhEyABKAIgIRQgASgCSCEVIAMgASgCJCABKAJMajYCLCADIBQgFWo2AiggAyASIBNqNgIkIAMgECARajYCICADIA4gD2o2AhwgAyAMIA1qNgIYIAMgCiALajYCFCADIAggCWo2AhAgAyAGIAdqNgIMIAMgBCAFajYCCCADQTBqIgQgAUEoaiABEGEgA0HYAGogA0EIaiACEEEgA0GAAWogBCACQShqEEEgA0GoAWogAUH4AGogAkHQAGoQQSABKAJQIRYgASgCVCEXIAEoAlghGCABKAJcIRkgASgCYCEaIAEoAmQhGyABKAJoIRwgASgCbCEdIAEoAnAhHiABKAJ0IR8gAygCqAEhASADKAKsASECIAMoArABIQQgAygCtAEhBSADKAK4ASEGIAMoArwBIQcgAygCwAEhCCADKALEASEJIAMoAsgBIQogAygCzAEhCyADKAKAASEMIAMoAlghDSADKAKEASEOIAMoAlwhDyADKAKIASEQIAMoAmAhESADKAKMASESIAMoAmQhEyADKAKQASEUIAMoAmghFSADKAKUASEgIAMoAmwhISADKAKYASEiIAMoAnAhIyADKAKcASEkIAMoAnQhJSADKAKgASEmIAMoAnghJyAAIAMoAqQBIiggAygCfCIpajYCTCAAICYgJ2o2AkggACAkICVqNgJEIAAgIiAjajYCQCAAICAgIWo2AjwgACAUIBVqNgI4IAAgEiATajYCNCAAIBAgEWo2AjAgACAOIA9qNgIsIAAgDCANajYCKCAAIAsgH0EBdCIfajYCdCAAIAogHkEBdCIeajYCcCAAIAkgHUEBdCIdajYCbCAAIAggHEEBdCIcajYCaCAAIAcgG0EBdCIbajYCZCAAIAYgGkEBdCIaajYCYCAAIAUgGUEBdCIZajYCXCAAIAQgGEEBdCIYajYCWCAAIAIgF0EBdCIXajYCVCAAIAEgFkEBdCIWajYCUCAAICMgImtB8P///wNqrSAhICBrQfD///8Baq0gFSAUa0Hw////A2qtIipCGoh8IitCGYh8IiynQf///x9xNgIYIAAgESAQa0Hw////A2qtIA8gDmtB8P///wFqrSANIAxrQdD9//8Daq0iMEIaiHwiMUIZiHwiLadB////H3E2AgggACAcIAhrQfD///8Daq0gGyAHa0Hw////AWqtIBogBmtB8P///wNqrSIyQhqIfCIzQhmIfCIup0H///8fcTYCkAEgACAYIARrQfD///8Daq0gFyACa0Hw////AWqtIBYgAWtB0P3//wNqrSI0QhqIfCI1QhmIfCIvp0H///8fcTYCgAEgACAlICRrQfD///8Baq0gLEIaiHwiLKdB////D3E2AhwgACATIBJrQfD///8Baq0gLUIaiHwiLadB////D3E2AgwgACAdIAlrQfD///8Baq0gLkIaiHwiLqdB////D3E2ApQBIAAgGSAFa0Hw////AWqtIC9CGoh8Ii+nQf///w9xNgKEASAAICcgJmtB8P///wNqrSAsQhmIfCIsp0H///8fcTYCICAAICtC////D4MgKkL///8fgyAtQhmIfCIqQhqIfD4CFCAAICqnQf///x9xNgIQIAAgHiAKa0Hw////A2qtIC5CGYh8IiqnQf///x9xNgKYASAAIDNC////D4MgMkL///8fgyAvQhmIfCIrQhqIfD4CjAEgACArp0H///8fcTYCiAEgACApIChrQfD///8Baq0gLEIaiHwiK6dB////D3E2AiQgACAfIAtrQfD///8Baq0gKkIaiHwiKqdB////D3E2ApwBIAAgMUL///8PgyArQhmIQhN+IDBC////H4N8IitCGoh8PgIEIAAgK6dB////H3E2AgAgACA1Qv///w+DICpCGYhCE34gNEL///8fg3wiKkIaiHw+AnwgACAqp0H///8fcTYCeCADQdABaiQAC9ILAgp+BH8jAEGwA2siDCQAIAxBqAJqQYEBEN4BGiAMQaACakIANwMAIAxBkAJqQbDqwgApAwA3AwAgDEGIAmpBqOrCACkDADcDACAMQYACakGg6sIAKQMANwMAIAxB+AFqQZjqwgApAwA3AwAgDEHwAWpBkOrCACkDADcDACAMQegBakGI6sIAKQMANwMAIAxB4AFqQYDqwgApAwA3AwAgDEGwAmogAUEIaikAADcDACAMQbgCaiABQRBqKQAANwMAIAxBwAJqIAFBGGopAAA3AwAgDEIANwOYAiAMQfjpwgApAwA3A9gBIAwgASkAADcDqAIgDEEgOgCoAyAMIAxB2AFqQdgBEN8BIgFB0ABqIg4gAS0A0AEiDGoiDUGAAToAACABQcgAaikDACICQgKGQoCAgPgPgyACQg6IQoCA/AeDhCACQh6IQoD+A4MgAkIKhiIDQjiIhIQhBiABKQNAIgJCNogiBEI4hiADIASEIgNCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIAJCAoZCgICA+A+DIAJCDohCgID8B4OEIAJCHohCgP4DgyACQgqGIgJCOIiEhCEEIAytIgVCO4YgAiAFQgOGhCICQoD+A4NCKIaEIAJCgID8B4NCGIYgAkKAgID4D4NCCIaEhCEFAkAgDEH/AHMiD0UNACANQQFqIg1FDQAgDSAPEN4BGgsgBoQhAiAEIAWEIQMCQCAMQfAAc0EQTwRAIAFByAFqIAM3AwAgASACNwPAASABIA5BARAjDAELIAEgDkEBECMgAUHYAWoiDEHwABDeARogAUHQAmogAzcAACABIAI3AMgCIAEgDEEBECMLIAEpAyAhAyABKQMoIQYgASkDMCEEIAEpAzghBSABKQMIIQcgASkDECEIIAEpAwAhAiABQfYBaiABKQMYIglCCIgiCjwAACABQd8BaiACPAAAIAFB9AFqIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEQiCIPQAAIAFB3QFqIAJCOIYgAkKA/gODQiiGhCACQoCA/AeDQhiGIAJCgICA+A+DQgiGhIQiC0IoiD0AACABIAJCOIinQfgBcToA2AEgASAKQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgCUI4iISEPgDwASABIAlC/wGDp0E/cUHAAHI6APcBIAEgCEI4hiAIQoD+A4NCKIaEIAhCgID8B4NCGIYgCEKAgID4D4NCCIaEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhDcA6AEgASAHQjiGIAdCgP4Dg0IohoQgB0KAgPwHg0IYhiAHQoCAgPgPg0IIhoSEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwDgASABIAsgAkIoiEKA/gODIAJCCIhCgICA+A+DIAJCGIhCgID8B4OEhIRCCIg+ANkBIAAgAUHYAWoQMiAAIAVCOIYgBUKA/gODQiiGhCAFQoCA/AeDQhiGIAVCgICA+A+DQgiGhIQgBUIIiEKAgID4D4MgBUIYiEKAgPwHg4QgBUIoiEKA/gODIAVCOIiEhIQ3ADggACAEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISENwAwIAAgBkI4hiAGQoD+A4NCKIaEIAZCgID8B4NCGIYgBkKAgID4D4NCCIaEhCAGQgiIQoCAgPgPgyAGQhiIQoCA/AeDhCAGQiiIQoD+A4MgBkI4iISEhDcAKCAAIANCOIYgA0KA/gODQiiGhCADQoCA/AeDQhiGIANCgICA+A+DQgiGhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIQ3ACAgAUGwA2okAAunCQIJfwN+IwBB4A9rIgckAAJAAkACQAJAIARBC0kNAEH8icAAIANBCxDcAQ0AIAdBh4rAADYCCCAHIARBC2s2AgQgByADQQtqNgIAIAdBgA9qIgggBxBEIAcoAoAPIglBgICAgHhGDQAgBygCiA8hDSAHKAKEDyEKIAdBuA9qQgA3AwAgB0GwD2pCADcDACAHQagPakIANwMAIAdBoA9qQgA3AwAgB0GYD2pCADcDACAHQZAPaiILQgA3AwAgB0GID2oiDEIANwMAIAdByA9qQcyMwAApAgAiEDcDACAHQdAPakHUjMAAKQIAIhE3AwAgB0HYD2pB3IzAACkCACISNwMAIAdBCGogEDcDACAHQRBqIBE3AwAgB0EYaiASNwMAIAdCADcDgA8gB0HEjMAAKQIAIhA3A8APIAcgEDcDACAHQSBqIAhB4AAQ3wEaIAdBhwFqQQA2AAAgB0IANwOAASAHQQA2ApgBIAdCADcDkAEgCCAHIAUgBhAtEDVB0YDDAC0AABoCQEEYECciCARAIAggBykAgA83AAAgCEEQaiALKQAANwAAIAhBCGogDCkAADcAACAHIAogDSAIIAEgAhAoIAcoAgghDSAHKAIEIQsgBygCACIMQQpGBEAgCEEEaygCACIMQXhxIg5BHEEgIAxBA3EiDBtJDQUgDEEAIA5BwABPGw0GIAgQRSAJRQ0EIApBBGsoAgAiCEF4cSIMQQRBCCAIQQNxIggbIAlqSQ0FIAhBACAMIAlBJ2pLGw0GIAoQRQwECyAIQQRrKAIAIg5BeHEiD0EcQSAgDkEDcSIOG0kNBCAHKQIMIRAgDkEAIA9BwABPGw0FIAgQRSAJRQ0CIApBBGsoAgAiCEF4cSIOQQRBCCAIQQNxIggbIAlqSQ0EIAhBACAOIAlBJ2pLGw0BIAoQRQwCCwALDAMLIAcgEDcCDCAHIA02AgggByALNgIEIAcgDDYCACAHQYAPaiAHEEkgBygChA8iCCAHKAKIDxAAIQ0gBygCgA8iCQRAIAhBBGsoAgAiCkF4cSILQQRBCCAKQQNxIgobIAlqSQ0CIApBACALIAlBJ2pLGw0DIAgQRQsCQCAHKAIAIghBCE1BAEEBIAh0Qc8DcRsNACAHKAIEIghFDQAgBygCCCIJQQRrKAIAIgpBeHEiC0EEQQggCkEDcSIKGyAIakkNAiAKQQAgCyAIQSdqSxsNAyAJEEULQQAhCwsgBgRAIAVBBGsoAgAiCEF4cSIJQQRBCCAIQQNxIggbIAZqSQ0BIAhBACAJIAZBJ2pLGw0CIAUQRQsgBARAIANBBGsoAgAiBUF4cSIGQQRBCCAFQQNxIgUbIARqSQ0BIAVBACAGIARBJ2pLGw0CIAMQRQsgAgRAIAFBBGsoAgAiA0F4cSIEQQRBCCADQQNxIgMbIAJqSQ0BIANBACAEIAJBJ2pLGw0CIAEQRQsgAAJ/IAtFBEBBACELQQAhBkEBDAELIA0hBkEAIQ1BAAs2AgwgACANNgIIIAAgBjYCBCAAIAs2AgAgB0HgD2okAA8LQa31wgBBLkHc9cIAEKMBAAtB7PXCAEEuQZz2wgAQowEAC/4KAQV/IwBBEGsiBCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4oBgEBAQEBAQEBAgQBAQMBAQEBAQEBAQEBAQEBAQEBAQEBAQkBAQEBBwALIAFB3ABGDQQLIAFBgAZJDQsgAkEBcQ0GDAsLIABBgAQ7AQogAEIANwECIABB3OgBOwEADAwLIABBgAQ7AQogAEIANwECIABB3OQBOwEADAsLIABBgAQ7AQogAEIANwECIABB3NwBOwEADAoLIABBgAQ7AQogAEIANwECIABB3LgBOwEADAkLIABBgAQ7AQogAEIANwECIABB3OAAOwEADAgLIAJBgAJxRQ0GIABBgAQ7AQogAEIANwECIABB3M4AOwEADAcLIAFBC3QhA0EAIQJBISEGQSEhBQJAA0AgAyAGQQF2IAJqIgZBAnRBlLLAAGooAgBBC3QiB0cEQCAGIAUgAyAHSRsiBSAGQQFqIAIgAyAHSxsiAmshBiACIAVJDQEMAgsLIAZBAWohAgsgAkEgSw0BIAJBAnQiA0GUssAAaigCAEHXBSEFAkAgAkEgRg0AIANBmLLAAGoiA0UNACADKAIAQRV2IQULQRV2IQMgAgR/IAJBAnRBkLLAAGooAgBB////AHEFQQALIQICQCAFIANBf3NqRQ0AIAEgAmshB0HXBSADIANB1wVNGyEGIAVBAWshBUEAIQIDQCADIAZGDQQgAiADQZizwABqLQAAaiICIAdLDQEgBSADQQFqIgNHDQALIAUhAwsgA0EBcUUNBCAEQQhqQQA6AAAgBEEAOwEGIAQgAUEEdkEPcUG0m8AAai0AADoADSAEIAFBCHZBD3FBtJvAAGotAAA6AAwgBCABQQx2QQ9xQbSbwABqLQAAOgALIAQgAUEQdkEPcUG0m8AAai0AADoACiAEIAFBFHZBD3FBtJvAAGotAAA6AAkgAUEBcmdBAnYiAiAEQQZqIgVqIgNB+wA6AAAgA0EBa0H1ADoAACAFIAJBAmsiAmpB3AA6AAAgBEEOaiIDIAFBD3FBtJvAAGotAAA6AAAgACAEKQEGNwAAIARB/QA6AA8gAEEIaiADLwEAOwAAIABBCjoACyAAIAI6AAoMBgsgAkGAgARxDQIMBAtBIUEhQfSxwAAQmQEACyAGQdcFQYSywAAQmQEACyAAQYAEOwEKIABCADcBAiAAQdzEADsBAAwCCwJAIAFBIEkNACABQf8ASQ0BIAFBgIAETwRAIAFBgIAITwRAIAFBsMcMa0HQuitJIAFBy6YMa0EFSXIgAUGe9AtrQeILSSABQd7cC2tBohNJcnIgAUHh1wtrQQ9JIAFBop0La0EOSXIgAUF+cUGe8ApGIAFBYHFB4M0KRnJycg0CIAFBuu4Ka0EGSSABQfCDOGtBkPwLSXINAgwDCyABQdCmwABBLEGop8AAQcQBQeyowABBwgMQcEUNAQwCCyABQa6swABBKEH+rMAAQaACQZ6vwABBrQIQcA0BCyAEQQhqQQA6AAAgBEEAOwEGIAQgAUEEdkEPcUG0m8AAai0AADoADSAEIAFBCHZBD3FBtJvAAGotAAA6AAwgBCABQQx2QQ9xQbSbwABqLQAAOgALIAQgAUEQdkEPcUG0m8AAai0AADoACiAEIAFBFHZBD3FBtJvAAGotAAA6AAkgAUEBcmdBAnYiAiAEQQZqIgVqIgNB+wA6AAAgA0EBa0H1ADoAACAFIAJBAmsiAmpB3AA6AAAgBEEOaiIDIAFBD3FBtJvAAGotAAA6AAAgACAEKQEGNwAAIARB/QA6AA8gAEEIaiADLwEAOwAAIABBCjoACyAAIAI6AAoMAQsgACABNgIEIABBgAE6AAALIARBEGokAAuXCAIjfg1/IAAgASgCDCImQQF0rSISIAIoAgwiJ60iDn4gASgCBCIoQQF0rSITIAIoAhQiKa0iFH58IAEoAhQiKkEBdK0iFSACKAIEIiutIgt+fCABKAIcIixBAXStIhYgAigCJCItQRNsrSIFfnwgATUCACIDIAIoAhgiLq0iHn58IAEoAiQiL0EBdK0iFyACKAIcIjBBE2ytIgx+fCABNQIIIgYgAigCECIxrSIPfnwgATUCECIHIAIoAggiMq0iDX58IAE1AhgiCCACNQIAIgl+fCABNQIgIgogAigCICIBQRNsrSIEfnwgJq0iGCANfiAorSIZIA9+fCAsrSIaIAR+fCAvrSIbIC5BE2ytIhB+fCADIBR+fCAJICqtIhx+fCAGIA5+fCAHIAt+fCAFIAh+fCAKIAx+fCALIBJ+IA4gE358IAUgFX58IAwgFn58IAMgD358IBcgKUETbK0iHX58IAYgDX58IAcgCX58IAQgCH58IAogEH58IiJCGoh8IiNCGYh8Ih+nQf///x9xNgIYIAAgBSASfiALIBN+fCAMIBV+fCAWIB1+fCADIA1+fCAXICdBE2ytIhF+fCAGIAl+fCAEIAd+fCAIIBB+fCAKIDFBE2ytIiB+fCAQIBx+IAQgGH58IBogIH58IBsgMkETbK0iIX58IAMgC358IAkgGX58IAUgBn58IAcgDH58IAggHX58IAogEX58IAwgEn4gBSATfnwgFSAdfnwgESAWfnwgFyArQRNsrX58IAMgCX58IAQgBn58IAcgEH58IAggIH58IAogIX58IiFCGoh8IiRCGYh8IiWnQf///x9xNgIIIAAgDyAYfiAZIB5+fCANIBx+fCAEIBt+fCADIDCtIhF+fCAJIBp+fCAGIBR+fCAHIA5+fCAIIAt+fCAFIAp+fCAfQhqIfCIfp0H///8PcTYCHCAAIAQgHH4gDSAZfnwgECAafnwgGyAgfnwgAyAOfnwgCSAYfnwgBiALfnwgBSAHfnwgCCAMfnwgCiAdfnwgJUIaiHwiBKdB////D3E2AgwgACASIBR+IBEgE358IA4gFX58IAsgFn58IAMgAa0iDH58IAUgF358IAYgHn58IAcgD358IAggDX58IAkgCn58IB9CGYh8IgWnQf///x9xNgIgIAAgI0L///8PgyAiQv//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ACIEQSlJDQBBiP7CACEAA0AgAiAAKAIAIgVPBEAgBSAAKAIEaiACSw0CCyAAKAIIIgANAAsLQZD+wgAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtByIDDAEH/HyABIAFB/x9NGzYCACADIARPDQRBwIDDAEF/NgIADAQLAkACQCAAIAMoAgAiAygCBEF4cUYEQCADIQIMAQsgAEEZIAJBAXZrQQAgAkEfRxt0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAkUNAiAEQQF0IQQgAiEDIAIoAgRBeHEgAEcNAAsLIAIoAggiACABNgIMIAIgATYCCCABQQA2AhggASACNgIMIAEgADYCCAwBCyAFIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggLQQAhAUHIgMMAQciAwwAoAgBBAWsiADYCACAADQJBkP7CACgCACIABEADQCABQQFqIQEgACgCCCIADQALC0HIgMMAQf8fIAEgAUH/H00bNgIADwsgAEF4cUGY/sIAaiECAn9BoIDDACgCACIDQQEgAEEDdnQiAHFFBEBBoIDDACAAIANyNgIAIAIMAQsgAigCCAshACACIAE2AgggACABNgIMIAEgAjYCDCABIAA2AggPC0GwgMMAIAE2AgBBqIDDAEGogMMAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAsLzwcCFX8GfiMAQcADayICJAAgAkH5AmogAUEJaikAADcAACACQYEDaiABQRFqKQAANwAAIAJBhwNqIAFBF2opAAA3AAAgAiABKQABNwDxAiACIAEtAABB+AFxOgDwAiACIAEtAB9BP3FBwAByOgCPAyACQQhqIAJB8AJqIgMQNyACKAJYIQEgAigCMCEEIAIoAlwhBSACKAI0IQYgAigCYCEHIAIoAjghCCACKAJkIQkgAigCPCEKIAIoAmghCyACKAJAIQwgAigCbCENIAIoAkQhDiACKAJwIQ8gAigCSCEQIAIoAnQhESACKAJMIRIgAigCeCETIAIoAlAhFCACIAIoAlQiFSACKAJ8IhZqNgLMASACIBMgFGo2AsgBIAIgESASajYCxAEgAiAPIBBqNgLAASACIA0gDmo2ArwBIAIgCyAMajYCuAEgAiAJIApqNgK0ASACIAcgCGo2ArABIAIgBSAGajYCrAEgAiABIARqNgKoASACIA8gEGtB8P///wNqrSANIA5rQfD///8Baq0gCyAMa0Hw////A2qtIhdCGoh8IhpCGYh8IhinQf///x9xNgLoASACIAcgCGtB8P///wNqrSAFIAZrQfD///8Baq0gASAEa0HQ/f//A2qtIhtCGoh8IhxCGYh8IhmnQf///x9xNgLYASACIBEgEmtB8P///wFqrSAYQhqIfCIYp0H///8PcTYC7AEgAiAJIAprQfD///8Baq0gGUIaiHwiGadB////D3E2AtwBIAIgEyAUa0Hw////A2qtIBhCGYh8IhinQf///x9xNgLwASACIBpC////D4MgF0L///8fgyAZQhmIfCIXQhqIfD4C5AEgAiAXp0H///8fcTYC4AEgAiAWIBVrQfD///8Baq0gGEIaiHwiF6dB////D3E2AvQBIAIgHEL///8PgyAXQhmIQhN+IBtC////H4N8IhdCGoh8PgLUASACIBenQf///x9xNgLQASADIAJB0AFqEDsgAkHAAmogAkGQA2opAgA3AwAgAkG4AmogAkGIA2opAgA3AwAgAkGwAmogAkGAA2opAgA3AwAgAkGoAmogAkH4AmopAgA3AwAgAiACKQLwAjcDoAIgAkHoAmogAkG4A2opAgA3AwAgAkHgAmogAkGwA2opAgA3AwAgAkHYAmogAkGoA2opAgA3AwAgAkHQAmogAkGgA2opAgA3AwAgAiACKQKYAzcDyAIgAyACQaACakEFEFUgAkH4AWoiASADIAJByAJqEEEgAyACQagBaiABEEEgACADEEwgAkHAA2okAAvFBwIOfwZ+IwBB8AFrIgMkACADQSBqIg1BrLrAACkCACISNwMAIANBGGoiDkGkusAAKQIAIhQ3AwAgA0EQaiIPQZy6wAApAgAiETcDACADQQhqIhBBlLrAACkCACITNwMAIANBMGoiBSATNwMAIANBOGoiBiARNwMAIANBQGsiByAUNwMAIANByABqIgggEjcDACADQfAAaiIJQgA3AwAgA0HoAGoiCkIANwMAIANB4ABqIgtCADcDACADQdgAaiIMQgA3AwAgA0IANwNQIANBjLrAACkCACISNwMAIAMgEjcDKCADIAEgAsAiAkEHdSIEIAJqIARzIgJBAUYQvwEQUiADIAFB+ABqIAJBAkYQvwEQUiADIAFB8AFqIAJBA0YQvwEQUiADIAFB6AJqIAJBBEYQvwEQUiADIAFB4ANqIAJBBUYQvwEQUiADIAFB2ARqIAJBBkYQvwEQUiADIAFB0AVqIAJBB0YQvwEQUiADIAFByAZqIAJBCEYQvwEQUiAEQQFxEL8BIQEgA0GYAWogCCkDADcDACADQZABaiAHKQMANwMAIANBiAFqIAYpAwA3AwAgA0GAAWogBSkDADcDACADIAMpAyg3A3ggCSgCACECIAooAgAhBCALKAIAIQUgDCgCACEGIAMoAnQhByADKAJsIQggAygCXCEJIAMoAmQhCiADKAJUIQsgAygCUCEMIANBwAFqIA0pAwA3AwAgA0G4AWogDikDADcDACADQbABaiAPKQMANwMAIANBqAFqIBApAwA3AwAgAyADKQMANwOgASADQfD///8DIAZrrUHw////ASALa61B0P3//wMgDGutIhJCGoh8IhRCGYh8IhGnQf///x9xNgLQASADQfD///8DIARrrUHw////ASAKa61B8P///wMgBWutIhNCGoh8IhZCGYh8IhWnQf///x9xNgLgASADQfD///8BIAlrrSARQhqIfCIRp0H///8PcTYC1AEgA0Hw////ASAIa60gFUIaiHwiFadB////D3E2AuQBIAMgE0L///8fgyARQhmIfCIRp0H///8fcTYC2AEgA0Hw////AyACa60gFUIZiHwiE6dB////H3E2AugBIAMgFkL///8PgyARQhqIfD4C3AEgA0Hw////ASAHa60gE0IaiHwiEadB////D3E2AuwBIAMgEUIZiEITfiASQv///x+DfCISp0H///8fcTYCyAEgAyAUQv///w+DIBJCGoh8PgLMASADIANB+ABqIAEQUiAAIANB+AAQ3wEaIANB8AFqJAALpgYCCn8CfiMAQZABayIFJAAgBUFAayABIAIgAyAEECUCQAJAAkACQCAFLQBARQRAIAVBOGoiCCAFQfkAaikAADcDACAFQTBqIgcgBUHxAGopAAA3AwAgBUEoaiIKIAVB6QBqKQAANwMAIAVBIGoiCyAFQeEAaikAADcDACAFQRhqIgwgBUHZAGopAAA3AwAgBUEQaiINIAVB0QBqKQAANwMAIAVBCGoiDiAFQckAaikAADcDACAFIAUpAEE3AwBB0YDDAC0AABpBwAAhCUHAABAnIgZFDQIgBiAFKQMANwAA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ADcAACALIAApAwA3AwAgC0EIaiAAQQhqIgwpAwA3AwAgC0EQaiAAQRBqIg0pAwA3AwAgC0EYaiAAQRhqIg4pAwA3AwAgAC0AigEhByACQShqIAYpAwA3AwAgAkEwaiAFKQMANwMAIAJBOGogBCkDADcDACACQUBrIAopAwA3AwAgAkHIAGogAkG4AWopAwA3AwAgAkHQAGogAkHAAWopAwA3AwAgAkHYAGogAkHIAWopAwA3AwAgAkHAADoAiAEgAiACKQOQATcDICACIAdBBHIiBzoAiQEgAkIANwOAASAEIA4pAgA3AwAgBSANKQIANwMAIAYgDCkCADcDACACIAApAgA3A5ABIAJBkAFqIAJBIGpBwABCACAHECYgBCgCACEEIAUoAgAhBSAGKAIAIQYgAigCrAEhDCACKAKkASENIAIoApwBIQ4gAigClAEhByACKAKQASETIBVFDQMgGSATNgIAIANB+ABqIAw2AgAgFiAENgIAIANB8ABqIA02AgAgFyAFNgIAIANB6ABqIA42AgAgGCAGNgIAIANB4ABqIAc2AgAgACAJNgKYASAPQSBrIQ8gCCIJIBRPDQALCyACQdABaiQADwtB/JTAABDRAQALIAIgDDYCrAEgAiAENgKoASACIA02AqQBIAIgBTYCoAEgAiAONgKcASACIAY2ApgBIAIgBzYClAEgAiATNgKQAUGkksAAQSsgAkGQAWpB0JLAAEGMlcAAEJQBAAuEBgIIfgl/IAAgATUCJCABNQIgIAE1AhwgATUCGCABNQIUIAE1AhAiA0IaiHwiBEIZiHwiBUIaiHwiBkIZiHwiB0IaiHwiCEIZiEITfiABNQIAIgJC////H4N8IgmnQf///x9xIgpBE2pBGnYgATUCBCACQhqIfCICQv///w+DIAlCGoh8pyILakEZdiABNQIIIAJCGYh8IgKnQf///x9xIgxqQRp2IAE1AgwgAkIaiHwiAqdB////D3EiDWpBGXYgA0L///8fgyACQhmIfCICp0H///8fcSIOakEadiAEQv///w+DIAJCGoh8pyIPakEZdiAFp0H///8fcSIQakEadiAGp0H///8PcSIRakEZdiAHp0H///8fcSISakEadiAIp0H///8PcSIBakEZdkETbCAKaiIKOgAAIAAgCkEQdjoAAiAAIApBCHY6AAEgACAKQRp2IAtqIgtBDnY6AAUgACALQQZ2OgAEIAAgCkEYdkEDcSALQQJ0cjoAAyAAIAtBGXYgDGoiDEENdjoACCAAIAxBBXY6AAcgACAMQQN0IAtBgICADnFBFnZyOgAGIAAgDEEadiANaiINQQt2OgALIAAgDUEDdjoACiAAIAxBFXZBH3EgDUEFdHI6AAkgACANQRl2IA5qIg5BEnY6AA8gACAOQQp2OgAOIAAgDkECdjoADSAAIA5BGnYgD2oiDzoAECAAIA1BE3ZBP3EgDkEGdHI6AAwgACAPQRB2OgASIAAgD0EIdjoAESAAIA9BGXYgEGoiEEEPdjoAFSAAIBBBB3Y6ABQgACAPQRh2QQFxIBBBAXRyOgATIAAgEEEadiARaiIRQQ12OgAYIAAgEUEFdjoAFyAAIBBBF3ZBB3EgEUEDdHI6ABYgACARQRl2IBJqIhJBDHY6ABsgACASQQR2OgAaIAAgEUEVdkEPcSASQQR0cjoAGSAAIBJBGnYgAWoiAUEKdjoAHiAAIAFBAnY6AB0gACABQYCA8A9xQRJ2OgAfIAAgEkEUdkE/cSABQQZ0cjoAHAuyBgIOfwJ+IwBB8A9rIgEkAAJAAkACQCAABEAgAEEIayIFIAUoAgAiCEEBaiICNgIAIAJFDQEgACgCACIGQX9GDQIgACAGQQFqNgIAIAFBwA9qIABBgAFqKQMANwMAIAFBuA9qIABB+ABqKQMANwMAIAFBsA9qIABB8ABqKQMANwMAIAFB8A5qIABBMGopAwA3AwAgAUH4DmogAEE4aikDADcDACABQYAPaiAAQUBrKQMANwMAIAFBiA9qIABByABqKQMANwMAIAFBkA9qIABB0ABqKQMANwMAIAFBmA9qIABB2ABqKQMANwMAIAFBoA9qIABB4ABqKQMANwMAIAEgACkDaDcDqA8gASAAKQMoNwPoDiAAKQOIASEPIAApA5gBIRAgAC0AkgEhCSAALQCRASEKIAAtAJABIQsgACgCoAEiAgRAIAAgAkEFdCIMakGkAWohByAAQaQBaiENIAFBgAFqQQRyIQ4DQAJAIAQgDmoiAiAEIA1qIgMpAAA3AAAgAkEYaiADQRhqKQAANwAAIAJBEGogA0EQaikAADcAACACQQhqIANBCGopAAA3AAAgA0EgaiIDIAdGDQAgBEHADUYNBiACQSBqIAMpAAA3AAAgAkE4aiADQRhqKQAANwAAIAJBMGogA0EQaikAADcAACACQShqIANBCGopAAA3AAAgBEFAayEEIANBIGogB0cNAQsLIAxBIGtBBXZBAWohBAsgAUEIaiAAQQhqIgJBCGopAwA3AwAgAUEQaiACQRBqKQMANwMAIAFBGGogAkEYaikDADcDACABIAQ2AoABIAEgAikDADcDACABQSBqIAFB6A5qIgJB4AAQ3wEaIAAgBjYCACAFIAg2AgAgAUHsDmogAUGAARDfARpB0YDDAC0AABpBkA8QJyIARQ0BIABBADYCCCAAQoGAgIAQNwMAIABBDGogAkGEARDfARogACAQNwOgASAAIAk6AJoBIAAgCjoAmQEgACALOgCYASAAIA83A5ABIABBqAFqIAFBgAFqQeQNEN8BGiABQfAPaiQAIABBCGoPCxDWAQALAAsQ2AEAC0GskcAAQS9B4IDAABCjAQALqAcBIn8jAEFAaiIBJAAgAUE4aiICQgA3AwAgAUEwaiIDQgA3AwAgAUEoaiIEQgA3AwAgAUIANwMgIAFBIGoQZiABIAEtACAiBToAHyABIAEtACEiBjoAHiABIAEtACIiBzoAHSABIAEtACMiCDoAHCABIAEtACQiCToAGyABIAEtACUiCjoAGiABIAEtACYiCzoAGSABIAEtACciDDoAGCABIAQtAAAiBDoAFyABIAEtACkiDToAFiABIAEtACoiDjoAFSABIAEtACsiDzoAFCABIAEtACwiEDoAEyABIAEtAC0iEToAEiABIAEtAC4iEjoAESABIAEtAC8iEzoAECABIAMtAAAiAzoADyABIAEtADEiFDoADiABIAEtADIiFToADSABIAEtADMiFjoADCABIAEtADQiFzoACyABIAEtADUiGDoACiABIAEtADYiGToACSABIAEtADciGjoACCABIAItAAAiGzoAByABIAEtADkiHDoABiABIAEtADoiHToABSABIAEtADsiHjoABCABIAEtADwiHzoAAyABIAEtAD0iIDoAAiABIAEtAD4iIToAASABIAEtAD8iIjoAAEHRgMMALQAAGkEgECciAkUEQAALIAIgIjoAHyACICE6AB4gAiAgOgAdIAIgHzoAHCACIB46ABsgAiAdOgAaIAIgHDoAGSACIBs6ABggAiAaOgAXIAIgGToAFiACIBg6ABUgAiAXOgAUIAIgFjoAEyACIBU6ABIgAiAUOgARIAIgAzoAECACIBM6AA8gAiASOgAOIAIgEToADSACIBA6AAwgAiAPOgALIAIgDjoACiACIA06AAkgAiAEOgAIIAIgDDoAByACIAs6AAYgAiAKOgAFIAIgCToABCACIAg6AAMgAiAHOgACIAIgBjoAASACIAU6AAAgAUEAOgAfIAFBADoAHiABQQA6AB0gAUEAOgAcIAFBADoAGyABQQA6ABogAUEAOgAZIAFBADoAGCABQQA6ABcgAUEAOgAWIAFBADoAFSABQQA6ABQgAUEAOgATIAFBADoAEiABQQA6ABEgAUEAOgAQIAFBADoADyABQQA6AA4gAUEAOgANIAFBADoADCABQQA6AAsgAUEAOgAKIAFBADoACSABQQA6AAggAUEAOgAHIAFBADoABiABQQA6AAUgAUEAOgAEIAFBADoAAyABQQA6AAIgAUEAOgABIAFBADoAACAAQSA2AgQgACACNgIAIAFBQGskAAvZBgEJfyMAQeADayIDJAACQAJAIAJBIEYEQCADQQJqIAFBAmoiAi0AADoAACADQQ9qIAFBD2oiBikAADcAACADQR9qIAFBH2oiBy0AADoAACADIAEvAAA7AQAgAyABKAADNgADIAMgASkABzcAByADIAEpABc3ABcgAS0ABiEIIAEtAAUhCSABLQAEIQogAS0AAyELIANBgAJqIgQgAxA+IANBwAJqIgUgBBA3IANBQGsgBRBlIANB4ABqIAVBoAEQ3wEaIAQQaSADIAs6AD0gAyAKOgA8IAMgCToAOyADIAg6ADogAyABLQAAOgDAAiADIAEtAAE6AIACIAMgAi0AADoAPiADIAEtAAc6ADkgAyABLQAIOgA4IAMgAS0ACToANyADIAEtAAo6ADYgAyABLQALOgA1IAMgAS0ADDoANCADIAEtAA06ADMgAyABLQAOOgAyIAMgBi0AADoAMSADIAEtABA6ADAgAyABLQAROgAvIAMgAS0AEjoALiADIAEtABM6AC0gAyABLQAUOgAsIAMgAS0AFToAKyADIAEtABY6ACogAyABLQAXOgApIAMgAS0AGDoAKCADIAEtABk6ACcgAyABLQAaOgAmIAMgAS0AGzoAJSADIAEtABw6ACQgAyABLQAdOgAjQdGAwwAtAAAaIAMgAS0AHjoA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AGpB/wFxQTBPDQIMAQsgBEGPf0oNAQsgAiADQQJqIgRNBEBCACEJDAULIAEgBGosAABBv39KDQJCACEJIANBA2oiBCACTw0EIAEgBGosAABBv39MDQVCgICAgIDgAAwDC0KAgICAgCAMAgtCACEJIANBAmoiBCACTw0CIAEgBGosAABBv39MDQMLQoCAgICAwAALIQpCgICAgBAhCQsgACAKIAOthCAJhDcCBCAAQQE2AgAPCyAEQQFqIQMMAgsgA0EBaiEDDAELIAIgA00NAANAIAEgA2osAABBAEgNASACIANBAWoiA0cNAAsMAgsgAiADSw0ACwsgACACNgIIIAAgATYCBCAAQQA2AgALuAUCAX8GfiMAQYABayIDJAAgA0EwaiABEFYgAyADKQNgIAMpA1ggAykDUCIEQhqIfCIHQhmIfCIFp0H///8fcTYCICADIAMpA0AgAykDOCADKQMwIghCGoh8IglCGYh8IganQf///x9xNgIQIAMgAykDaCAFQhqIfCIFp0H///8PcTYCJCADIAMpA0ggBkIaiHwiBqdB////D3E2AhQgAyADKQNwIAVCGYh8IgWnQf///x9xNgIoIAMgB0L///8PgyAEQv///x+DIAZCGYh8IgRCGoh8PgIcIAMgBKdB////H3E2AhggAyADKQN4IAVCGoh8IgSnQf///w9xNgIsIAMgCUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAkEBayEBA0AgA0EwaiADQQhqEFYgAyADKQNgIAMpA1ggAykDUCIEQhqIfCIHQhmIfCIFp0H///8fcTYCICADIAMpA0AgAykDOCADKQMwIghCGoh8IglCGYh8IganQf///x9xNgIQIAMgAykDaCAFQhqIfCIFp0H///8PcTYCJCADIAMpA0ggBkIaiHwiBqdB////D3E2AhQgAyADKQNwIAVCGYh8IgWnQf///x9xNgIoIAMgB0L///8PgyAEQv///x+DIAZCGYh8IgRCGoh8PgIcIAMgBKdB////H3E2AhggAyADKQN4IAVCGoh8IgSnQf///w9xNgIsIAMgCUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAUEBayIBDQALIAAgAykCCDcCACAAQSBq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IAMgARB7DAELQQELIQAgA0EBaiEDIAVBAWsiBQ0ACwtBASEDIABFBEAgASgCFEGynsAAQQEgASgCGCgCDBEAACEDCyACQUBrJAAgAwu3BAEPfyMAQRBrIgIgASgCICABKAIcIAEoAhggASgCFCABKAIQIAEoAgwgASgCCCABKAIEIAEoAgBB7afX5wFrIgNBH3VqQdKxzARrIgRBH3VqQZbrnO8BayIFQR91akHF+s7vAWsiBkEfdWpBzQJrIgdBH3VqIghBH3VqIglBH3VqIgpBH3VqQYCAQGoiC0EfdSIBNgIMIAIoAgwhDCACIAE2AgwgAigCDCENIAIgATYCDCACKAIMIQ4gAiABNgIMIAIoAgwhDyACIAE2AgwgAigCDCEQIAIgATYCDCACKAIMGiACIAE2AgwgAigCDBogAiABNgIMIAIoAgwaIAIgATYCDCACKAIMIQEgACAKQf////8BcSAJQf////8BcSAIQf////8BcSAHQf////8BcSAGQf////8BcSAFQf////8BcSAEQf////8BcSADQf////8BcSAMQe2n1+cBcWoiAkEddmogDUHSscwEcWoiA0EddmogDkGW65zvAXFqIgRBHXZqIA9BxfrO7wFxaiIFQR12aiAQQc0CcWoiBkEddmoiB0EddmoiCEEddmoiCUH/////AXE2AhwgACAIQf////8BcTYCGCAAIAdB/////wFxNgIUIAAgBkH/////AXE2AhAgACAFQf////8BcTYCDCAAIARB/////wFxNgIIIAAgA0H/////AXE2AgQgACACQf////8BcTYCACAAIAsgCUEddmogAUGAgMAAcWpB/////wFxNgIgC7wDAgx/AX4jAEEQayIIJAAgAwRAA0AgAyADQRAgA0EQSSIEGyIFayEDIAIgBWoCQCAERQRAIAEgAkEAEGAMAQsgBSAIakEQIAVrEN4BIAggAiAFEN8BIQJBAToAACABIAJBARBgCyECIAMNAAsLIAAgASgCJCABKAI0IAEoAjAgASgCLCABKAIoIgJBGnZqIgNBGnZqIgVBGnZqIgdBGnZBBWxqIgRB////H3EiBkEFaiIJQRp2IAJB////H3EgBEEadmoiAmoiBEEadiADQf///x9xIgpqIgtBGnYgBUH///8fcSIFaiIMQRp2IAdB////H3FqIg1BgICAIGsiDkEfdkEBayIPQf///x9xIgMgBHEgAiAOQR91IgJxciIEQRp0IAIgBnEgAyAJcXJyIgYgASgCAGoiCTYAACAAIAYgCUutIAE1AgQgAyALcSACIApxciIGQRR0IARBBnZyrXx8IhA+AAQgACABNQIIIAMgDHEgAiAFcXIiA0EOdCAGQQx2cq18IBBCIIh8IhA+AAggACABNQIMIA0gD3EgAiAHcXJBCHQgA0ESdnKtfCAQQiCIfD4ADCAIQRBqJAALxwMCDX4DfyAAIAAoAiggASgAA0ECdkH///8fcWqtIgMgACgCFCIQrSILfiAAKAIkIAEoAABB////H3FqrSIFIAAoAhgiEa0iDX58IAAoAiwgASgABkEEdkH///8fcWqtIgYgADUCECIHfnwgACgCMCABKAAJQQZ2aq0iCCAAKAIgIhJBBWytIgR+fCAAKAI0QQBBgICACCACG2ogASgADEEIdmqtIgkgACgCHCIBQQVsrSIKfnwgAyAHfiAFIAt+fCAEIAZ+fCAIIAp+fCAJIBFBBWytIgx+fCADIAR+IAUgB358IAYgCn58IAggDH58IAkgEEEFbK1+fCIKQhqIQv////8Pg3wiDEIaiEL/////D4N8Ig6nQf///x9xNgIsIAAgAyANfiAFIAGtIg9+fCAGIAt+fCAHIAh+fCAEIAl+fCAOQhqIQv////8Pg3wiBKdB////H3E2AjAgACADIA9+IAUgEq1+fCAGIA1+fCAIIAt+fCAHIAl+fCAEQhqIQv////8Pg3wiA6dB////H3E2AjQgACADQhqIp0EFbCAKp0H///8fcWoiAUH///8fcTYCJCAAIAynQf///x9xIAFBGnZqNgIoC+EDAgZ+Dn8gAigCJCEJIAEoAiQhCiACKAIgIQsgASgCICEMIAIoAgwhDSABKAIMIQ4gAigCHCEPIAEoAhwhECACKAIIIREgASgCCCESIAIoAgQhEyABKAIEIRQgAigCACEVIAEoAgAhFiAAIAEoAhggAigCGGtB8P///wNqrSABKAIUIAIoAhRrQfD///8Baq0gASgCECACKAIQa0Hw////A2qtIgNCGoh8IgZCGYh8IgSnQf///x9xNgIYIAAgEiARa0Hw////A2qtIBQgE2tB8P///wFqrSAWIBVrQdD9//8Daq0iB0IaiHwiCEIZiHwiBadB////H3E2AgggACAQIA9rQfD///8Baq0gBEIaiHwiBKdB////D3E2AhwgACAOIA1rQfD///8Baq0gBUIaiHwiBadB////D3E2AgwgACAMIAtrQfD///8Daq0gBEIZiHwiBKdB////H3E2AiAgACAGQv///w+DIANC////H4MgBUIZiHwiA0IaiHw+AhQgACADp0H///8fcTYCECAAIAogCWtB8P///wFqrSAEQhqIfCIDp0H///8PcTYCJCAAIAhC////D4MgA0IZiEITfiAHQv///x+DfCIDQhqIfD4CBCAAIAOnQf///x9xNgIAC9cDAgV/A34jAEHgD2siAyQAIANBCGpBzIzAACkCACIINwMAIANBEGpB1IzAACkCACIJNwMAIANBGGpB3IzAACkCACIKNwMAIANBuA9qQgA3AwAgA0GwD2pCADcDACADQagPakIANwMAIANBoA9qQgA3AwAgA0GYD2oiBUIANwMAIANBkA9qIgZCADcDACADQYgPaiIHQgA3AwAgA0HID2ogCDcDACADQdAPaiAJNwMAIANB2A9qIAo3AwAgA0HEjMAAKQIAIgg3AwAgA0IANwOADyADIAg3A8APIANBIGogA0GAD2oiBEHgABDfARogA0GHAWpBADYAACADQgA3A4ABIANBADYCmAEgA0IANwOQASAEIAMgASACEC0QNUHRgMMALQAAGgJAAkBBIBAnIgQEQCAEIAMpAIAPNwAAIARBGGogBSkAADcAACAEQRBqIAYpAAA3AAAgBEEIaiAHKQAANwAAIAIEQCABQQRrKAIAIgVBeHEiBkEEQQggBUEDcSIFGyACakkNAiAFQQAgBiACQSdqSxsNAyABEEULIABBIDYCBCAAIAQ2AgAgA0HgD2okAA8LAAtBrfXCAEEuQdz1wgAQowEAC0Hs9cIAQS5BnPbCABCjAQALyAMCBH8DfiMAQeAPayIDJAAgA0EIakHMjMAAKQIAIgc3AwAgA0EQakHUjMAAKQIAIgg3AwAgA0EYakHcjMAAKQIAIgk3AwAgA0G4D2pCADcDACADQbAPakIANwMAIANBqA9qQgA3AwAgA0GgD2pCADcDACADQZgPakIANwMAIANBkA9qIgVCADcDACADQYgPaiIGQgA3AwAgA0HID2ogBzcDACADQdAPaiAINwMAIANB2A9qIAk3AwAgA0HEjMAAKQIAIgc3AwAgA0IANwOADyADIAc3A8APIANBIGogA0GAD2oiBEHgABDfARogA0GHAWpBADYAACADQgA3A4ABIANBADYCmAEgA0IANwOQASAEIAMgASACEC0QNUHRgMMALQAAGgJAAkBBGBAnIgQEQCAEIAMpAIAPNwAAIARBEGogBSkAADcAACAEQQhqIAYpAAA3AAAgAgRAIAFBBGsoAgAiBUF4cSIGQQRBCCAFQQNxIgUbIAJqSQ0CIAVBACAGIAJBJ2pLGw0DIAEQRQsgAEEYNgIEIAAgBDYCACADQeAPaiQADwsAC0Gt9cIAQS5B3PXCABCjAQALQez1wgBBLkGc9sIAEKMBAAu6AwEFfwJAAkACQAJAAn8CQCACQcAARgRAQdGAwwAtAAAaIAEoAAMhAkHAABAnIgMNAQALQQEhBEG0iMAAQRgQACEGQQAgAkUNARogAUEEaygCACIFQXhxIgdBBEEIIAVBA3EiBRsgAmpJDQIgBUEAIAcgAkEnaksbDQMgARBFQQAMAQsgAyABLwAAOwAAIANBAmogAUECai0AADoAACADIAI2AAMgA0E/aiABQT9qLQAAOgAAIANBN2ogAUE3aikAADcAACADQS9qIAFBL2opAAA3AAAgA0EnaiABQSdqKQAANwAAIANBH2ogAUEfaikAADcAACADQRdqIAFBF2opAAA3AAAgA0EPaiABQQ9qKQAANwAAIAMgASkABzcAByABQQRrKAIAIgJBeHEiBEHEAEHIACACQQNxIgIbSQ0DIAJBACAEQegATxsNBCABEEVBACEEQcAACyEBIAAgBDYCDCAAIAY2AgggACABNgIEIAAgAzYCAA8LQa31wgBBLkHc9cIAEKMBAAtB7PXCAEEuQZz2wgAQowEAC0Gt9cIAQS5B3PXCABCjAQALQez1wgBBLkGc9sIAEKMBAAvfAgEHfyMAQdABayICJAAgAkGAAWoiAyABQdAAahA7IAJB0ABqIAJBoAFqKQIANwMAIAJByABqIAJBmAFqKQIANwMAIAJBQGsiByACQZABaikCADcDACACQThqIgggAkGIAWopAgA3AwAgAiACKQKAATcDMCACQfgAaiACQcgBaikCADcDACACQfAAaiACQcABaikCADcDACACQegAaiACQbgBaikCADcDACACQeAAaiACQbABaikCADcDACACIAIp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OgAAQfz8wgBBADYCAAsgAEEgaiQADAYLIABBADYCGCAAQQE2AgwgAEHg9sIANgIIIABCBDcCECAAQQhqQYT3wgAQpgEACyAAQQA2AhggAEEBNgIMIABBwILAADYCCAwDCyAAQQA2AhggAEEBNgIMIABBgILAADYCCAwCC0GUg8AAENEBAAsACyAAQgQ3AhAgAEEIakGsj8AAEKYBAAsLIAFBEGokAAstAAJAIANpQQFHQYCAgIB4IANrIAFJckUEQCAAIAEgAyACEEoiAA0BCwALIAALIwEBfyAAKAIAIgAgAEEfdSICcyACa60gAEF/c0EfdiABEHULJQAgAEUEQEGn8sIAQTIQ1wEACyAAIAIgAyAEIAUgASgCEBEKAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBENAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBEJAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBEWAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBEYAAsjACAARQRAQafywgBBMhDXAQALIAAgAiADIAQgASgCEBEaAAshACAARQRAQafywgBBMhDXAQALIAAgAiADIAEoAhARAwALHwAgAEUEQEGn8sIAQTIQ1wEACyAAIAIgASgCEBEBAAscACAAKAIAIgAoAgAgASAAQQRqKAIAKAIQEQEACxgAIAEgACgCACIAKAIAIABBBGooAgAQOAvcBgENfyAAKAIAIQcgACgCBCEDIAEoAhQhCSABKAIYIQtBACEAQQAhASMAQRBrIgQkAEEBIQwCQCAJQSIgCygCECINEQEADQACQCADRQRAQQAhAwwBCyAHIQUgAyEGAkACQANAIAUgBmohDkEAIQACQANAIAAgBWoiCC0AACIKQf8Aa0H/AXFBoQFJIApBIkZyIApB3ABGcg0BIAYgAEEBaiIARw0ACyACIAZqIQIMAwsgACACaiECAkACQAJAIAgsAAAiAEEATgRAIAhBAWohBSAAQf8BcSEADAELIAgtAAFBP3EhBSAAQR9xIQYgAEFfTQRAIAZBBnQgBXIhACAIQQJqIQUMAQsgCC0AAkE/cSAFQQZ0ciEKIABBcEkEQCAKIAZBDHRyIQAgCEEDaiEFDAELIAhBBGoh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AjwgBSAFQRhqrUKAgICA8ACENwNgIAUgBUEQaq1CgICAgPAAhDcDWCAFIAVBDGqtQoCAgIAQhDcDUCAFIAVBCGqtQoCAgIAQhDcDSAwDCyADIAdB+KXAABCaAQALIAQQ0QEACyAAIAEgAyABIAQQwwEACyAFIAVByABqNgI4IAVBMGogBBCmAQALFAAgACgCACABIAAoAgQoAhARAQALDQAgAEUEQBCnAQALAAsQACABIAAoAgQgACgCCBA4CxAAIAEgACgCACAAKAIEEDgLIQAgAEL6hJyDstaplFM3AwggAEL0qajcsoPpgod/NwMACxAAIAEoAhQgASgCGCAAEFgLIAAgAELPkYaA866RtgU3AwggAEKF4Z+i68irjmM3AwALIAAgAEKQx4yUopiKpQ43AwggAELn+MPj/N3QpgY3AwALEwAgAEEoNgIEIABB5PLCADYCAAsTACAAQbT3wgA2AgQgACABNgIACyIAIABC7bqtts2F1PXjADcDCCAAQviCmb2V7sbFuX83AwALIAAgAELakJn3/vvw5y43AwggAEL239fl4aeXtCY3AwALFgBB2IDDACAANgIAQdSAwwBBAToAAAsPAEHGm8AAQSsgABCjAQALDQAgADUCAEEBIAEQdQsNACAAKQMAQQEgARB1CwsAIAAjAGokACMACw0AIABBpIPAACABEFgLDQBBuPnCAEEbENcBAAsJACAAIAEQIQALDgBB0/nCAEHPABDXAQALDQAgAEG8j8AAIAEQWAsNACAAQYiewAAgARBYCw0AIABB7PTCACABEFgLQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIABBAWohACABQQFqIQEgAkEBayICDQEMAgsLIAQgBWshAwsgAwuUBQEIfwJAAn8CQCACIgYgACABa0sEQCABIAJqIgMhBSAAIAJqIQIgACAGQRBJDQIaIAJBfHEhBEEAIAJBA3EiB2shCCAHBEAgA0EBayEDA0AgAkEBayICIAMtAAA6AAAgA0EBayEDIAIgBEsNAAsLIAQgBiAHayIHQXxxIgZrIQIgBSAIaiIFQQNxBEAgBkEATA0CIAVBA3QiA0EYcSEIIAVBfHEiCUEEayEBQQAgA2tBGHEhCiAJKAIAIQMDQCAEQQRrIgQgAyAKdCABKAIAIgMgCHZyNgIAIAFBBGshASACIARJDQALDAILIAZBAEwNASABIAdqQQRrIQEDQCAEQQRrIgQgASgCADYCACABQQRrIQEgAiAESQ0ACwwBCwJAIAZBEEkEQCAAIQIMAQsgAEEAIABrQQNxIgVqIQQgBQRAIAAhAiABIQMDQCACIAMtAAA6AAAgA0EBaiEDIAJBAWoiAiAESQ0ACwsgBCAGIAVrIgZBfHEiB2ohAgJAIAEgBWoiBUEDcQRAIAdBAEwNASAFQQN0IgNBGHEhCCAFQXxxIglBBGohAUEAIANrQRhxIQogCSgCACEDA0AgBCADIAh2IAEoAgAiAyAKdHI2AgAgAUEEaiEBIARBBGoiBCACSQ0ACwwBCyAHQQBMDQAgBSEBA0AgBCABKAIANgIAIAFBBGohASAEQQRqIgQgAkkNAAsLIAZBA3EhBiAFIAdqIQELIAZFDQIgAiAGaiEDA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0kNAAsMAgsgB0EDcSIBRQ0BIAUgBmshBSACIAFrCyEDIAVBAWshAQNAIAJBAWsiAiABLQAAOgAAIAFBAWshASACIANLDQALCyAAC58BAQN/AkAgASICQRBJBEAgACEBDAELIABBACAAa0EDcSIEaiEDIAQEQCAAIQEDQCABQQA6AAAgAUEBaiIBIANJDQALCyADIAIgBGsiAkF8cSIEaiEBIARBAEoEQANAIANBADYCACADQQRqIgMgAUkNAAsLIAJBA3EhAgsgAgRAIAEgAmohAgNAIAFBADoAACABQQFqIgEgAkkNAAsLIAALuAIBB38CQCACIgRBEEkEQCAAIQIMAQsgAEEAIABrQQNxIgNqIQUgAwRAIAAhAiABIQYDQCACIAYtAAA6AAAgBkEBaiEGIAJBAWoiAiAFSQ0ACwsgBSAEIANrIghBfHEiB2ohAgJAIAEgA2oiA0EDcQRAIAdBAEwNASADQQN0IgRBGHEhCSADQXxxIgZBBGohAUEAIARrQRhxIQQgBigCACEGA0AgBSAGIAl2IAEoAgAiBiAEdHI2AgAgAUEEaiEBIAVBBGoiBSACSQ0ACwwBCyAHQQBMDQAgAyEBA0AgBSABKAIANgIAIAFBBGohASAFQQRqIgUgAkkNAAsLIAhBA3EhBCADIAdqIQELIAQEQCACIARqIQMDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADSQ0ACwsgAAsJACAAQQA2AgALAgALC9/7Ag4AQYCAwAALuQMvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hcnJheXZlYy0wLjcuNi9zcmMvYXJyYXl2ZWMucnMAABAAYAAAAHsEAAAPAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvY3J5cHRvX3NlY3JldGJveC0wLjEuMS9zcmMvbGliLnJzT25jZSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkAAAA0wAQACoAAABvbmUtdGltZSBpbml0aWFsaXphdGlvbiBtYXkgbm90IGJlIHBlcmZvcm1lZCByZWN1cnNpdmVseQgBEAA4AAAAL3J1c3RjLzA1MTQ3ODk1NzM3MWVlMDA4NGE3YzA5MTM5NDFkMmE4YzQ3NTdiYjkvbGlicmFyeS9zdGQvc3JjL3N5bmMvb25jZS5yc0gBEABMAAAAlQAAADIAAAAkAAAADAAAAAQAAAAlAAAAJgAAACcAQcSDwAALoQEBAAAAKAAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JzNTgtMC41LjEvc3JjL2VuY29kZS5ycwAAzAEQAFoAAADQAQAAGwAAAMwBEABaAAAA0QEAABAAAADMARAAWgAAAMwBAAAJAAAAzAEQAFoAAAC5AQAAIABB8ITAAAudAQEAAAApAAAAzAEQAFoAAAA9AQAAIAAAAGRlc3QgaXMgb3V0IG9mIGJvdW5kcwAAAIgCEAAVAAAAQnVmZmVyVG9vU21hbGxVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlbkZyb21VdGY4RXJyb3JieXRlc2Vycm9yU29tZQAAKgAAABQAAAAEAAAAKwAAAMwBEABaAAAAkwAAACsAQZiGwAAL2goBAAAALAAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2NpcGhlci0wLjQuNC9zcmMvc3RyZWFtLnJzIAMQAFwAAAB4AAAAJwAAAFN0cmVhbUNpcGhlckVycm9yAAAAcAAQAGMAAAD9AAAAGQAAAHAAEABjAAAAAgEAACEAAABwABAAYwAAAAUBAAAYAAAASW52YWxpZCBrZXkgbGVuZ3RoSW52YWxpZCBub25jZSBsZW5ndGhJbnZhbGlkIHNlYWxlciBzZWNyZXQgZm9ybWF0OiBtdXN0IHN0YXJ0IHdpdGggJ3NlYWxlclNlY3JldF96J0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aEludmFsaWQgdmVyaWZ5aW5nIGtleTogAEwEEAAXAAAASW52YWxpZCBwdWJsaWMga2V5OiBsBBAAFAAAAFdyb25nIHRhZ0ZhaWxlZCB0byBjcmVhdGUgY2lwaGVySW52YWxpZCAgZm9ybWF0OiBtdXN0IHN0YXJ0IHdpdGggJycAqAQQAAgAAACwBBAAGgAAAMoEEAABAAAASW52YWxpZCBiYXNlNTg6IOQEEAAQAAAAa2V5U2VjcmV0X3r/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpzZWFsZXJTZWNyZXRfenNlYWxlcl96c2lnbmVyU2VjcmV0X3pzaWduZXIgc2VjcmV0c2lnbmF0dXJlX3oAAADyBRAACwAAAHNpZ25hdHVyZXNpZ25lcl96c2lnbmVyIElEAAARBhAACAAAAHNlYWxlciBzZWNyZXQAAADPBRAACAAAAGfmCWqFrme7cvNuPDr1T6V/Ug5RjGgFm6vZgx8ZzeBbYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkSW52YWxpZCBzaWduaW5nIGtleSBsZW5ndGhJbnZhbGlkIHZlcmlmeWluZyBrZXkgbGVuZ3RoSW52YWxpZCBVVEYtOCBpbiBzZWNyZXQ6IAAA2QYQABkAAABJbnZhbGlkIFVURi04IGluIHNpZ25hdHVyZTog/AYQABwAAABJbnZhbGlkIFVURi04IGluIGlkOiAAAAAgBxAAFQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2NvbnNvbGVfZXJyb3JfcGFuaWNfaG9vay0wLjEuNy9zcmMvbGliLnJzAEAHEABrAAAAlQAAAA4AAAAtAAAADAAAAAQAAAAuAAAALwAAADAAAABjYXBhY2l0eSBvdmVyZmxvdwAAANQHEAARAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc/AHEAAcAAAAGQAAAAUAAABhIGZvcm1hdHRpbmcgdHJhaXQgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3Igd2hlbiB0aGUgdW5kZXJseWluZyBzdHJlYW0gZGlkIG5vdABB/JDAAAuFAgEAAAAxAAAAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzhAgQABgAAAB7AgAADgAAAEFycmF5VmVjOiBjYXBhY2l0eSBleGNlZWRlZCBpbiBleHRlbmQvZnJvbV9pdGVyAAAAAAAEAAAABAAAADIAAABpbnN1ZmZpY2llbnQgY2FwYWNpdHkAAADsCBAAFQAAAENhcGFjaXR5RXJyb3I6IAAMCRAADwAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAAAAAACAAAAABAAAAMwAAAAAAAAAEAAAABAAAADQAAABtaWQgPiBsZW4AAABwCRAACQBBkJPAAAurBy9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JsYWtlMy0xLjguMS9zcmMvbGliLnJzAAAAkAkQAFkAAAALAgAAEQAAAJAJEABZAAAAvgIAAAoAAACQCRAAWQAAAOwCAAAMAAAAkAkQAFkAAADsAgAAKAAAAJAJEABZAAAA3AIAABcAAACQCRAAWQAAABgDAAAfAAAAkAkQAFkAAAA1AwAADAAAAJAJEABZAAAAPAMAABIAAACQCRAAWQAAAGADAAAhAAAAkAkQAFkAAAB1BAAAMgAAAJAJEABZAAAAfQQAABsAAACQCRAAWQAAAKQEAAAXAAAAdGhlIHN1YnRyZWUgc3RhcnRpbmcgYXQgIGNvbnRhaW5zIGF0IG1vc3QgIGJ5dGVzIChmb3VuZCCsChAAGAAAAMQKEAASAAAA1goQAA4AAABMuhAAAQAAAJAJEABZAAAAtgQAAA0AAACQCRAAWQAAABMFAAAbAAAAkAkQAFkAAAAlBQAAGwAAAJAJEABZAAAAVgUAABIAAACQCRAAWQAAAGAFAAASAAAAc2V0X2lucHV0X29mZnNldCBtdXN0IGJlIHVzZWQgd2l0aCBmaW5hbGl6ZV9ub25fcm9vdFQLEAA0AAAAkAkQAFkAAABxBQAACQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JzNTgtMC41LjEvc3JjL2RlY29kZS5ycwAAoAsQAFoAAADAAQAACwAAAKALEABaAAAArAEAACAAAABidWZmZXIgcHJvdmlkZWQgdG8gZGVjb2RlIGJhc2U1OCBlbmNvZGVkIHN0cmluZyBpbnRvIHdhcyB0b28gc21hbGxwcm92aWRlZCBzdHJpbmcgY29udGFpbmVkIGludmFsaWQgY2hhcmFjdGVyICBhdCBieXRlIABeDBAALAAAAIoMEAAJAAAAcHJvdmlkZWQgc3RyaW5nIGNvbnRhaW5lZCBub24tYXNjaWkgY2hhcmFjdGVyIHN0YXJ0aW5nIGF0IGJ5dGUgAKQMEAA/AAAANQAAAAwAAAAEAAAANgAAADcAAAA4AAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQBBxJrAAAvVAQEAAAAoAAAAL3J1c3RjLzA1MTQ3ODk1NzM3MWVlMDA4NGE3YzA5MTM5NDFkMmE4YzQ3NTdiYjkvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAEwNEABLAAAAAwoAAA4AAAAKClN0YWNrOgoKLi4wMTIzNDU2Nzg5YWJjZGVmOltjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAAAAAQAA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dHVhdGlvblNlY1JhbmRvbUNvcHlCeXRlczogaU9TIFNlY3VyaXR5IGZyYW1ld29yayBmYWlsdXJlUnRsR2VuUmFuZG9tOiBXaW5kb3dzIHN5c3RlbSBmdW5jdGlvbiBmYWlsdXJlUkRSQU5EOiBmYWlsZWQgbXVsdGlwbGUgdGltZXM6IENQVSBpc3N1ZSBsaWtlbHlSRFJBTkQ6IGluc3RydWN0aW9uIG5vdCBzdXBwb3J0ZWRXZWIgQ3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZUNhbGxpbmcgV2ViIEFQSSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGZhaWxlZHJhbmRTZWN1cmU6IFZ4V29ya3MgUk5HIG1vZHVsZSBpcyBub3QgaW5pdGlhbGl6ZWROb2RlLmpzIGNyeXB0byBDb21tb25KUyBtb2R1bGUgaXMgdW5hdmFpbGFibGVDYWxsaW5nIE5vZGUuanMgQVBJIGNyeXB0by5yYW5kb21GaWxsU3luYyBmYWlsZWROb2RlLmpzIEVTIG1vZHVsZXMgYXJlIG5vdCBkaXJlY3RseSBzdXBwb3J0ZWQsIHNlZSBodHRwczovL2RvY3MucnMvZ2V0cmFuZG9tI25vZGVqcy1lcy1tb2R1bGUtc3VwcG9ydGNyeXB0b2Nsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkcmV0dXJuIHRoaXNkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5AQAAAAAAAABFcnJvcjogAJS5EAAHAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcmFuZF9jb3JlLTAuNi40L3NyYy9vcy5ycwCkuRAAWwAAAD8AAAANAAAAAAAAAAQAAAAEAAAASAAAAAAAAAAEAAAABAAAAEkAAABIAAAAELoQAD8AAABKAAAAQQAAAD8AAABCAAAAKU5vbmUgfXNpZ25hdHVyZSBlcnJvcjogYroQAAIAAABLAAAADAAAAAQAAABMAAAATQAAAE4AAAAvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi42L3NyYy9kbG1hbGxvYy5yc2Fzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQAhLoQACkAAACoBAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplIDw9IHNpemUgKyBtYXhfb3ZlcmhlYWQAAIS6EAApAAAArgQAAA0AAABjYW5ub3QgbW9kaWZ5IHRoZSBwYW5pYyBob29rIGZyb20gYSBwYW5pY2tpbmcgdGhyZWFkLLsQADQAAABsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzaLsQABwAAACGAAAACQAAAGi7EAAcAAAAiwIAAB4AAABLAAAADAAAAAQAAABPAAAAAAAAAAgAAAAEAAAAUAAAAAAAAAAIAAAABAAAAFEAAABSAAAAUwAAABAAAAAEAAAAVAAAAFUAAABMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAOy7EAAqAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAILwQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AACQvBAADgAAACC8EABdAAAAegIAAA0AAABudWxsIHBvaW50ZXIgcGFzc2VkIHRvIHJ1c3RyZWN1cnNpdmUgdXNlIG9mIGFuIG9iamVjdCBkZXRlY3RlZCB3aGljaCB3b3VsZCBsZWFkIHRvIHVuc2FmZSBhbGlhc2luZyBpbiBydXN0AAAnAAAAJgAAABQAAAAyAAAALQAAAC8AAAAhAAAAHQAAAC0AAAAnAAAAJwAAADEAAAAtAAAAMAAAAGUAAADUthAA+7YQACG3EAA1txAAZ7cQAJS3EADDtxAA5LcQAAG4EADUthAA1LYQAC64EABfuBAAjLgQALy4EAAnAAAAJgAAABQAAAAyAAAALQAAAC8AAAAhAAAAHQAAAC0AAAAnAAAAJwAAADEAAAAtAAAAMAAAAGUAAADUthAA+7YQACG3EAA1txAAZ7cQAJS3EADDtxAA5LcQAAG4EADUthAA1LYQAC64EABfuBAAjLgQALy4EABBlPzCAAs1AwAAAEMAAAACAAAAAAAAAEQAAAACAAAAAAAAAEUAAAACAAAAAAAAAEYAAAACAAAAAAAAAEcAQeT8wgALAVYASAlwcm9kdWNlcnMBDHByb2Nlc3NlZC1ieQIGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4TMC4yLjEwMCAoMjQwNWVjMmI0KQ==";
    let output = void 0;
    async function initialize() {
      return output ?? (output = await __wbg_init({ module_or_path: data }));
    }
    class WasmCrypto extends CryptoProvider {
      constructor() {
        super();
      }
      static async create() {
        try {
          await initialize();
        } catch (e) {
          logger.warn("Failed to initialize WasmCrypto, falling back to PureJSCrypto", { err: e });
          return new PureJSCrypto();
        }
        return new WasmCrypto();
      }
      emptyBlake3State() {
        return blake3_empty_state();
      }
      cloneBlake3State(state) {
        return state.clone();
      }
      blake3HashOnce(data2) {
        return blake3_hash_once(data2);
      }
      blake3HashOnceWithContext(data2, { context }) {
        return blake3_hash_once_with_context(data2, context);
      }
      blake3IncrementalUpdate(state, data2) {
        state.update(data2);
        return state;
      }
      blake3DigestForState(state) {
        return state.finalize();
      }
      newEd25519SigningKey() {
        return new_ed25519_signing_key();
      }
      getSignerID(secret) {
        return get_signer_id(textEncoder.encode(secret));
      }
      sign(secret, message) {
        return sign(textEncoder.encode(stableStringify(message)), textEncoder.encode(secret));
      }
      verify(signature, message, id2) {
        const result = verify(textEncoder.encode(signature), textEncoder.encode(stableStringify(message)), textEncoder.encode(id2));
        return result;
      }
      newX25519StaticSecret() {
        return new_x25519_private_key();
      }
      getSealerID(secret) {
        return get_sealer_id(textEncoder.encode(secret));
      }
      encrypt(value, keySecret, nOnceMaterial) {
        return `encrypted_U${bytesToBase64url(encrypt(textEncoder.encode(stableStringify(value)), keySecret, textEncoder.encode(stableStringify(nOnceMaterial))))}`;
      }
      decryptRaw(encrypted, keySecret, nOnceMaterial) {
        return textDecoder.decode(decrypt(base64URLtoBytes(encrypted.substring("encrypted_U".length)), keySecret, textEncoder.encode(stableStringify(nOnceMaterial))));
      }
      seal({ message, from, to, nOnceMaterial }) {
        return `sealed_U${bytesToBase64url(seal(textEncoder.encode(stableStringify(message)), from, to, textEncoder.encode(stableStringify(nOnceMaterial))))}`;
      }
      unseal(sealed, sealer, from, nOnceMaterial) {
        const plaintext = textDecoder.decode(unseal(base64URLtoBytes(sealed.substring("sealed_U".length)), sealer, from, textEncoder.encode(stableStringify(nOnceMaterial))));
        try {
          return JSON.parse(plaintext);
        } catch (e) {
          logger.error("Failed to decrypt/parse sealed message", { err: e });
          return void 0;
        }
      }
    }
    async function exportAccountToInspector() {
      const authSecretStorage = new AuthSecretStorage();
      const localStorageData = await authSecretStorage.get();
      if (!localStorageData) {
        console.error("No account data found in localStorage");
        return;
      }
      const encodedAccountSecret = btoa(localStorageData.accountSecret);
      window.open(
        new URL(
          `#/import/${localStorageData == null ? void 0 : localStorageData.accountID}/${encodedAccountSecret}`,
          "https://inspector.jazz.tools"
        ).toString(),
        "_blank"
      );
    }
    function listenForCmdJ() {
      if (typeof window === "undefined") return;
      const cb = (e) => {
        if (e.metaKey && e.key === "j") {
          if (confirm(
            "Are you sure you want to inspect your account using inspector.jazz.tools? This lets anyone with the secret inspector URL read your data and impersonate you."
          )) {
            exportAccountToInspector();
          }
        }
      };
      window.addEventListener("keydown", cb);
      return () => {
        window.removeEventListener("keydown", cb);
      };
    }
    function setupInspector() {
      if (typeof window === "undefined") return;
      const url2 = new URL(window.location.href);
      if (url2.hash.includes("allowJazzInspector") || false) {
        return listenForCmdJ();
      }
    }
    function getStorageOptions(storage) {
      const useIndexedDB = !storage || Array.isArray(storage) && storage.includes("indexedDB") || storage === "indexedDB";
      return { useIndexedDB };
    }
    setupInspector();
    var BrowserWebSocketPeerWithReconnection = class extends WebSocketPeerWithReconnection {
      onNetworkChange(callback) {
        const handler = () => callback(navigator.onLine);
        window.addEventListener("online", handler);
        window.addEventListener("offline", handler);
        return () => {
          window.removeEventListener("online", handler);
          window.removeEventListener("offline", handler);
        };
      }
    };
    async function setupPeers(options) {
      const crypto2 = options.crypto || await WasmCrypto.create();
      let node = void 0;
      const { useIndexedDB } = getStorageOptions(options.storage);
      const peersToLoadFrom = [];
      const storage = useIndexedDB ? await getIndexedDBStorage() : void 0;
      if (options.sync.when === "never") {
        return {
          toggleNetwork: () => {
          },
          peersToLoadFrom,
          storage,
          setNode: () => {
          },
          crypto: crypto2
        };
      }
      const wsPeer = new BrowserWebSocketPeerWithReconnection({
        peer: options.sync.peer,
        reconnectionTimeout: options.reconnectionTimeout,
        addPeer: (peer) => {
          if (node) {
            node.syncManager.addPeer(peer);
          } else {
            peersToLoadFrom.push(peer);
          }
        },
        removePeer: (peer) => {
          peersToLoadFrom.splice(peersToLoadFrom.indexOf(peer), 1);
        }
      });
      function toggleNetwork(enabled) {
        if (enabled) {
          wsPeer.enable();
        } else {
          wsPeer.disable();
        }
      }
      function setNode(value) {
        node = value;
      }
      if (options.sync.when === "always" || !options.sync.when) {
        toggleNetwork(true);
      }
      return {
        toggleNetwork,
        peersToLoadFrom,
        storage,
        setNode,
        crypto: crypto2
      };
    }
    async function createJazzBrowserGuestContext(options) {
      const { toggleNetwork, peersToLoadFrom, setNode, crypto: crypto2, storage } = await setupPeers(options);
      const context = await createAnonymousJazzContext({
        crypto: crypto2,
        peersToLoadFrom,
        storage
      });
      setNode(context.agent.node);
      options.authSecretStorage.emitUpdate(null);
      return {
        guest: context.agent,
        node: context.agent.node,
        done: () => {
          toggleNetwork(false);
          context.done();
        },
        logOut: () => {
          return context.logOut();
        }
      };
    }
    async function createJazzBrowserContext(options) {
      const { toggleNetwork, peersToLoadFrom, setNode, crypto: crypto2, storage } = await setupPeers(options);
      let unsubscribeAuthUpdate = () => {
      };
      if (options.sync.when === "signedUp") {
        let handleAuthUpdate2 = function(isAuthenticated) {
          if (isAuthenticated) {
            toggleNetwork(true);
          } else {
            toggleNetwork(false);
          }
        };
        const authSecretStorage = options.authSecretStorage;
        const credentials = options.credentials ?? await authSecretStorage.get();
        unsubscribeAuthUpdate = authSecretStorage.onUpdate(handleAuthUpdate2);
        handleAuthUpdate2(authSecretStorage.getIsAuthenticated(credentials));
      }
      const context = await createJazzContext({
        credentials: options.credentials,
        newAccountProps: options.newAccountProps,
        peersToLoadFrom,
        storage,
        crypto: crypto2,
        defaultProfileName: options.defaultProfileName,
        AccountSchema: options.AccountSchema,
        sessionProvider: provideBrowserLockSession,
        authSecretStorage: options.authSecretStorage
      });
      setNode(context.node);
      return {
        me: context.account,
        node: context.node,
        authSecretStorage: context.authSecretStorage,
        done: () => {
          toggleNetwork(false);
          unsubscribeAuthUpdate();
          context.done();
        },
        logOut: () => {
          unsubscribeAuthUpdate();
          return context.logOut();
        }
      };
    }
    function provideBrowserLockSession(accountID, crypto2) {
      let sessionDone;
      const donePromise = new Promise((resolve) => {
        sessionDone = resolve;
      });
      let resolveSession;
      const sessionPromise = new Promise((resolve) => {
        resolveSession = resolve;
      });
      void async function() {
        for (let idx = 0; idx < 100; idx++) {
          for (let retry = 0; retry < 2; retry++) {
            const sessionFinishedOrNoLock = await navigator.locks.request(
              accountID + "_" + idx,
              { ifAvailable: true },
              async (lock) => {
                if (!lock) return "noLock";
                const sessionID = localStorage.getItem(accountID + "_" + idx) || crypto2.newRandomSessionID(accountID);
                localStorage.setItem(accountID + "_" + idx, sessionID);
                resolveSession(sessionID);
                await donePromise;
                console.log("Done with lock", accountID + "_" + idx, sessionID);
                return "sessionFinished";
              }
            );
            if (sessionFinishedOrNoLock === "sessionFinished") {
              return;
            }
          }
        }
        throw new Error("Couldn't get lock on session after 100x2 tries");
      }();
      return sessionPromise.then((sessionID) => ({
        sessionID,
        sessionDone
      }));
    }
    var LocalStorageKVStore = class {
      constructor() {
      }
      async get(key) {
        return localStorage.getItem(key);
      }
      async set(key, value) {
        localStorage.setItem(key, value);
      }
      async delete(key) {
        localStorage.removeItem(key);
      }
      async clearAll() {
        localStorage.clear();
      }
    };
    var JazzBrowserContextManager = class extends JazzContextManager {
      // TODO: When the storage changes, if the user is changed, update the context
      getKvStore() {
        if (typeof window === "undefined") {
          return new InMemoryKVStore();
        } else {
          return new LocalStorageKVStore();
        }
      }
      async getNewContext(props, authProps) {
        if (props.guestMode) {
          return createJazzBrowserGuestContext({
            sync: props.sync,
            storage: props.storage,
            authSecretStorage: this.authSecretStorage
          });
        } else {
          return createJazzBrowserContext({
            sync: props.sync,
            storage: props.storage,
            AccountSchema: props.AccountSchema,
            credentials: authProps == null ? void 0 : authProps.credentials,
            newAccountProps: authProps == null ? void 0 : authProps.newAccountProps,
            defaultProfileName: props.defaultProfileName,
            authSecretStorage: this.authSecretStorage
          });
        }
      }
      propsChanged(props) {
        if (!this.props) {
          return true;
        }
        return this.props.sync.when !== props.sync.when || this.props.sync.peer !== props.sync.peer || this.props.guestMode !== props.guestMode;
      }
    };
    setupInspector();
    function createInviteLink(value, role, {
      baseURL = window.location.href.replace(/#.*$/, ""),
      valueHint
    } = {}) {
      return createInviteLink$1(value, role, baseURL, valueHint);
    }
    async function consumeInviteLinkFromWindowLocation({
      as,
      forValueHint,
      invitedObjectSchema
    }) {
      const result = await consumeInviteLink({
        inviteURL: window.location.href,
        as,
        forValueHint,
        invitedObjectSchema
      });
      if (result) {
        window.history.replaceState(
          {},
          "",
          window.location.href.replace(/#.*$/, "")
        );
      }
      return result;
    }
    var JazzContext = React.createContext(void 0);
    var JazzContextManagerContext = React.createContext(void 0);
    function getCurrentAccountFromContextManager(contextManager) {
      const context = contextManager.getCurrentValue();
      if (!context) {
        throw new Error("No context found");
      }
      return "me" in context ? context.me : context.guest;
    }
    function useJazzContext() {
      const value = reactExports.useContext(JazzContext);
      if (!value) {
        throw new Error(
          "You need to set up a JazzProvider on top of your app to use this hook."
        );
      }
      return value;
    }
    function useJazzContextManager() {
      const value = reactExports.useContext(JazzContextManagerContext);
      if (!value) {
        throw new Error(
          "You need to set up a JazzProvider on top of your app to use this hook."
        );
      }
      return value;
    }
    function useAuthSecretStorage() {
      const value = reactExports.useContext(JazzContextManagerContext);
      if (!value) {
        throw new Error(
          "You need to set up a JazzProvider on top of your app to use this useAuthSecretStorage."
        );
      }
      return value.getAuthSecretStorage();
    }
    function useIsAuthenticated() {
      const authSecretStorage = useAuthSecretStorage();
      return reactExports.useSyncExternalStore(
        reactExports.useCallback(
          (callback) => {
            return authSecretStorage.onUpdate(callback);
          },
          [authSecretStorage]
        ),
        () => authSecretStorage.isAuthenticated,
        () => authSecretStorage.isAuthenticated
      );
    }
    function useCoValueSubscription(Schema, id2, options) {
      const contextManager = useJazzContextManager();
      const createSubscription = () => {
        if (!id2) {
          return {
            subscription: null,
            contextManager,
            id: id2,
            Schema
          };
        }
        const node = contextManager.getCurrentValue().node;
        const subscription2 = new SubscriptionScope(
          node,
          (options == null ? void 0 : options.resolve) ?? true,
          id2,
          {
            ref: anySchemaToCoSchema(Schema),
            optional: true
          }
        );
        return {
          subscription: subscription2,
          contextManager,
          id: id2,
          Schema
        };
      };
      const [subscription, setSubscription] = React.useState(createSubscription);
      React.useLayoutEffect(() => {
        var _a;
        if (subscription.contextManager !== contextManager || subscription.id !== id2 || subscription.Schema !== Schema) {
          (_a = subscription.subscription) == null ? void 0 : _a.destroy();
          setSubscription(createSubscription());
        }
        return contextManager.subscribe(() => {
          var _a2;
          (_a2 = subscription.subscription) == null ? void 0 : _a2.destroy();
          setSubscription(createSubscription());
        });
      }, [Schema, id2, contextManager]);
      return subscription.subscription;
    }
    function useCoState(Schema, id2, options) {
      const subscription = useCoValueSubscription(Schema, id2, options);
      const value = React.useSyncExternalStore(
        React.useCallback(
          (callback) => {
            if (!subscription) {
              return () => {
              };
            }
            return subscription.subscribe(callback);
          },
          [subscription]
        ),
        () => subscription ? subscription.getCurrentValue() : null,
        () => subscription ? subscription.getCurrentValue() : null
      );
      return value;
    }
    function useAccountSubscription(Schema, options) {
      const contextManager = useJazzContextManager();
      const createSubscription = () => {
        const agent = getCurrentAccountFromContextManager(contextManager);
        if (agent._type === "Anonymous") {
          return {
            subscription: null,
            contextManager,
            agent
          };
        }
        const resolve = (options == null ? void 0 : options.resolve) ?? true;
        const node = contextManager.getCurrentValue().node;
        const subscription2 = new SubscriptionScope(node, resolve, agent.id, {
          ref: anySchemaToCoSchema(Schema),
          optional: true
        });
        return {
          subscription: subscription2,
          contextManager,
          Schema
        };
      };
      const [subscription, setSubscription] = React.useState(createSubscription);
      React.useLayoutEffect(() => {
        var _a;
        if (subscription.contextManager !== contextManager || subscription.Schema !== Schema) {
          (_a = subscription.subscription) == null ? void 0 : _a.destroy();
          setSubscription(createSubscription());
        }
        return contextManager.subscribe(() => {
          var _a2;
          (_a2 = subscription.subscription) == null ? void 0 : _a2.destroy();
          setSubscription(createSubscription());
        });
      }, [Schema, contextManager]);
      return subscription.subscription;
    }
    function useAccount(AccountSchema = Account, options) {
      const contextManager = useJazzContextManager();
      const subscription = useAccountSubscription(AccountSchema, options);
      const agent = getCurrentAccountFromContextManager(contextManager);
      const value = React.useSyncExternalStore(
        React.useCallback(
          (callback) => {
            if (!subscription) {
              return () => {
              };
            }
            return subscription.subscribe(callback);
          },
          [subscription]
        ),
        () => subscription ? subscription.getCurrentValue() : null,
        () => subscription ? subscription.getCurrentValue() : null
      );
      return {
        me: value,
        agent,
        logOut: contextManager.logOut
      };
    }
    function usePassphraseAuth({
      wordlist: wordlist2
    }) {
      const context = useJazzContext();
      const authSecretStorage = useAuthSecretStorage();
      if ("guest" in context) {
        throw new Error("Passphrase auth is not supported in guest mode");
      }
      const authMethod = reactExports.useMemo(() => {
        return new PassphraseAuth(
          context.node.crypto,
          context.authenticate,
          context.register,
          authSecretStorage,
          wordlist2
        );
      }, [wordlist2]);
      const passphrase = reactExports.useSyncExternalStore(
        reactExports.useCallback(
          (callback) => {
            authMethod.loadCurrentAccountPassphrase();
            return authMethod.subscribe(callback);
          },
          [authMethod]
        ),
        () => authMethod.passphrase
      );
      const isAuthenticated = useIsAuthenticated();
      return {
        state: isAuthenticated ? "signedIn" : "anonymous",
        logIn: authMethod.logIn,
        signUp: authMethod.signUp,
        registerNewAccount: authMethod.registerNewAccount,
        generateRandomPassphrase: authMethod.generateRandomPassphrase,
        passphrase
      };
    }
    /*! image-blob-reduce 4.1.0 https://github.com/nodeca/image-blob-reduce @license MIT */
    function commonjsRequire$1(path) {
      throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var pica$1 = { exports: {} };
    /*!
    
    pica
    https://github.com/nodeca/pica
    
    */
    (function(module2, exports2) {
      (function(f) {
        {
          module2.exports = f();
        }
      })(function() {
        return (/* @__PURE__ */ function() {
          function r2(e, n, t) {
            function o(i2, f) {
              if (!n[i2]) {
                if (!e[i2]) {
                  var c = "function" == typeof commonjsRequire$1 && commonjsRequire$1;
                  if (!f && c) return c(i2, true);
                  if (u) return u(i2, true);
                  var a = new Error("Cannot find module '" + i2 + "'");
                  throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i2] = { exports: {} };
                e[i2][0].call(p.exports, function(r3) {
                  var n2 = e[i2][1][r3];
                  return o(n2 || r3);
                }, p, p.exports, r2, e, n, t);
              }
              return n[i2].exports;
            }
            for (var u = "function" == typeof commonjsRequire$1 && commonjsRequire$1, i = 0; i < t.length; i++) o(t[i]);
            return o;
          }
          return r2;
        }())({ 1: [function(_dereq_, module3, exports3) {
          var Multimath = _dereq_("multimath");
          var mm_unsharp_mask = _dereq_("./mm_unsharp_mask");
          var mm_resize = _dereq_("./mm_resize");
          function MathLib(requested_features) {
            var __requested_features = requested_features || [];
            var features = {
              js: __requested_features.indexOf("js") >= 0,
              wasm: __requested_features.indexOf("wasm") >= 0
            };
            Multimath.call(this, features);
            this.features = {
              js: features.js,
              wasm: features.wasm && this.has_wasm()
            };
            this.use(mm_unsharp_mask);
            this.use(mm_resize);
          }
          MathLib.prototype = Object.create(Multimath.prototype);
          MathLib.prototype.constructor = MathLib;
          MathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {
            var result = this.resize(options, cache);
            if (options.unsharpAmount) {
              this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);
            }
            return result;
          };
          module3.exports = MathLib;
        }, { "./mm_resize": 4, "./mm_unsharp_mask": 9, "multimath": 19 }], 2: [function(_dereq_, module3, exports3) {
          function clampTo8(i) {
            return i < 0 ? 0 : i > 255 ? 255 : i;
          }
          function clampNegative(i) {
            return i >= 0 ? i : 0;
          }
          function convolveHor(src, dest, srcW, srcH, destW, filters) {
            var r2, g, b, a;
            var filterPtr, filterShift, filterSize;
            var srcPtr, srcY, destX, filterVal;
            var srcOffset = 0, destOffset = 0;
            for (srcY = 0; srcY < srcH; srcY++) {
              filterPtr = 0;
              for (destX = 0; destX < destW; destX++) {
                filterShift = filters[filterPtr++];
                filterSize = filters[filterPtr++];
                srcPtr = srcOffset + filterShift * 4 | 0;
                r2 = g = b = a = 0;
                for (; filterSize > 0; filterSize--) {
                  filterVal = filters[filterPtr++];
                  a = a + filterVal * src[srcPtr + 3] | 0;
                  b = b + filterVal * src[srcPtr + 2] | 0;
                  g = g + filterVal * src[srcPtr + 1] | 0;
                  r2 = r2 + filterVal * src[srcPtr] | 0;
                  srcPtr = srcPtr + 4 | 0;
                }
                dest[destOffset + 3] = clampNegative(a >> 7);
                dest[destOffset + 2] = clampNegative(b >> 7);
                dest[destOffset + 1] = clampNegative(g >> 7);
                dest[destOffset] = clampNegative(r2 >> 7);
                destOffset = destOffset + srcH * 4 | 0;
              }
              destOffset = (srcY + 1) * 4 | 0;
              srcOffset = (srcY + 1) * srcW * 4 | 0;
            }
          }
          function convolveVert(src, dest, srcW, srcH, destW, filters) {
            var r2, g, b, a;
            var filterPtr, filterShift, filterSize;
            var srcPtr, srcY, destX, filterVal;
            var srcOffset = 0, destOffset = 0;
            for (srcY = 0; srcY < srcH; srcY++) {
              filterPtr = 0;
              for (destX = 0; destX < destW; destX++) {
                filterShift = filters[filterPtr++];
                filterSize = filters[filterPtr++];
                srcPtr = srcOffset + filterShift * 4 | 0;
                r2 = g = b = a = 0;
                for (; filterSize > 0; filterSize--) {
                  filterVal = filters[filterPtr++];
                  a = a + filterVal * src[srcPtr + 3] | 0;
                  b = b + filterVal * src[srcPtr + 2] | 0;
                  g = g + filterVal * src[srcPtr + 1] | 0;
                  r2 = r2 + filterVal * src[srcPtr] | 0;
                  srcPtr = srcPtr + 4 | 0;
                }
                r2 >>= 7;
                g >>= 7;
                b >>= 7;
                a >>= 7;
                dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14);
                dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);
                dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);
                dest[destOffset] = clampTo8(r2 + (1 << 13) >> 14);
                destOffset = destOffset + srcH * 4 | 0;
              }
              destOffset = (srcY + 1) * 4 | 0;
              srcOffset = (srcY + 1) * srcW * 4 | 0;
            }
          }
          function convolveHorWithPre(src, dest, srcW, srcH, destW, filters) {
            var r2, g, b, a, alpha;
            var filterPtr, filterShift, filterSize;
            var srcPtr, srcY, destX, filterVal;
            var srcOffset = 0, destOffset = 0;
            for (srcY = 0; srcY < srcH; srcY++) {
              filterPtr = 0;
              for (destX = 0; destX < destW; destX++) {
                filterShift = filters[filterPtr++];
                filterSize = filters[filterPtr++];
                srcPtr = srcOffset + filterShift * 4 | 0;
                r2 = g = b = a = 0;
                for (; filterSize > 0; filterSize--) {
                  filterVal = filters[filterPtr++];
                  alpha = src[srcPtr + 3];
                  a = a + filterVal * alpha | 0;
                  b = b + filterVal * src[srcPtr + 2] * alpha | 0;
                  g = g + filterVal * src[srcPtr + 1] * alpha | 0;
                  r2 = r2 + filterVal * src[srcPtr] * alpha | 0;
                  srcPtr = srcPtr + 4 | 0;
                }
                b = b / 255 | 0;
                g = g / 255 | 0;
                r2 = r2 / 255 | 0;
                dest[destOffset + 3] = clampNegative(a >> 7);
                dest[destOffset + 2] = clampNegative(b >> 7);
                dest[destOffset + 1] = clampNegative(g >> 7);
                dest[destOffset] = clampNegative(r2 >> 7);
                destOffset = destOffset + srcH * 4 | 0;
              }
              destOffset = (srcY + 1) * 4 | 0;
              srcOffset = (srcY + 1) * srcW * 4 | 0;
            }
          }
          function convolveVertWithPre(src, dest, srcW, srcH, destW, filters) {
            var r2, g, b, a;
            var filterPtr, filterShift, filterSize;
            var srcPtr, srcY, destX, filterVal;
            var srcOffset = 0, destOffset = 0;
            for (srcY = 0; srcY < srcH; srcY++) {
              filterPtr = 0;
              for (destX = 0; destX < destW; destX++) {
                filterShift = filters[filterPtr++];
                filterSize = filters[filterPtr++];
                srcPtr = srcOffset + filterShift * 4 | 0;
                r2 = g = b = a = 0;
                for (; filterSize > 0; filterSize--) {
                  filterVal = filters[filterPtr++];
                  a = a + filterVal * src[srcPtr + 3] | 0;
                  b = b + filterVal * src[srcPtr + 2] | 0;
                  g = g + filterVal * src[srcPtr + 1] | 0;
                  r2 = r2 + filterVal * src[srcPtr] | 0;
                  srcPtr = srcPtr + 4 | 0;
                }
                r2 >>= 7;
                g >>= 7;
                b >>= 7;
                a >>= 7;
                a = clampTo8(a + (1 << 13) >> 14);
                if (a > 0) {
                  r2 = r2 * 255 / a | 0;
                  g = g * 255 / a | 0;
                  b = b * 255 / a | 0;
                }
                dest[destOffset + 3] = a;
                dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);
                dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);
                dest[destOffset] = clampTo8(r2 + (1 << 13) >> 14);
                destOffset = destOffset + srcH * 4 | 0;
              }
              destOffset = (srcY + 1) * 4 | 0;
              srcOffset = (srcY + 1) * srcW * 4 | 0;
            }
          }
          module3.exports = {
            convolveHor,
            convolveVert,
            convolveHorWithPre,
            convolveVertWithPre
          };
        }, {}], 3: [function(_dereq_, module3, exports3) {
          module3.exports = "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";
        }, {}], 4: [function(_dereq_, module3, exports3) {
          module3.exports = {
            name: "resize",
            fn: _dereq_("./resize"),
            wasm_fn: _dereq_("./resize_wasm"),
            wasm_src: _dereq_("./convolve_wasm_base64")
          };
        }, { "./convolve_wasm_base64": 3, "./resize": 5, "./resize_wasm": 8 }], 5: [function(_dereq_, module3, exports3) {
          var createFilters = _dereq_("./resize_filter_gen");
          var _require = _dereq_("./convolve"), convolveHor = _require.convolveHor, convolveVert = _require.convolveVert, convolveHorWithPre = _require.convolveHorWithPre, convolveVertWithPre = _require.convolveVertWithPre;
          function hasAlpha(src, width, height) {
            var ptr = 3, len = width * height * 4 | 0;
            while (ptr < len) {
              if (src[ptr] !== 255) return true;
              ptr = ptr + 4 | 0;
            }
            return false;
          }
          function resetAlpha(dst, width, height) {
            var ptr = 3, len = width * height * 4 | 0;
            while (ptr < len) {
              dst[ptr] = 255;
              ptr = ptr + 4 | 0;
            }
          }
          module3.exports = function resize(options) {
            var src = options.src;
            var srcW = options.width;
            var srcH = options.height;
            var destW = options.toWidth;
            var destH = options.toHeight;
            var scaleX = options.scaleX || options.toWidth / options.width;
            var scaleY = options.scaleY || options.toHeight / options.height;
            var offsetX = options.offsetX || 0;
            var offsetY = options.offsetY || 0;
            var dest = options.dest || new Uint8Array(destW * destH * 4);
            var filter = typeof options.filter === "undefined" ? "mks2013" : options.filter;
            var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);
            var tmp = new Uint16Array(destW * srcH * 4);
            if (hasAlpha(src, srcW, srcH)) {
              convolveHorWithPre(src, tmp, srcW, srcH, destW, filtersX);
              convolveVertWithPre(tmp, dest, srcH, destW, destH, filtersY);
            } else {
              convolveHor(src, tmp, srcW, srcH, destW, filtersX);
              convolveVert(tmp, dest, srcH, destW, destH, filtersY);
              resetAlpha(dest, destW, destH);
            }
            return dest;
          };
        }, { "./convolve": 2, "./resize_filter_gen": 6 }], 6: [function(_dereq_, module3, exports3) {
          var FILTER_INFO = _dereq_("./resize_filter_info");
          var FIXED_FRAC_BITS = 14;
          function toFixedPoint(num) {
            return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));
          }
          module3.exports = function resizeFilterGen(filter, srcSize, destSize, scale, offset) {
            var filterFunction = FILTER_INFO.filter[filter].fn;
            var scaleInverted = 1 / scale;
            var scaleClamped = Math.min(1, scale);
            var srcWindow = FILTER_INFO.filter[filter].win / scaleClamped;
            var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;
            var leftNotEmpty, rightNotEmpty, filterShift, filterSize;
            var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);
            var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);
            var packedFilterPtr = 0;
            var slowCopy = !packedFilter.subarray || !packedFilter.set;
            for (destPixel = 0; destPixel < destSize; destPixel++) {
              srcPixel = (destPixel + 0.5) * scaleInverted + offset;
              srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));
              srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));
              filterElementSize = srcLast - srcFirst + 1;
              floatFilter = new Float32Array(filterElementSize);
              fxpFilter = new Int16Array(filterElementSize);
              total = 0;
              for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {
                floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);
                total += floatVal;
                floatFilter[idx] = floatVal;
              }
              filterTotal = 0;
              for (idx = 0; idx < floatFilter.length; idx++) {
                filterVal = floatFilter[idx] / total;
                filterTotal += filterVal;
                fxpFilter[idx] = toFixedPoint(filterVal);
              }
              fxpFilter[destSize >> 1] += toFixedPoint(1 - filterTotal);
              leftNotEmpty = 0;
              while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {
                leftNotEmpty++;
              }
              if (leftNotEmpty < fxpFilter.length) {
                rightNotEmpty = fxpFilter.length - 1;
                while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {
                  rightNotEmpty--;
                }
                filterShift = srcFirst + leftNotEmpty;
                filterSize = rightNotEmpty - leftNotEmpty + 1;
                packedFilter[packedFilterPtr++] = filterShift;
                packedFilter[packedFilterPtr++] = filterSize;
                if (!slowCopy) {
                  packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);
                  packedFilterPtr += filterSize;
                } else {
                  for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {
                    packedFilter[packedFilterPtr++] = fxpFilter[idx];
                  }
                }
              } else {
                packedFilter[packedFilterPtr++] = 0;
                packedFilter[packedFilterPtr++] = 0;
              }
            }
            return packedFilter;
          };
        }, { "./resize_filter_info": 7 }], 7: [function(_dereq_, module3, exports3) {
          var filter = {
            // Nearest neibor
            box: {
              win: 0.5,
              fn: function fn(x) {
                if (x < 0) x = -x;
                return x < 0.5 ? 1 : 0;
              }
            },
            // // Hamming
            hamming: {
              win: 1,
              fn: function fn(x) {
                if (x < 0) x = -x;
                if (x >= 1) {
                  return 0;
                }
                if (x < 11920929e-14) {
                  return 1;
                }
                var xpi = x * Math.PI;
                return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1));
              }
            },
            // Lanczos, win = 2
            lanczos2: {
              win: 2,
              fn: function fn(x) {
                if (x < 0) x = -x;
                if (x >= 2) {
                  return 0;
                }
                if (x < 11920929e-14) {
                  return 1;
                }
                var xpi = x * Math.PI;
                return Math.sin(xpi) / xpi * Math.sin(xpi / 2) / (xpi / 2);
              }
            },
            // Lanczos, win = 3
            lanczos3: {
              win: 3,
              fn: function fn(x) {
                if (x < 0) x = -x;
                if (x >= 3) {
                  return 0;
                }
                if (x < 11920929e-14) {
                  return 1;
                }
                var xpi = x * Math.PI;
                return Math.sin(xpi) / xpi * Math.sin(xpi / 3) / (xpi / 3);
              }
            },
            // Magic Kernel Sharp 2013, win = 2.5
            // http://johncostella.com/magic/
            mks2013: {
              win: 2.5,
              fn: function fn(x) {
                if (x < 0) x = -x;
                if (x >= 2.5) {
                  return 0;
                }
                if (x >= 1.5) {
                  return -0.125 * (x - 2.5) * (x - 2.5);
                }
                if (x >= 0.5) {
                  return 0.25 * (4 * x * x - 11 * x + 7);
                }
                return 1.0625 - 1.75 * x * x;
              }
            }
          };
          module3.exports = {
            filter,
            // Legacy mapping
            f2q: {
              box: 0,
              hamming: 1,
              lanczos2: 2,
              lanczos3: 3
            },
            q2f: ["box", "hamming", "lanczos2", "lanczos3"]
          };
        }, {}], 8: [function(_dereq_, module3, exports3) {
          var createFilters = _dereq_("./resize_filter_gen");
          function hasAlpha(src, width, height) {
            var ptr = 3, len = width * height * 4 | 0;
            while (ptr < len) {
              if (src[ptr] !== 255) return true;
              ptr = ptr + 4 | 0;
            }
            return false;
          }
          function resetAlpha(dst, width, height) {
            var ptr = 3, len = width * height * 4 | 0;
            while (ptr < len) {
              dst[ptr] = 255;
              ptr = ptr + 4 | 0;
            }
          }
          function asUint8Array(src) {
            return new Uint8Array(src.buffer, 0, src.byteLength);
          }
          var IS_LE = true;
          try {
            IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
          } catch (__) {
          }
          function copyInt16asLE(src, target, target_offset) {
            if (IS_LE) {
              target.set(asUint8Array(src), target_offset);
              return;
            }
            for (var ptr = target_offset, i = 0; i < src.length; i++) {
              var data2 = src[i];
              target[ptr++] = data2 & 255;
              target[ptr++] = data2 >> 8 & 255;
            }
          }
          module3.exports = function resize_wasm(options) {
            var src = options.src;
            var srcW = options.width;
            var srcH = options.height;
            var destW = options.toWidth;
            var destH = options.toHeight;
            var scaleX = options.scaleX || options.toWidth / options.width;
            var scaleY = options.scaleY || options.toHeight / options.height;
            var offsetX = options.offsetX || 0;
            var offsetY = options.offsetY || 0;
            var dest = options.dest || new Uint8Array(destW * destH * 4);
            var filter = typeof options.filter === "undefined" ? "mks2013" : options.filter;
            var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);
            var src_offset = 0;
            var src_size = Math.max(src.byteLength, dest.byteLength);
            var tmp_offset = this.__align(src_offset + src_size);
            var tmp_size = srcH * destW * 4 * 2;
            var filtersX_offset = this.__align(tmp_offset + tmp_size);
            var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);
            var alloc_bytes = filtersY_offset + filtersY.byteLength;
            var instance = this.__instance("resize", alloc_bytes);
            var mem = new Uint8Array(this.__memory.buffer);
            var mem32 = new Uint32Array(this.__memory.buffer);
            var src32 = new Uint32Array(src.buffer);
            mem32.set(src32);
            copyInt16asLE(filtersX, mem, filtersX_offset);
            copyInt16asLE(filtersY, mem, filtersY_offset);
            var fn = instance.exports.convolveHV || instance.exports._convolveHV;
            if (hasAlpha(src, srcW, srcH)) {
              fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 1);
            } else {
              fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 0);
              resetAlpha(dest, destW, destH);
            }
            var dest32 = new Uint32Array(dest.buffer);
            dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW));
            return dest;
          };
        }, { "./resize_filter_gen": 6 }], 9: [function(_dereq_, module3, exports3) {
          module3.exports = {
            name: "unsharp_mask",
            fn: _dereq_("./unsharp_mask"),
            wasm_fn: _dereq_("./unsharp_mask_wasm"),
            wasm_src: _dereq_("./unsharp_mask_wasm_base64")
          };
        }, { "./unsharp_mask": 10, "./unsharp_mask_wasm": 11, "./unsharp_mask_wasm_base64": 12 }], 10: [function(_dereq_, module3, exports3) {
          var glur_mono16 = _dereq_("glur/mono16");
          function hsv_v16(img, width, height) {
            var size = width * height;
            var out = new Uint16Array(size);
            var r2, g, b, max;
            for (var i = 0; i < size; i++) {
              r2 = img[4 * i];
              g = img[4 * i + 1];
              b = img[4 * i + 2];
              max = r2 >= g && r2 >= b ? r2 : g >= b && g >= r2 ? g : b;
              out[i] = max << 8;
            }
            return out;
          }
          module3.exports = function unsharp(img, width, height, amount, radius, threshold) {
            var v1, v2, vmul;
            var diff, iTimes4;
            if (amount === 0 || radius < 0.5) {
              return;
            }
            if (radius > 2) {
              radius = 2;
            }
            var brightness = hsv_v16(img, width, height);
            var blured = new Uint16Array(brightness);
            glur_mono16(blured, width, height, radius);
            var amountFp = amount / 100 * 4096 + 0.5 | 0;
            var thresholdFp = threshold << 8;
            var size = width * height;
            for (var i = 0; i < size; i++) {
              v1 = brightness[i];
              diff = v1 - blured[i];
              if (Math.abs(diff) >= thresholdFp) {
                v2 = v1 + (amountFp * diff + 2048 >> 12);
                v2 = v2 > 65280 ? 65280 : v2;
                v2 = v2 < 0 ? 0 : v2;
                v1 = v1 !== 0 ? v1 : 1;
                vmul = (v2 << 12) / v1 | 0;
                iTimes4 = i * 4;
                img[iTimes4] = img[iTimes4] * vmul + 2048 >> 12;
                img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 2048 >> 12;
                img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 2048 >> 12;
              }
            }
          };
        }, { "glur/mono16": 18 }], 11: [function(_dereq_, module3, exports3) {
          module3.exports = function unsharp(img, width, height, amount, radius, threshold) {
            if (amount === 0 || radius < 0.5) {
              return;
            }
            if (radius > 2) {
              radius = 2;
            }
            var pixels = width * height;
            var img_bytes_cnt = pixels * 4;
            var hsv_bytes_cnt = pixels * 2;
            var blur_bytes_cnt = pixels * 2;
            var blur_line_byte_cnt = Math.max(width, height) * 4;
            var blur_coeffs_byte_cnt = 8 * 4;
            var img_offset = 0;
            var hsv_offset = img_bytes_cnt;
            var blur_offset = hsv_offset + hsv_bytes_cnt;
            var blur_tmp_offset = blur_offset + blur_bytes_cnt;
            var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;
            var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;
            var instance = this.__instance("unsharp_mask", img_bytes_cnt + hsv_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {
              exp: Math.exp
            });
            var img32 = new Uint32Array(img.buffer);
            var mem32 = new Uint32Array(this.__memory.buffer);
            mem32.set(img32);
            var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;
            fn(img_offset, hsv_offset, width, height);
            fn = instance.exports.blurMono16 || instance.exports._blurMono16;
            fn(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius);
            fn = instance.exports.unsharp || instance.exports._unsharp;
            fn(img_offset, img_offset, hsv_offset, blur_offset, width, height, amount, threshold);
            img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));
          };
        }, {}], 12: [function(_dereq_, module3, exports3) {
          module3.exports = "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";
        }, {}], 13: [function(_dereq_, module3, exports3) {
          var GC_INTERVAL = 100;
          function Pool(create, idle) {
            this.create = create;
            this.available = [];
            this.acquired = {};
            this.lastId = 1;
            this.timeoutId = 0;
            this.idle = idle || 2e3;
          }
          Pool.prototype.acquire = function() {
            var _this = this;
            var resource;
            if (this.available.length !== 0) {
              resource = this.available.pop();
            } else {
              resource = this.create();
              resource.id = this.lastId++;
              resource.release = function() {
                return _this.release(resource);
              };
            }
            this.acquired[resource.id] = resource;
            return resource;
          };
          Pool.prototype.release = function(resource) {
            var _this2 = this;
            delete this.acquired[resource.id];
            resource.lastUsed = Date.now();
            this.available.push(resource);
            if (this.timeoutId === 0) {
              this.timeoutId = setTimeout(function() {
                return _this2.gc();
              }, GC_INTERVAL);
            }
          };
          Pool.prototype.gc = function() {
            var _this3 = this;
            var now = Date.now();
            this.available = this.available.filter(function(resource) {
              if (now - resource.lastUsed > _this3.idle) {
                resource.destroy();
                return false;
              }
              return true;
            });
            if (this.available.length !== 0) {
              this.timeoutId = setTimeout(function() {
                return _this3.gc();
              }, GC_INTERVAL);
            } else {
              this.timeoutId = 0;
            }
          };
          module3.exports = Pool;
        }, {}], 14: [function(_dereq_, module3, exports3) {
          var MIN_INNER_TILE_SIZE = 2;
          module3.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {
            var scaleX = toWidth / fromWidth;
            var scaleY = toHeight / fromHeight;
            var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize;
            if (minScale > 0.5) return [[toWidth, toHeight]];
            var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale));
            if (stageCount <= 1) return [[toWidth, toHeight]];
            var result = [];
            for (var i = 0; i < stageCount; i++) {
              var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));
              var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));
              result.push([width, height]);
            }
            return result;
          };
        }, {}], 15: [function(_dereq_, module3, exports3) {
          var PIXEL_EPSILON = 1e-5;
          function pixelFloor(x) {
            var nearest = Math.round(x);
            if (Math.abs(x - nearest) < PIXEL_EPSILON) {
              return nearest;
            }
            return Math.floor(x);
          }
          function pixelCeil(x) {
            var nearest = Math.round(x);
            if (Math.abs(x - nearest) < PIXEL_EPSILON) {
              return nearest;
            }
            return Math.ceil(x);
          }
          module3.exports = function createRegions(options) {
            var scaleX = options.toWidth / options.width;
            var scaleY = options.toHeight / options.height;
            var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;
            var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder;
            if (innerTileWidth < 1 || innerTileHeight < 1) {
              throw new Error("Internal error in pica: target tile width/height is too small.");
            }
            var x, y;
            var innerX, innerY, toTileWidth, toTileHeight;
            var tiles = [];
            var tile;
            for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {
              for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {
                x = innerX - options.destTileBorder;
                if (x < 0) {
                  x = 0;
                }
                toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;
                if (x + toTileWidth >= options.toWidth) {
                  toTileWidth = options.toWidth - x;
                }
                y = innerY - options.destTileBorder;
                if (y < 0) {
                  y = 0;
                }
                toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;
                if (y + toTileHeight >= options.toHeight) {
                  toTileHeight = options.toHeight - y;
                }
                tile = {
                  toX: x,
                  toY: y,
                  toWidth: toTileWidth,
                  toHeight: toTileHeight,
                  toInnerX: innerX,
                  toInnerY: innerY,
                  toInnerWidth: innerTileWidth,
                  toInnerHeight: innerTileHeight,
                  offsetX: x / scaleX - pixelFloor(x / scaleX),
                  offsetY: y / scaleY - pixelFloor(y / scaleY),
                  scaleX,
                  scaleY,
                  x: pixelFloor(x / scaleX),
                  y: pixelFloor(y / scaleY),
                  width: pixelCeil(toTileWidth / scaleX),
                  height: pixelCeil(toTileHeight / scaleY)
                };
                tiles.push(tile);
              }
            }
            return tiles;
          };
        }, {}], 16: [function(_dereq_, module3, exports3) {
          function objClass(obj) {
            return Object.prototype.toString.call(obj);
          }
          module3.exports.isCanvas = function isCanvas(element) {
            var cname = objClass(element);
            return cname === "[object HTMLCanvasElement]" || cname === "[object OffscreenCanvas]" || cname === "[object Canvas]";
          };
          module3.exports.isImage = function isImage(element) {
            return objClass(element) === "[object HTMLImageElement]";
          };
          module3.exports.isImageBitmap = function isImageBitmap(element) {
            return objClass(element) === "[object ImageBitmap]";
          };
          module3.exports.limiter = function limiter(concurrency) {
            var active = 0, queue = [];
            function roll() {
              if (active < concurrency && queue.length) {
                active++;
                queue.shift()();
              }
            }
            return function limit(fn) {
              return new Promise(function(resolve, reject) {
                queue.push(function() {
                  fn().then(function(result) {
                    resolve(result);
                    active--;
                    roll();
                  }, function(err2) {
                    reject(err2);
                    active--;
                    roll();
                  });
                });
                roll();
              });
            };
          };
          module3.exports.cib_quality_name = function cib_quality_name(num) {
            switch (num) {
              case 0:
                return "pixelated";
              case 1:
                return "low";
              case 2:
                return "medium";
            }
            return "high";
          };
          module3.exports.cib_support = function cib_support(createCanvas) {
            return Promise.resolve().then(function() {
              if (typeof createImageBitmap === "undefined") {
                return false;
              }
              var c = createCanvas(100, 100);
              return createImageBitmap(c, 0, 0, 100, 100, {
                resizeWidth: 10,
                resizeHeight: 10,
                resizeQuality: "high"
              }).then(function(bitmap) {
                var status = bitmap.width === 10;
                bitmap.close();
                c = null;
                return status;
              });
            })["catch"](function() {
              return false;
            });
          };
          module3.exports.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {
            return new Promise(function(resolve, reject) {
              if (typeof OffscreenCanvas === "undefined") {
                resolve(false);
                return;
              }
              function workerPayload(self2) {
                if (typeof createImageBitmap === "undefined") {
                  self2.postMessage(false);
                  return;
                }
                Promise.resolve().then(function() {
                  var canvas2 = new OffscreenCanvas(10, 10);
                  var ctx = canvas2.getContext("2d");
                  ctx.rect(0, 0, 1, 1);
                  return createImageBitmap(canvas2, 0, 0, 1, 1);
                }).then(function() {
                  return self2.postMessage(true);
                }, function() {
                  return self2.postMessage(false);
                });
              }
              var code = btoa("(".concat(workerPayload.toString(), ")(self);"));
              var w = new Worker("data:text/javascript;base64,".concat(code));
              w.onmessage = function(ev) {
                return resolve(ev.data);
              };
              w.onerror = reject;
            }).then(function(result) {
              return result;
            }, function() {
              return false;
            });
          };
          module3.exports.can_use_canvas = function can_use_canvas(createCanvas) {
            var usable = false;
            try {
              var canvas2 = createCanvas(2, 1);
              var ctx = canvas2.getContext("2d");
              var d = ctx.createImageData(2, 1);
              d.data[0] = 12;
              d.data[1] = 23;
              d.data[2] = 34;
              d.data[3] = 255;
              d.data[4] = 45;
              d.data[5] = 56;
              d.data[6] = 67;
              d.data[7] = 255;
              ctx.putImageData(d, 0, 0);
              d = null;
              d = ctx.getImageData(0, 0, 2, 1);
              if (d.data[0] === 12 && d.data[1] === 23 && d.data[2] === 34 && d.data[3] === 255 && d.data[4] === 45 && d.data[5] === 56 && d.data[6] === 67 && d.data[7] === 255) {
                usable = true;
              }
            } catch (err2) {
            }
            return usable;
          };
          module3.exports.cib_can_use_region = function cib_can_use_region() {
            return new Promise(function(resolve) {
              if (typeof createImageBitmap === "undefined") {
                resolve(false);
                return;
              }
              var image = new Image();
              image.src = "data:image/jpeg;base64,/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRcZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRAf/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z";
              image.onload = function() {
                createImageBitmap(image, 0, 0, image.width, image.height).then(function(bitmap) {
                  if (bitmap.width === image.width && bitmap.height === image.height) {
                    resolve(true);
                  } else {
                    resolve(false);
                  }
                }, function() {
                  return resolve(false);
                });
              };
              image.onerror = function() {
                return resolve(false);
              };
            });
          };
        }, {}], 17: [function(_dereq_, module3, exports3) {
          module3.exports = function() {
            var MathLib = _dereq_("./mathlib");
            var mathLib;
            onmessage = function onmessage2(ev) {
              var tileOpts = ev.data.opts;
              if (!tileOpts.src && tileOpts.srcBitmap) {
                var canvas2 = new OffscreenCanvas(tileOpts.width, tileOpts.height);
                var ctx = canvas2.getContext("2d");
                ctx.drawImage(tileOpts.srcBitmap, 0, 0);
                tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data;
                canvas2.width = canvas2.height = 0;
                canvas2 = null;
                tileOpts.srcBitmap.close();
                tileOpts.srcBitmap = null;
              }
              if (!mathLib) mathLib = new MathLib(ev.data.features);
              var data2 = mathLib.resizeAndUnsharp(tileOpts);
              {
                postMessage({
                  data: data2
                }, [data2.buffer]);
              }
            };
          };
        }, { "./mathlib": 1 }], 18: [function(_dereq_, module3, exports3) {
          var a0, a1, a2, a3, b1, b2, left_corner, right_corner;
          function gaussCoef(sigma) {
            if (sigma < 0.5) {
              sigma = 0.5;
            }
            var a = Math.exp(0.726 * 0.726) / sigma, g1 = Math.exp(-a), g2 = Math.exp(-2 * a), k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);
            a0 = k;
            a1 = k * (a - 1) * g1;
            a2 = k * (a + 1) * g1;
            a3 = -k * g2;
            b1 = 2 * g1;
            b2 = -g2;
            left_corner = (a0 + a1) / (1 - b1 - b2);
            right_corner = (a2 + a3) / (1 - b1 - b2);
            return new Float32Array([a0, a1, a2, a3, b1, b2, left_corner, right_corner]);
          }
          function convolveMono16(src, out, line, coeff, width, height) {
            var prev_src, curr_src, curr_out, prev_out, prev_prev_out;
            var src_index, out_index, line_index;
            var i, j;
            var coeff_a0, coeff_a1, coeff_b1, coeff_b2;
            for (i = 0; i < height; i++) {
              src_index = i * width;
              out_index = i;
              line_index = 0;
              prev_src = src[src_index];
              prev_prev_out = prev_src * coeff[6];
              prev_out = prev_prev_out;
              coeff_a0 = coeff[0];
              coeff_a1 = coeff[1];
              coeff_b1 = coeff[4];
              coeff_b2 = coeff[5];
              for (j = 0; j < width; j++) {
                curr_src = src[src_index];
                curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
                prev_prev_out = prev_out;
                prev_out = curr_out;
                prev_src = curr_src;
                line[line_index] = prev_out;
                line_index++;
                src_index++;
              }
              src_index--;
              line_index--;
              out_index += height * (width - 1);
              prev_src = src[src_index];
              prev_prev_out = prev_src * coeff[7];
              prev_out = prev_prev_out;
              curr_src = prev_src;
              coeff_a0 = coeff[2];
              coeff_a1 = coeff[3];
              for (j = width - 1; j >= 0; j--) {
                curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
                prev_prev_out = prev_out;
                prev_out = curr_out;
                prev_src = curr_src;
                curr_src = src[src_index];
                out[out_index] = line[line_index] + prev_out;
                src_index--;
                line_index--;
                out_index -= height;
              }
            }
          }
          function blurMono16(src, width, height, radius) {
            if (!radius) {
              return;
            }
            var out = new Uint16Array(src.length), tmp_line = new Float32Array(Math.max(width, height));
            var coeff = gaussCoef(radius);
            convolveMono16(src, out, tmp_line, coeff, width, height);
            convolveMono16(out, src, tmp_line, coeff, height, width);
          }
          module3.exports = blurMono16;
        }, {}], 19: [function(_dereq_, module3, exports3) {
          var assign = _dereq_("object-assign");
          var base64decode = _dereq_("./lib/base64decode");
          var hasWebAssembly = _dereq_("./lib/wa_detect");
          var DEFAULT_OPTIONS = {
            js: true,
            wasm: true
          };
          function MultiMath(options) {
            if (!(this instanceof MultiMath)) return new MultiMath(options);
            var opts = assign({}, DEFAULT_OPTIONS, options || {});
            this.options = opts;
            this.__cache = {};
            this.__init_promise = null;
            this.__modules = opts.modules || {};
            this.__memory = null;
            this.__wasm = {};
            this.__isLE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
            if (!this.options.js && !this.options.wasm) {
              throw new Error('mathlib: at least "js" or "wasm" should be enabled');
            }
          }
          MultiMath.prototype.has_wasm = hasWebAssembly;
          MultiMath.prototype.use = function(module4) {
            this.__modules[module4.name] = module4;
            if (this.options.wasm && this.has_wasm() && module4.wasm_fn) {
              this[module4.name] = module4.wasm_fn;
            } else {
              this[module4.name] = module4.fn;
            }
            return this;
          };
          MultiMath.prototype.init = function() {
            if (this.__init_promise) return this.__init_promise;
            if (!this.options.js && this.options.wasm && !this.has_wasm()) {
              return Promise.reject(new Error(`mathlib: only "wasm" was enabled, but it's not supported`));
            }
            var self2 = this;
            this.__init_promise = Promise.all(Object.keys(self2.__modules).map(function(name) {
              var module4 = self2.__modules[name];
              if (!self2.options.wasm || !self2.has_wasm() || !module4.wasm_fn) return null;
              if (self2.__wasm[name]) return null;
              return WebAssembly.compile(self2.__base64decode(module4.wasm_src)).then(function(m) {
                self2.__wasm[name] = m;
              });
            })).then(function() {
              return self2;
            });
            return this.__init_promise;
          };
          MultiMath.prototype.__base64decode = base64decode;
          MultiMath.prototype.__reallocate = function mem_grow_to(bytes) {
            if (!this.__memory) {
              this.__memory = new WebAssembly.Memory({
                initial: Math.ceil(bytes / (64 * 1024))
              });
              return this.__memory;
            }
            var mem_size = this.__memory.buffer.byteLength;
            if (mem_size < bytes) {
              this.__memory.grow(Math.ceil((bytes - mem_size) / (64 * 1024)));
            }
            return this.__memory;
          };
          MultiMath.prototype.__instance = function instance(name, memsize, env_extra) {
            if (memsize) this.__reallocate(memsize);
            if (!this.__wasm[name]) {
              var module4 = this.__modules[name];
              this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module4.wasm_src));
            }
            if (!this.__cache[name]) {
              var env_base = {
                memoryBase: 0,
                memory: this.__memory,
                tableBase: 0,
                table: new WebAssembly.Table({ initial: 0, element: "anyfunc" })
              };
              this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {
                env: assign(env_base, env_extra || {})
              });
            }
            return this.__cache[name];
          };
          MultiMath.prototype.__align = function align(number2, base) {
            base = base || 8;
            var reminder = number2 % base;
            return number2 + (reminder ? base - reminder : 0);
          };
          module3.exports = MultiMath;
        }, { "./lib/base64decode": 20, "./lib/wa_detect": 21, "object-assign": 22 }], 20: [function(_dereq_, module3, exports3) {
          var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          module3.exports = function base64decode(str) {
            var input = str.replace(/[\r\n=]/g, ""), max = input.length;
            var out = new Uint8Array(max * 3 >> 2);
            var bits = 0;
            var ptr = 0;
            for (var idx = 0; idx < max; idx++) {
              if (idx % 4 === 0 && idx) {
                out[ptr++] = bits >> 16 & 255;
                out[ptr++] = bits >> 8 & 255;
                out[ptr++] = bits & 255;
              }
              bits = bits << 6 | BASE64_MAP.indexOf(input.charAt(idx));
            }
            var tailbits = max % 4 * 6;
            if (tailbits === 0) {
              out[ptr++] = bits >> 16 & 255;
              out[ptr++] = bits >> 8 & 255;
              out[ptr++] = bits & 255;
            } else if (tailbits === 18) {
              out[ptr++] = bits >> 10 & 255;
              out[ptr++] = bits >> 2 & 255;
            } else if (tailbits === 12) {
              out[ptr++] = bits >> 4 & 255;
            }
            return out;
          };
        }, {}], 21: [function(_dereq_, module3, exports3) {
          var wa;
          module3.exports = function hasWebAssembly() {
            if (typeof wa !== "undefined") return wa;
            wa = false;
            if (typeof WebAssembly === "undefined") return wa;
            try {
              var bin2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]);
              var module4 = new WebAssembly.Module(bin2);
              var instance = new WebAssembly.Instance(module4, {});
              if (instance.exports.test(4) !== 0) wa = true;
              return wa;
            } catch (__) {
            }
            return wa;
          };
        }, {}], 22: [function(_dereq_, module3, exports3) {
          var getOwnPropertySymbols = Object.getOwnPropertySymbols;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject(val) {
            if (val === null || val === void 0) {
              throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
          }
          function shouldUseNative() {
            try {
              if (!Object.assign) {
                return false;
              }
              var test1 = new String("abc");
              test1[5] = "de";
              if (Object.getOwnPropertyNames(test1)[0] === "5") {
                return false;
              }
              var test2 = {};
              for (var i = 0; i < 10; i++) {
                test2["_" + String.fromCharCode(i)] = i;
              }
              var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                return test2[n];
              });
              if (order2.join("") !== "0123456789") {
                return false;
              }
              var test3 = {};
              "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                test3[letter] = letter;
              });
              if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                return false;
              }
              return true;
            } catch (err2) {
              return false;
            }
          }
          module3.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
              from = Object(arguments[s]);
              for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                  to[key] = from[key];
                }
              }
              if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                  if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                  }
                }
              }
            }
            return to;
          };
        }, {}], 23: [function(_dereq_, module3, exports3) {
          var bundleFn = arguments[3];
          var sources = arguments[4];
          var cache = arguments[5];
          var stringify = JSON.stringify;
          module3.exports = function(fn, options) {
            var wkey;
            var cacheKeys = Object.keys(cache);
            for (var i = 0, l = cacheKeys.length; i < l; i++) {
              var key = cacheKeys[i];
              var exp = cache[key].exports;
              if (exp === fn || exp && exp.default === fn) {
                wkey = key;
                break;
              }
            }
            if (!wkey) {
              wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
              var wcache = {};
              for (var i = 0, l = cacheKeys.length; i < l; i++) {
                var key = cacheKeys[i];
                wcache[key] = key;
              }
              sources[wkey] = [
                "function(require,module,exports){" + fn + "(self); }",
                wcache
              ];
            }
            var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
            var scache = {};
            scache[wkey] = wkey;
            sources[skey] = [
              "function(require,module,exports){var f = require(" + stringify(wkey) + ");(f.default ? f.default : f)(self);}",
              scache
            ];
            var workerSources = {};
            resolveSources(skey);
            function resolveSources(key2) {
              workerSources[key2] = true;
              for (var depPath in sources[key2][1]) {
                var depKey = sources[key2][1][depPath];
                if (!workerSources[depKey]) {
                  resolveSources(depKey);
                }
              }
            }
            var src = "(" + bundleFn + ")({" + Object.keys(workerSources).map(function(key2) {
              return stringify(key2) + ":[" + sources[key2][0] + "," + stringify(sources[key2][1]) + "]";
            }).join(",") + "},{},[" + stringify(skey) + "])";
            var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
            var blob = new Blob([src], { type: "text/javascript" });
            if (options && options.bare) {
              return blob;
            }
            var workerUrl = URL2.createObjectURL(blob);
            var worker = new Worker(workerUrl);
            worker.objectURL = workerUrl;
            return worker;
          };
        }, {}], "/index.js": [function(_dereq_, module3, exports3) {
          function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
          }
          function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }
          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }
          function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
              for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
              }
            } catch (err2) {
              _d = true;
              _e = err2;
            } finally {
              try {
                if (!_n && _i["return"] != null) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }
            return _arr;
          }
          function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
          }
          var assign = _dereq_("object-assign");
          var webworkify = _dereq_("webworkify");
          var MathLib = _dereq_("./lib/mathlib");
          var Pool = _dereq_("./lib/pool");
          var utils2 = _dereq_("./lib/utils");
          var worker = _dereq_("./lib/worker");
          var createStages = _dereq_("./lib/stepper");
          var createRegions = _dereq_("./lib/tiler");
          var filter_info = _dereq_("./lib/mm_resize/resize_filter_info");
          var singletones = {};
          var NEED_SAFARI_FIX = false;
          try {
            if (typeof navigator !== "undefined" && navigator.userAgent) {
              NEED_SAFARI_FIX = navigator.userAgent.indexOf("Safari") >= 0;
            }
          } catch (e) {
          }
          var concurrency = 1;
          if (typeof navigator !== "undefined") {
            concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);
          }
          var DEFAULT_PICA_OPTS = {
            tile: 1024,
            concurrency,
            features: ["js", "wasm", "ww"],
            idle: 2e3,
            createCanvas: function createCanvas(width, height) {
              var tmpCanvas = document.createElement("canvas");
              tmpCanvas.width = width;
              tmpCanvas.height = height;
              return tmpCanvas;
            }
          };
          var DEFAULT_RESIZE_OPTS = {
            filter: "mks2013",
            unsharpAmount: 0,
            unsharpRadius: 0,
            unsharpThreshold: 0
          };
          var CAN_NEW_IMAGE_DATA = false;
          var CAN_CREATE_IMAGE_BITMAP = false;
          var CAN_USE_CANVAS_GET_IMAGE_DATA = false;
          var CAN_USE_OFFSCREEN_CANVAS = false;
          var CAN_USE_CIB_REGION_FOR_IMAGE = false;
          function workerFabric() {
            return {
              value: webworkify(worker),
              destroy: function destroy() {
                this.value.terminate();
                if (typeof window !== "undefined") {
                  var url2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
                  if (url2 && url2.revokeObjectURL && this.value.objectURL) {
                    url2.revokeObjectURL(this.value.objectURL);
                  }
                }
              }
            };
          }
          function Pica(options) {
            if (!(this instanceof Pica)) return new Pica(options);
            this.options = assign({}, DEFAULT_PICA_OPTS, options || {});
            var limiter_key = "lk_".concat(this.options.concurrency);
            this.__limit = singletones[limiter_key] || utils2.limiter(this.options.concurrency);
            if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit;
            this.features = {
              js: false,
              // pure JS implementation, can be disabled for testing
              wasm: false,
              // webassembly implementation for heavy functions
              cib: false,
              // resize via createImageBitmap (only FF at this moment)
              ww: false
              // webworkers
            };
            this.__workersPool = null;
            this.__requested_features = [];
            this.__mathlib = null;
          }
          Pica.prototype.init = function() {
            var _this = this;
            if (this.__initPromise) return this.__initPromise;
            if (typeof ImageData !== "undefined" && typeof Uint8ClampedArray !== "undefined") {
              try {
                new ImageData(new Uint8ClampedArray(400), 10, 10);
                CAN_NEW_IMAGE_DATA = true;
              } catch (__) {
              }
            }
            if (typeof ImageBitmap !== "undefined") {
              if (ImageBitmap.prototype && ImageBitmap.prototype.close) {
                CAN_CREATE_IMAGE_BITMAP = true;
              } else {
                this.debug("ImageBitmap does not support .close(), disabled");
              }
            }
            var features = this.options.features.slice();
            if (features.indexOf("all") >= 0) {
              features = ["cib", "wasm", "js", "ww"];
            }
            this.__requested_features = features;
            this.__mathlib = new MathLib(features);
            if (features.indexOf("ww") >= 0) {
              if (typeof window !== "undefined" && "Worker" in window) {
                try {
                  var wkr = _dereq_("webworkify")(function() {
                  });
                  wkr.terminate();
                  this.features.ww = true;
                  var wpool_key = "wp_".concat(JSON.stringify(this.options));
                  if (singletones[wpool_key]) {
                    this.__workersPool = singletones[wpool_key];
                  } else {
                    this.__workersPool = new Pool(workerFabric, this.options.idle);
                    singletones[wpool_key] = this.__workersPool;
                  }
                } catch (__) {
                }
              }
            }
            var initMath = this.__mathlib.init().then(function(mathlib) {
              assign(_this.features, mathlib.features);
            });
            var checkCibResize;
            if (!CAN_CREATE_IMAGE_BITMAP) {
              checkCibResize = Promise.resolve(false);
            } else {
              checkCibResize = utils2.cib_support(this.options.createCanvas).then(function(status) {
                if (_this.features.cib && features.indexOf("cib") < 0) {
                  _this.debug("createImageBitmap() resize supported, but disabled by config");
                  return;
                }
                if (features.indexOf("cib") >= 0) _this.features.cib = status;
              });
            }
            CAN_USE_CANVAS_GET_IMAGE_DATA = utils2.can_use_canvas(this.options.createCanvas);
            var checkOffscreenCanvas;
            if (CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && features.indexOf("ww") !== -1) {
              checkOffscreenCanvas = utils2.worker_offscreen_canvas_support();
            } else {
              checkOffscreenCanvas = Promise.resolve(false);
            }
            checkOffscreenCanvas = checkOffscreenCanvas.then(function(result) {
              CAN_USE_OFFSCREEN_CANVAS = result;
            });
            var checkCibRegion = utils2.cib_can_use_region().then(function(result) {
              CAN_USE_CIB_REGION_FOR_IMAGE = result;
            });
            this.__initPromise = Promise.all([initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion]).then(function() {
              return _this;
            });
            return this.__initPromise;
          };
          Pica.prototype.__invokeResize = function(tileOpts, opts) {
            var _this2 = this;
            opts.__mathCache = opts.__mathCache || {};
            return Promise.resolve().then(function() {
              if (!_this2.features.ww) {
                return {
                  data: _this2.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)
                };
              }
              return new Promise(function(resolve, reject) {
                var w = _this2.__workersPool.acquire();
                if (opts.cancelToken) opts.cancelToken["catch"](function(err2) {
                  return reject(err2);
                });
                w.value.onmessage = function(ev) {
                  w.release();
                  if (ev.data.err) reject(ev.data.err);
                  else resolve(ev.data);
                };
                var transfer = [];
                if (tileOpts.src) transfer.push(tileOpts.src.buffer);
                if (tileOpts.srcBitmap) transfer.push(tileOpts.srcBitmap);
                w.value.postMessage({
                  opts: tileOpts,
                  features: _this2.__requested_features,
                  preload: {
                    wasm_nodule: _this2.__mathlib.__
                  }
                }, transfer);
              });
            });
          };
          Pica.prototype.__extractTileData = function(tile, from, opts, stageEnv, extractTo) {
            if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,
            // can use canvas because canvas doesn't have orientation;
            // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671
            (utils2.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) {
              this.debug("Create tile for OffscreenCanvas");
              return createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then(function(bitmap) {
                extractTo.srcBitmap = bitmap;
                return extractTo;
              });
            }
            if (utils2.isCanvas(from)) {
              if (!stageEnv.srcCtx) stageEnv.srcCtx = from.getContext("2d");
              this.debug("Get tile pixel data");
              extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data;
              return extractTo;
            }
            this.debug("Draw tile imageBitmap/image to temporary canvas");
            var tmpCanvas = this.options.createCanvas(tile.width, tile.height);
            var tmpCtx = tmpCanvas.getContext("2d");
            tmpCtx.globalCompositeOperation = "copy";
            tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);
            this.debug("Get tile pixel data");
            extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data;
            tmpCanvas.width = tmpCanvas.height = 0;
            return extractTo;
          };
          Pica.prototype.__landTileData = function(tile, result, stageEnv) {
            var toImageData;
            this.debug("Convert raw rgba tile result to ImageData");
            if (result.bitmap) {
              stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY);
              return null;
            }
            if (CAN_NEW_IMAGE_DATA) {
              toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight);
            } else {
              toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight);
              if (toImageData.data.set) {
                toImageData.data.set(result.data);
              } else {
                for (var i = toImageData.data.length - 1; i >= 0; i--) {
                  toImageData.data[i] = result.data[i];
                }
              }
            }
            this.debug("Draw tile");
            if (NEED_SAFARI_FIX) {
              stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);
            } else {
              stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);
            }
            return null;
          };
          Pica.prototype.__tileAndResize = function(from, to, opts) {
            var _this3 = this;
            var stageEnv = {
              srcCtx: null,
              srcImageBitmap: null,
              isImageBitmapReused: false,
              toCtx: null
            };
            var processTile = function processTile2(tile) {
              return _this3.__limit(function() {
                if (opts.canceled) return opts.cancelToken;
                var tileOpts = {
                  width: tile.width,
                  height: tile.height,
                  toWidth: tile.toWidth,
                  toHeight: tile.toHeight,
                  scaleX: tile.scaleX,
                  scaleY: tile.scaleY,
                  offsetX: tile.offsetX,
                  offsetY: tile.offsetY,
                  filter: opts.filter,
                  unsharpAmount: opts.unsharpAmount,
                  unsharpRadius: opts.unsharpRadius,
                  unsharpThreshold: opts.unsharpThreshold
                };
                _this3.debug("Invoke resize math");
                return Promise.resolve(tileOpts).then(function(tileOpts2) {
                  return _this3.__extractTileData(tile, from, opts, stageEnv, tileOpts2);
                }).then(function(tileOpts2) {
                  _this3.debug("Invoke resize math");
                  return _this3.__invokeResize(tileOpts2, opts);
                }).then(function(result) {
                  if (opts.canceled) return opts.cancelToken;
                  stageEnv.srcImageData = null;
                  return _this3.__landTileData(tile, result, stageEnv);
                });
              });
            };
            return Promise.resolve().then(function() {
              stageEnv.toCtx = to.getContext("2d");
              if (utils2.isCanvas(from)) return null;
              if (utils2.isImageBitmap(from)) {
                stageEnv.srcImageBitmap = from;
                stageEnv.isImageBitmapReused = true;
                return null;
              }
              if (utils2.isImage(from)) {
                if (!CAN_CREATE_IMAGE_BITMAP) return null;
                _this3.debug("Decode image via createImageBitmap");
                return createImageBitmap(from).then(function(imageBitmap) {
                  stageEnv.srcImageBitmap = imageBitmap;
                })["catch"](function(e) {
                  return null;
                });
              }
              throw new Error('Pica: ".from" should be Image, Canvas or ImageBitmap');
            }).then(function() {
              if (opts.canceled) return opts.cancelToken;
              _this3.debug("Calculate tiles");
              var regions = createRegions({
                width: opts.width,
                height: opts.height,
                srcTileSize: _this3.options.tile,
                toWidth: opts.toWidth,
                toHeight: opts.toHeight,
                destTileBorder: opts.__destTileBorder
              });
              var jobs = regions.map(function(tile) {
                return processTile(tile);
              });
              function cleanup(stageEnv2) {
                if (stageEnv2.srcImageBitmap) {
                  if (!stageEnv2.isImageBitmapReused) stageEnv2.srcImageBitmap.close();
                  stageEnv2.srcImageBitmap = null;
                }
              }
              _this3.debug("Process tiles");
              return Promise.all(jobs).then(function() {
                _this3.debug("Finished!");
                cleanup(stageEnv);
                return to;
              }, function(err2) {
                cleanup(stageEnv);
                throw err2;
              });
            });
          };
          Pica.prototype.__processStages = function(stages, from, to, opts) {
            var _this4 = this;
            if (opts.canceled) return opts.cancelToken;
            var _stages$shift = stages.shift(), _stages$shift2 = _slicedToArray(_stages$shift, 2), toWidth = _stages$shift2[0], toHeight = _stages$shift2[1];
            var isLastStage = stages.length === 0;
            var filter;
            if (isLastStage || filter_info.q2f.indexOf(opts.filter) < 0) filter = opts.filter;
            else if (opts.filter === "box") filter = "box";
            else filter = "hamming";
            opts = assign({}, opts, {
              toWidth,
              toHeight,
              filter
            });
            var tmpCanvas;
            if (!isLastStage) {
              tmpCanvas = this.options.createCanvas(toWidth, toHeight);
            }
            return this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function() {
              if (isLastStage) return to;
              opts.width = toWidth;
              opts.height = toHeight;
              return _this4.__processStages(stages, tmpCanvas, to, opts);
            }).then(function(res) {
              if (tmpCanvas) {
                tmpCanvas.width = tmpCanvas.height = 0;
              }
              return res;
            });
          };
          Pica.prototype.__resizeViaCreateImageBitmap = function(from, to, opts) {
            var _this5 = this;
            var toCtx = to.getContext("2d");
            this.debug("Resize via createImageBitmap()");
            return createImageBitmap(from, {
              resizeWidth: opts.toWidth,
              resizeHeight: opts.toHeight,
              resizeQuality: utils2.cib_quality_name(filter_info.f2q[opts.filter])
            }).then(function(imageBitmap) {
              if (opts.canceled) return opts.cancelToken;
              if (!opts.unsharpAmount) {
                toCtx.drawImage(imageBitmap, 0, 0);
                imageBitmap.close();
                toCtx = null;
                _this5.debug("Finished!");
                return to;
              }
              _this5.debug("Unsharp result");
              var tmpCanvas = _this5.options.createCanvas(opts.toWidth, opts.toHeight);
              var tmpCtx = tmpCanvas.getContext("2d");
              tmpCtx.drawImage(imageBitmap, 0, 0);
              imageBitmap.close();
              var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);
              _this5.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);
              toCtx.putImageData(iData, 0, 0);
              tmpCanvas.width = tmpCanvas.height = 0;
              iData = tmpCtx = tmpCanvas = toCtx = null;
              _this5.debug("Finished!");
              return to;
            });
          };
          Pica.prototype.resize = function(from, to, options) {
            var _this6 = this;
            this.debug("Start resize...");
            var opts = assign({}, DEFAULT_RESIZE_OPTS);
            if (!isNaN(options)) {
              opts = assign(opts, {
                quality: options
              });
            } else if (options) {
              opts = assign(opts, options);
            }
            opts.toWidth = to.width;
            opts.toHeight = to.height;
            opts.width = from.naturalWidth || from.width;
            opts.height = from.naturalHeight || from.height;
            if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
              if (opts.quality < 0 || opts.quality > 3) {
                throw new Error("Pica: .quality should be [0..3], got ".concat(opts.quality));
              }
              opts.filter = filter_info.q2f[opts.quality];
            }
            if (to.width === 0 || to.height === 0) {
              return Promise.reject(new Error("Invalid output size: ".concat(to.width, "x").concat(to.height)));
            }
            if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;
            opts.canceled = false;
            if (opts.cancelToken) {
              opts.cancelToken = opts.cancelToken.then(function(data2) {
                opts.canceled = true;
                throw data2;
              }, function(err2) {
                opts.canceled = true;
                throw err2;
              });
            }
            var DEST_TILE_BORDER = 3;
            opts.__destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));
            return this.init().then(function() {
              if (opts.canceled) return opts.cancelToken;
              if (_this6.features.cib) {
                if (filter_info.q2f.indexOf(opts.filter) >= 0) {
                  return _this6.__resizeViaCreateImageBitmap(from, to, opts);
                }
                _this6.debug("cib is enabled, but not supports provided filter, fallback to manual math");
              }
              if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {
                var err2 = new Error("Pica: cannot use getImageData on canvas, make sure fingerprinting protection isn't enabled");
                err2.code = "ERR_GET_IMAGE_DATA";
                throw err2;
              }
              var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this6.options.tile, opts.__destTileBorder);
              return _this6.__processStages(stages, from, to, opts);
            });
          };
          Pica.prototype.resizeBuffer = function(options) {
            var _this7 = this;
            var opts = assign({}, DEFAULT_RESIZE_OPTS, options);
            if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
              if (opts.quality < 0 || opts.quality > 3) {
                throw new Error("Pica: .quality should be [0..3], got ".concat(opts.quality));
              }
              opts.filter = filter_info.q2f[opts.quality];
            }
            return this.init().then(function() {
              return _this7.__mathlib.resizeAndUnsharp(opts);
            });
          };
          Pica.prototype.toBlob = function(canvas2, mimeType, quality) {
            mimeType = mimeType || "image/png";
            return new Promise(function(resolve) {
              if (canvas2.toBlob) {
                canvas2.toBlob(function(blob) {
                  return resolve(blob);
                }, mimeType, quality);
                return;
              }
              if (canvas2.convertToBlob) {
                resolve(canvas2.convertToBlob({
                  type: mimeType,
                  quality
                }));
                return;
              }
              var asString = atob(canvas2.toDataURL(mimeType, quality).split(",")[1]);
              var len = asString.length;
              var asBuffer = new Uint8Array(len);
              for (var i = 0; i < len; i++) {
                asBuffer[i] = asString.charCodeAt(i);
              }
              resolve(new Blob([asBuffer], {
                type: mimeType
              }));
            });
          };
          Pica.prototype.debug = function() {
          };
          module3.exports = Pica;
        }, { "./lib/mathlib": 1, "./lib/mm_resize/resize_filter_info": 7, "./lib/pool": 13, "./lib/stepper": 14, "./lib/tiler": 15, "./lib/utils": 16, "./lib/worker": 17, "object-assign": 22, "webworkify": 23 }] }, {}, [])("/index.js");
      });
    })(pica$1);
    var image_traverse$1 = { exports: {} };
    (function(module2) {
      function error2(message, code) {
        var err2 = new Error(message);
        err2.code = code;
        return err2;
      }
      function to_hex(number2) {
        var n = number2.toString(16).toUpperCase();
        for (var i = 2 - n.length; i > 0; i--) n = "0" + n;
        return "0x" + n;
      }
      function utf8_encode(str) {
        try {
          return unescape(encodeURIComponent(str));
        } catch (_) {
          return str;
        }
      }
      function utf8_decode(str) {
        try {
          return decodeURIComponent(escape(str));
        } catch (_) {
          return str;
        }
      }
      function is_uint8array(bin2) {
        return Object.prototype.toString.call(bin2) === "[object Uint8Array]";
      }
      function ExifParser(jpeg_bin, exif_start, exif_end) {
        this.input = jpeg_bin.subarray(exif_start, exif_end);
        this.start = exif_start;
        var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));
        if (sig !== "II*\0" && sig !== "MM\0*") {
          throw error2("invalid TIFF signature", "EBADDATA");
        }
        this.big_endian = sig[0] === "M";
      }
      ExifParser.prototype.each = function(on_entry) {
        this.aborted = false;
        var offset = this.read_uint32(4);
        this.ifds_to_read = [{
          id: 0,
          offset
        }];
        while (this.ifds_to_read.length > 0 && !this.aborted) {
          var i = this.ifds_to_read.shift();
          if (!i.offset) continue;
          this.scan_ifd(i.id, i.offset, on_entry);
        }
      };
      ExifParser.prototype.filter = function(on_entry) {
        var ifds = {};
        ifds.ifd0 = { id: 0, entries: [] };
        this.each(function(entry) {
          if (on_entry(entry) === false && !entry.is_subifd_link) return;
          if (entry.is_subifd_link && entry.count !== 1 && entry.format !== 4) return;
          if (!ifds["ifd" + entry.ifd]) {
            ifds["ifd" + entry.ifd] = { id: entry.ifd, entries: [] };
          }
          ifds["ifd" + entry.ifd].entries.push(entry);
        });
        delete ifds.ifd1;
        var length = 8;
        Object.keys(ifds).forEach(function(ifd_no) {
          length += 2;
          ifds[ifd_no].entries.forEach(function(entry) {
            length += 12 + (entry.data_length > 4 ? Math.ceil(entry.data_length / 2) * 2 : 0);
          });
          length += 4;
        });
        this.output = new Uint8Array(length);
        this.output[0] = this.output[1] = (this.big_endian ? "M" : "I").charCodeAt(0);
        this.write_uint16(2, 42);
        var offset = 8;
        var self2 = this;
        this.write_uint32(4, offset);
        Object.keys(ifds).forEach(function(ifd_no) {
          ifds[ifd_no].written_offset = offset;
          var ifd_start = offset;
          var ifd_end = ifd_start + 2 + ifds[ifd_no].entries.length * 12 + 4;
          offset = ifd_end;
          self2.write_uint16(ifd_start, ifds[ifd_no].entries.length);
          ifds[ifd_no].entries.sort(function(a, b) {
            return a.tag - b.tag;
          }).forEach(function(entry, idx) {
            var entry_offset = ifd_start + 2 + idx * 12;
            self2.write_uint16(entry_offset, entry.tag);
            self2.write_uint16(entry_offset + 2, entry.format);
            self2.write_uint32(entry_offset + 4, entry.count);
            if (entry.is_subifd_link) {
              if (ifds["ifd" + entry.tag]) ifds["ifd" + entry.tag].link_offset = entry_offset + 8;
            } else if (entry.data_length <= 4) {
              self2.output.set(
                self2.input.subarray(entry.data_offset - self2.start, entry.data_offset - self2.start + 4),
                entry_offset + 8
              );
            } else {
              self2.write_uint32(entry_offset + 8, offset);
              self2.output.set(
                self2.input.subarray(entry.data_offset - self2.start, entry.data_offset - self2.start + entry.data_length),
                offset
              );
              offset += Math.ceil(entry.data_length / 2) * 2;
            }
          });
          var next_ifd = ifds["ifd" + (ifds[ifd_no].id + 1)];
          if (next_ifd) next_ifd.link_offset = ifd_end - 4;
        });
        Object.keys(ifds).forEach(function(ifd_no) {
          if (ifds[ifd_no].written_offset && ifds[ifd_no].link_offset) {
            self2.write_uint32(ifds[ifd_no].link_offset, ifds[ifd_no].written_offset);
          }
        });
        if (this.output.length !== offset) throw error2("internal error: incorrect buffer size allocated");
        return this.output;
      };
      ExifParser.prototype.read_uint16 = function(offset) {
        var d = this.input;
        if (offset + 2 > d.length) throw error2("unexpected EOF", "EBADDATA");
        return this.big_endian ? d[offset] * 256 + d[offset + 1] : d[offset] + d[offset + 1] * 256;
      };
      ExifParser.prototype.read_uint32 = function(offset) {
        var d = this.input;
        if (offset + 4 > d.length) throw error2("unexpected EOF", "EBADDATA");
        return this.big_endian ? d[offset] * 16777216 + d[offset + 1] * 65536 + d[offset + 2] * 256 + d[offset + 3] : d[offset] + d[offset + 1] * 256 + d[offset + 2] * 65536 + d[offset + 3] * 16777216;
      };
      ExifParser.prototype.write_uint16 = function(offset, value) {
        var d = this.output;
        if (this.big_endian) {
          d[offset] = value >>> 8 & 255;
          d[offset + 1] = value & 255;
        } else {
          d[offset] = value & 255;
          d[offset + 1] = value >>> 8 & 255;
        }
      };
      ExifParser.prototype.write_uint32 = function(offset, value) {
        var d = this.output;
        if (this.big_endian) {
          d[offset] = value >>> 24 & 255;
          d[offset + 1] = value >>> 16 & 255;
          d[offset + 2] = value >>> 8 & 255;
          d[offset + 3] = value & 255;
        } else {
          d[offset] = value & 255;
          d[offset + 1] = value >>> 8 & 255;
          d[offset + 2] = value >>> 16 & 255;
          d[offset + 3] = value >>> 24 & 255;
        }
      };
      ExifParser.prototype.is_subifd_link = function(ifd, tag) {
        return ifd === 0 && tag === 34665 || // SubIFD
        ifd === 0 && tag === 34853 || // GPS Info
        ifd === 34665 && tag === 40965;
      };
      ExifParser.prototype.exif_format_length = function(format) {
        switch (format) {
          case 1:
          // byte
          case 2:
          // ascii
          case 6:
          // sbyte
          case 7:
            return 1;
          case 3:
          // short
          case 8:
            return 2;
          case 4:
          // long
          case 9:
          // slong
          case 11:
            return 4;
          case 5:
          // rational
          case 10:
          // srational
          case 12:
            return 8;
          default:
            return 0;
        }
      };
      ExifParser.prototype.exif_format_read = function(format, offset) {
        var v;
        switch (format) {
          case 1:
          // byte
          case 2:
            v = this.input[offset];
            return v;
          case 6:
            v = this.input[offset];
            return v | (v & 128) * 33554430;
          case 3:
            v = this.read_uint16(offset);
            return v;
          case 8:
            v = this.read_uint16(offset);
            return v | (v & 32768) * 131070;
          case 4:
            v = this.read_uint32(offset);
            return v;
          case 9:
            v = this.read_uint32(offset);
            return v | 0;
          case 5:
          // rational
          case 10:
          // srational
          case 11:
          // float
          case 12:
            return null;
          // not implemented
          case 7:
            return null;
          // blob
          default:
            return null;
        }
      };
      ExifParser.prototype.scan_ifd = function(ifd_no, offset, on_entry) {
        var entry_count = this.read_uint16(offset);
        offset += 2;
        for (var i = 0; i < entry_count; i++) {
          var tag = this.read_uint16(offset);
          var format = this.read_uint16(offset + 2);
          var count2 = this.read_uint32(offset + 4);
          var comp_length = this.exif_format_length(format);
          var data_length = count2 * comp_length;
          var data_offset = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);
          var is_subifd_link = false;
          if (data_offset + data_length > this.input.length) {
            throw error2("unexpected EOF", "EBADDATA");
          }
          var value = [];
          var comp_offset = data_offset;
          for (var j = 0; j < count2; j++, comp_offset += comp_length) {
            var item = this.exif_format_read(format, comp_offset);
            if (item === null) {
              value = null;
              break;
            }
            value.push(item);
          }
          if (Array.isArray(value) && format === 2) {
            try {
              value = utf8_decode(String.fromCharCode.apply(null, value));
            } catch (_) {
              value = null;
            }
            if (value && value[value.length - 1] === "\0") value = value.slice(0, -1);
          }
          if (this.is_subifd_link(ifd_no, tag)) {
            if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {
              this.ifds_to_read.push({
                id: tag,
                offset: value[0]
              });
              is_subifd_link = true;
            }
          }
          var entry = {
            is_big_endian: this.big_endian,
            ifd: ifd_no,
            tag,
            format,
            count: count2,
            entry_offset: offset + this.start,
            data_length,
            data_offset: data_offset + this.start,
            value,
            is_subifd_link
          };
          if (on_entry(entry) === false) {
            this.aborted = true;
            return;
          }
          offset += 12;
        }
        if (ifd_no === 0) {
          this.ifds_to_read.push({
            id: 1,
            offset: this.read_uint32(offset)
          });
        }
      };
      module2.exports.is_jpeg = function(jpeg_bin) {
        return jpeg_bin.length >= 4 && jpeg_bin[0] === 255 && jpeg_bin[1] === 216 && jpeg_bin[2] === 255;
      };
      module2.exports.jpeg_segments_each = function(jpeg_bin, on_segment) {
        if (!is_uint8array(jpeg_bin)) {
          throw error2("Invalid argument (jpeg_bin), Uint8Array expected", "EINVAL");
        }
        if (typeof on_segment !== "function") {
          throw error2("Invalid argument (on_segment), Function expected", "EINVAL");
        }
        if (!module2.exports.is_jpeg(jpeg_bin)) {
          throw error2("Unknown file format", "ENOTJPEG");
        }
        var offset = 0, length = jpeg_bin.length, inside_scan = false;
        for (; ; ) {
          var segment_code, segment_length;
          if (offset + 1 >= length) throw error2("Unexpected EOF", "EBADDATA");
          var byte1 = jpeg_bin[offset];
          var byte2 = jpeg_bin[offset + 1];
          if (byte1 === 255 && byte2 === 255) {
            segment_code = 255;
            segment_length = 1;
          } else if (byte1 === 255 && byte2 !== 0) {
            segment_code = byte2;
            segment_length = 2;
            if (208 <= segment_code && segment_code <= 217 || segment_code === 1) ;
            else {
              if (offset + 3 >= length) throw error2("Unexpected EOF", "EBADDATA");
              segment_length += jpeg_bin[offset + 2] * 256 + jpeg_bin[offset + 3];
              if (segment_length < 2) throw error2("Invalid segment length", "EBADDATA");
              if (offset + segment_length - 1 >= length) throw error2("Unexpected EOF", "EBADDATA");
            }
            if (inside_scan) {
              if (segment_code >= 208 && segment_code <= 215) ;
              else {
                inside_scan = false;
              }
            }
            if (segment_code === 218) inside_scan = true;
          } else if (inside_scan) {
            for (var pos = offset + 1; ; pos++) {
              if (pos >= length) throw error2("Unexpected EOF", "EBADDATA");
              if (jpeg_bin[pos] === 255) {
                if (pos + 1 >= length) throw error2("Unexpected EOF", "EBADDATA");
                if (jpeg_bin[pos + 1] !== 0) {
                  segment_code = 0;
                  segment_length = pos - offset;
                  break;
                }
              }
            }
          } else {
            throw error2("Unexpected byte at segment start: " + to_hex(byte1) + " (offset " + to_hex(offset) + ")", "EBADDATA");
          }
          if (on_segment({ code: segment_code, offset, length: segment_length }) === false) break;
          if (segment_code === 217) break;
          offset += segment_length;
        }
      };
      module2.exports.jpeg_segments_filter = function(jpeg_bin, on_segment) {
        if (!is_uint8array(jpeg_bin)) {
          throw error2("Invalid argument (jpeg_bin), Uint8Array expected", "EINVAL");
        }
        if (typeof on_segment !== "function") {
          throw error2("Invalid argument (on_segment), Function expected", "EINVAL");
        }
        var ranges = [];
        var out_length = 0;
        module2.exports.jpeg_segments_each(jpeg_bin, function(segment) {
          var new_segment = on_segment(segment);
          if (is_uint8array(new_segment)) {
            ranges.push({ data: new_segment });
            out_length += new_segment.length;
          } else if (Array.isArray(new_segment)) {
            new_segment.filter(is_uint8array).forEach(function(s) {
              ranges.push({ data: s });
              out_length += s.length;
            });
          } else if (new_segment !== false) {
            var new_range = { start: segment.offset, end: segment.offset + segment.length };
            if (ranges.length > 0 && ranges[ranges.length - 1].end === new_range.start) {
              ranges[ranges.length - 1].end = new_range.end;
            } else {
              ranges.push(new_range);
            }
            out_length += segment.length;
          }
        });
        var result = new Uint8Array(out_length);
        var offset = 0;
        ranges.forEach(function(range) {
          var data2 = range.data || jpeg_bin.subarray(range.start, range.end);
          result.set(data2, offset);
          offset += data2.length;
        });
        return result;
      };
      module2.exports.jpeg_exif_tags_each = function(jpeg_bin, on_exif_entry) {
        if (!is_uint8array(jpeg_bin)) {
          throw error2("Invalid argument (jpeg_bin), Uint8Array expected", "EINVAL");
        }
        if (typeof on_exif_entry !== "function") {
          throw error2("Invalid argument (on_exif_entry), Function expected", "EINVAL");
        }
        module2.exports.jpeg_segments_each(jpeg_bin, function(segment) {
          if (segment.code === 218) return false;
          if (segment.code === 225 && segment.length >= 10 && jpeg_bin[segment.offset + 4] === 69 && jpeg_bin[segment.offset + 5] === 120 && jpeg_bin[segment.offset + 6] === 105 && jpeg_bin[segment.offset + 7] === 102 && jpeg_bin[segment.offset + 8] === 0 && jpeg_bin[segment.offset + 9] === 0) {
            new ExifParser(jpeg_bin, segment.offset + 10, segment.offset + segment.length).each(on_exif_entry);
            return false;
          }
        });
      };
      module2.exports.jpeg_exif_tags_filter = function(jpeg_bin, on_exif_entry) {
        if (!is_uint8array(jpeg_bin)) {
          throw error2("Invalid argument (jpeg_bin), Uint8Array expected", "EINVAL");
        }
        if (typeof on_exif_entry !== "function") {
          throw error2("Invalid argument (on_exif_entry), Function expected", "EINVAL");
        }
        var stop_search = false;
        return module2.exports.jpeg_segments_filter(jpeg_bin, function(segment) {
          if (stop_search) return;
          if (segment.code === 218) stop_search = true;
          if (segment.code === 225 && segment.length >= 10 && jpeg_bin[segment.offset + 4] === 69 && jpeg_bin[segment.offset + 5] === 120 && jpeg_bin[segment.offset + 6] === 105 && jpeg_bin[segment.offset + 7] === 102 && jpeg_bin[segment.offset + 8] === 0 && jpeg_bin[segment.offset + 9] === 0) {
            var new_exif = new ExifParser(jpeg_bin, segment.offset + 10, segment.offset + segment.length).filter(on_exif_entry);
            if (!new_exif) return false;
            var header = new Uint8Array(10);
            header.set(jpeg_bin.slice(segment.offset, segment.offset + 10));
            header[2] = new_exif.length + 8 >>> 8 & 255;
            header[3] = new_exif.length + 8 & 255;
            stop_search = true;
            return [header, new_exif];
          }
        });
      };
      module2.exports.jpeg_add_comment = function(jpeg_bin, comment) {
        var comment_inserted = false, segment_count = 0;
        return module2.exports.jpeg_segments_filter(jpeg_bin, function(segment) {
          segment_count++;
          if (segment_count === 1 && segment.code === 216) return;
          if (segment_count === 2 && segment.code === 224) return;
          if (comment_inserted) return;
          comment = utf8_encode(comment);
          var csegment = new Uint8Array(5 + comment.length);
          var offset = 0;
          csegment[offset++] = 255;
          csegment[offset++] = 254;
          csegment[offset++] = comment.length + 3 >>> 8 & 255;
          csegment[offset++] = comment.length + 3 & 255;
          comment.split("").forEach(function(c) {
            csegment[offset++] = c.charCodeAt(0) & 255;
          });
          csegment[offset++] = 0;
          comment_inserted = true;
          return [csegment, jpeg_bin.subarray(segment.offset, segment.offset + segment.length)];
        });
      };
    })(image_traverse$1);
    function commonjsRequire(path) {
      throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var pica = { exports: {} };
    /*!
    
    pica
    https://github.com/nodeca/pica
    
    */
    var hasRequiredPica;
    function requirePica() {
      if (hasRequiredPica) return pica.exports;
      hasRequiredPica = 1;
      (function(module2, exports2) {
        (function(f) {
          {
            module2.exports = f();
          }
        })(function() {
          return (/* @__PURE__ */ function() {
            function r2(e, n, t) {
              function o(i2, f) {
                if (!n[i2]) {
                  if (!e[i2]) {
                    var c = "function" == typeof commonjsRequire && commonjsRequire;
                    if (!f && c) return c(i2, true);
                    if (u) return u(i2, true);
                    var a = new Error("Cannot find module '" + i2 + "'");
                    throw a.code = "MODULE_NOT_FOUND", a;
                  }
                  var p = n[i2] = { exports: {} };
                  e[i2][0].call(p.exports, function(r3) {
                    var n2 = e[i2][1][r3];
                    return o(n2 || r3);
                  }, p, p.exports, r2, e, n, t);
                }
                return n[i2].exports;
              }
              for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++) o(t[i]);
              return o;
            }
            return r2;
          }())({ 1: [function(_dereq_, module3, exports3) {
            var Multimath = _dereq_("multimath");
            var mm_unsharp_mask = _dereq_("./mm_unsharp_mask");
            var mm_resize = _dereq_("./mm_resize");
            function MathLib(requested_features) {
              var __requested_features = requested_features || [];
              var features = {
                js: __requested_features.indexOf("js") >= 0,
                wasm: __requested_features.indexOf("wasm") >= 0
              };
              Multimath.call(this, features);
              this.features = {
                js: features.js,
                wasm: features.wasm && this.has_wasm()
              };
              this.use(mm_unsharp_mask);
              this.use(mm_resize);
            }
            MathLib.prototype = Object.create(Multimath.prototype);
            MathLib.prototype.constructor = MathLib;
            MathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {
              var result = this.resize(options, cache);
              if (options.unsharpAmount) {
                this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);
              }
              return result;
            };
            module3.exports = MathLib;
          }, { "./mm_resize": 4, "./mm_unsharp_mask": 9, "multimath": 19 }], 2: [function(_dereq_, module3, exports3) {
            function clampTo8(i) {
              return i < 0 ? 0 : i > 255 ? 255 : i;
            }
            function clampNegative(i) {
              return i >= 0 ? i : 0;
            }
            function convolveHor(src, dest, srcW, srcH, destW, filters) {
              var r2, g, b, a;
              var filterPtr, filterShift, filterSize;
              var srcPtr, srcY, destX, filterVal;
              var srcOffset = 0, destOffset = 0;
              for (srcY = 0; srcY < srcH; srcY++) {
                filterPtr = 0;
                for (destX = 0; destX < destW; destX++) {
                  filterShift = filters[filterPtr++];
                  filterSize = filters[filterPtr++];
                  srcPtr = srcOffset + filterShift * 4 | 0;
                  r2 = g = b = a = 0;
                  for (; filterSize > 0; filterSize--) {
                    filterVal = filters[filterPtr++];
                    a = a + filterVal * src[srcPtr + 3] | 0;
                    b = b + filterVal * src[srcPtr + 2] | 0;
                    g = g + filterVal * src[srcPtr + 1] | 0;
                    r2 = r2 + filterVal * src[srcPtr] | 0;
                    srcPtr = srcPtr + 4 | 0;
                  }
                  dest[destOffset + 3] = clampNegative(a >> 7);
                  dest[destOffset + 2] = clampNegative(b >> 7);
                  dest[destOffset + 1] = clampNegative(g >> 7);
                  dest[destOffset] = clampNegative(r2 >> 7);
                  destOffset = destOffset + srcH * 4 | 0;
                }
                destOffset = (srcY + 1) * 4 | 0;
                srcOffset = (srcY + 1) * srcW * 4 | 0;
              }
            }
            function convolveVert(src, dest, srcW, srcH, destW, filters) {
              var r2, g, b, a;
              var filterPtr, filterShift, filterSize;
              var srcPtr, srcY, destX, filterVal;
              var srcOffset = 0, destOffset = 0;
              for (srcY = 0; srcY < srcH; srcY++) {
                filterPtr = 0;
                for (destX = 0; destX < destW; destX++) {
                  filterShift = filters[filterPtr++];
                  filterSize = filters[filterPtr++];
                  srcPtr = srcOffset + filterShift * 4 | 0;
                  r2 = g = b = a = 0;
                  for (; filterSize > 0; filterSize--) {
                    filterVal = filters[filterPtr++];
                    a = a + filterVal * src[srcPtr + 3] | 0;
                    b = b + filterVal * src[srcPtr + 2] | 0;
                    g = g + filterVal * src[srcPtr + 1] | 0;
                    r2 = r2 + filterVal * src[srcPtr] | 0;
                    srcPtr = srcPtr + 4 | 0;
                  }
                  r2 >>= 7;
                  g >>= 7;
                  b >>= 7;
                  a >>= 7;
                  dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14);
                  dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);
                  dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);
                  dest[destOffset] = clampTo8(r2 + (1 << 13) >> 14);
                  destOffset = destOffset + srcH * 4 | 0;
                }
                destOffset = (srcY + 1) * 4 | 0;
                srcOffset = (srcY + 1) * srcW * 4 | 0;
              }
            }
            function convolveHorWithPre(src, dest, srcW, srcH, destW, filters) {
              var r2, g, b, a, alpha;
              var filterPtr, filterShift, filterSize;
              var srcPtr, srcY, destX, filterVal;
              var srcOffset = 0, destOffset = 0;
              for (srcY = 0; srcY < srcH; srcY++) {
                filterPtr = 0;
                for (destX = 0; destX < destW; destX++) {
                  filterShift = filters[filterPtr++];
                  filterSize = filters[filterPtr++];
                  srcPtr = srcOffset + filterShift * 4 | 0;
                  r2 = g = b = a = 0;
                  for (; filterSize > 0; filterSize--) {
                    filterVal = filters[filterPtr++];
                    alpha = src[srcPtr + 3];
                    a = a + filterVal * alpha | 0;
                    b = b + filterVal * src[srcPtr + 2] * alpha | 0;
                    g = g + filterVal * src[srcPtr + 1] * alpha | 0;
                    r2 = r2 + filterVal * src[srcPtr] * alpha | 0;
                    srcPtr = srcPtr + 4 | 0;
                  }
                  b = b / 255 | 0;
                  g = g / 255 | 0;
                  r2 = r2 / 255 | 0;
                  dest[destOffset + 3] = clampNegative(a >> 7);
                  dest[destOffset + 2] = clampNegative(b >> 7);
                  dest[destOffset + 1] = clampNegative(g >> 7);
                  dest[destOffset] = clampNegative(r2 >> 7);
                  destOffset = destOffset + srcH * 4 | 0;
                }
                destOffset = (srcY + 1) * 4 | 0;
                srcOffset = (srcY + 1) * srcW * 4 | 0;
              }
            }
            function convolveVertWithPre(src, dest, srcW, srcH, destW, filters) {
              var r2, g, b, a;
              var filterPtr, filterShift, filterSize;
              var srcPtr, srcY, destX, filterVal;
              var srcOffset = 0, destOffset = 0;
              for (srcY = 0; srcY < srcH; srcY++) {
                filterPtr = 0;
                for (destX = 0; destX < destW; destX++) {
                  filterShift = filters[filterPtr++];
                  filterSize = filters[filterPtr++];
                  srcPtr = srcOffset + filterShift * 4 | 0;
                  r2 = g = b = a = 0;
                  for (; filterSize > 0; filterSize--) {
                    filterVal = filters[filterPtr++];
                    a = a + filterVal * src[srcPtr + 3] | 0;
                    b = b + filterVal * src[srcPtr + 2] | 0;
                    g = g + filterVal * src[srcPtr + 1] | 0;
                    r2 = r2 + filterVal * src[srcPtr] | 0;
                    srcPtr = srcPtr + 4 | 0;
                  }
                  r2 >>= 7;
                  g >>= 7;
                  b >>= 7;
                  a >>= 7;
                  a = clampTo8(a + (1 << 13) >> 14);
                  if (a > 0) {
                    r2 = r2 * 255 / a | 0;
                    g = g * 255 / a | 0;
                    b = b * 255 / a | 0;
                  }
                  dest[destOffset + 3] = a;
                  dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);
                  dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);
                  dest[destOffset] = clampTo8(r2 + (1 << 13) >> 14);
                  destOffset = destOffset + srcH * 4 | 0;
                }
                destOffset = (srcY + 1) * 4 | 0;
                srcOffset = (srcY + 1) * srcW * 4 | 0;
              }
            }
            module3.exports = {
              convolveHor,
              convolveVert,
              convolveHorWithPre,
              convolveVertWithPre
            };
          }, {}], 3: [function(_dereq_, module3, exports3) {
            module3.exports = "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";
          }, {}], 4: [function(_dereq_, module3, exports3) {
            module3.exports = {
              name: "resize",
              fn: _dereq_("./resize"),
              wasm_fn: _dereq_("./resize_wasm"),
              wasm_src: _dereq_("./convolve_wasm_base64")
            };
          }, { "./convolve_wasm_base64": 3, "./resize": 5, "./resize_wasm": 8 }], 5: [function(_dereq_, module3, exports3) {
            var createFilters = _dereq_("./resize_filter_gen");
            var _require = _dereq_("./convolve"), convolveHor = _require.convolveHor, convolveVert = _require.convolveVert, convolveHorWithPre = _require.convolveHorWithPre, convolveVertWithPre = _require.convolveVertWithPre;
            function hasAlpha(src, width, height) {
              var ptr = 3, len = width * height * 4 | 0;
              while (ptr < len) {
                if (src[ptr] !== 255) return true;
                ptr = ptr + 4 | 0;
              }
              return false;
            }
            function resetAlpha(dst, width, height) {
              var ptr = 3, len = width * height * 4 | 0;
              while (ptr < len) {
                dst[ptr] = 255;
                ptr = ptr + 4 | 0;
              }
            }
            module3.exports = function resize(options) {
              var src = options.src;
              var srcW = options.width;
              var srcH = options.height;
              var destW = options.toWidth;
              var destH = options.toHeight;
              var scaleX = options.scaleX || options.toWidth / options.width;
              var scaleY = options.scaleY || options.toHeight / options.height;
              var offsetX = options.offsetX || 0;
              var offsetY = options.offsetY || 0;
              var dest = options.dest || new Uint8Array(destW * destH * 4);
              var filter = typeof options.filter === "undefined" ? "mks2013" : options.filter;
              var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);
              var tmp = new Uint16Array(destW * srcH * 4);
              if (hasAlpha(src, srcW, srcH)) {
                convolveHorWithPre(src, tmp, srcW, srcH, destW, filtersX);
                convolveVertWithPre(tmp, dest, srcH, destW, destH, filtersY);
              } else {
                convolveHor(src, tmp, srcW, srcH, destW, filtersX);
                convolveVert(tmp, dest, srcH, destW, destH, filtersY);
                resetAlpha(dest, destW, destH);
              }
              return dest;
            };
          }, { "./convolve": 2, "./resize_filter_gen": 6 }], 6: [function(_dereq_, module3, exports3) {
            var FILTER_INFO = _dereq_("./resize_filter_info");
            var FIXED_FRAC_BITS = 14;
            function toFixedPoint(num) {
              return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));
            }
            module3.exports = function resizeFilterGen(filter, srcSize, destSize, scale, offset) {
              var filterFunction = FILTER_INFO.filter[filter].fn;
              var scaleInverted = 1 / scale;
              var scaleClamped = Math.min(1, scale);
              var srcWindow = FILTER_INFO.filter[filter].win / scaleClamped;
              var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;
              var leftNotEmpty, rightNotEmpty, filterShift, filterSize;
              var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);
              var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);
              var packedFilterPtr = 0;
              var slowCopy = !packedFilter.subarray || !packedFilter.set;
              for (destPixel = 0; destPixel < destSize; destPixel++) {
                srcPixel = (destPixel + 0.5) * scaleInverted + offset;
                srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));
                srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));
                filterElementSize = srcLast - srcFirst + 1;
                floatFilter = new Float32Array(filterElementSize);
                fxpFilter = new Int16Array(filterElementSize);
                total = 0;
                for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {
                  floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);
                  total += floatVal;
                  floatFilter[idx] = floatVal;
                }
                filterTotal = 0;
                for (idx = 0; idx < floatFilter.length; idx++) {
                  filterVal = floatFilter[idx] / total;
                  filterTotal += filterVal;
                  fxpFilter[idx] = toFixedPoint(filterVal);
                }
                fxpFilter[destSize >> 1] += toFixedPoint(1 - filterTotal);
                leftNotEmpty = 0;
                while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {
                  leftNotEmpty++;
                }
                if (leftNotEmpty < fxpFilter.length) {
                  rightNotEmpty = fxpFilter.length - 1;
                  while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {
                    rightNotEmpty--;
                  }
                  filterShift = srcFirst + leftNotEmpty;
                  filterSize = rightNotEmpty - leftNotEmpty + 1;
                  packedFilter[packedFilterPtr++] = filterShift;
                  packedFilter[packedFilterPtr++] = filterSize;
                  if (!slowCopy) {
                    packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);
                    packedFilterPtr += filterSize;
                  } else {
                    for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {
                      packedFilter[packedFilterPtr++] = fxpFilter[idx];
                    }
                  }
                } else {
                  packedFilter[packedFilterPtr++] = 0;
                  packedFilter[packedFilterPtr++] = 0;
                }
              }
              return packedFilter;
            };
          }, { "./resize_filter_info": 7 }], 7: [function(_dereq_, module3, exports3) {
            var filter = {
              // Nearest neibor
              box: {
                win: 0.5,
                fn: function fn(x) {
                  if (x < 0) x = -x;
                  return x < 0.5 ? 1 : 0;
                }
              },
              // // Hamming
              hamming: {
                win: 1,
                fn: function fn(x) {
                  if (x < 0) x = -x;
                  if (x >= 1) {
                    return 0;
                  }
                  if (x < 11920929e-14) {
                    return 1;
                  }
                  var xpi = x * Math.PI;
                  return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1));
                }
              },
              // Lanczos, win = 2
              lanczos2: {
                win: 2,
                fn: function fn(x) {
                  if (x < 0) x = -x;
                  if (x >= 2) {
                    return 0;
                  }
                  if (x < 11920929e-14) {
                    return 1;
                  }
                  var xpi = x * Math.PI;
                  return Math.sin(xpi) / xpi * Math.sin(xpi / 2) / (xpi / 2);
                }
              },
              // Lanczos, win = 3
              lanczos3: {
                win: 3,
                fn: function fn(x) {
                  if (x < 0) x = -x;
                  if (x >= 3) {
                    return 0;
                  }
                  if (x < 11920929e-14) {
                    return 1;
                  }
                  var xpi = x * Math.PI;
                  return Math.sin(xpi) / xpi * Math.sin(xpi / 3) / (xpi / 3);
                }
              },
              // Magic Kernel Sharp 2013, win = 2.5
              // http://johncostella.com/magic/
              mks2013: {
                win: 2.5,
                fn: function fn(x) {
                  if (x < 0) x = -x;
                  if (x >= 2.5) {
                    return 0;
                  }
                  if (x >= 1.5) {
                    return -0.125 * (x - 2.5) * (x - 2.5);
                  }
                  if (x >= 0.5) {
                    return 0.25 * (4 * x * x - 11 * x + 7);
                  }
                  return 1.0625 - 1.75 * x * x;
                }
              }
            };
            module3.exports = {
              filter,
              // Legacy mapping
              f2q: {
                box: 0,
                hamming: 1,
                lanczos2: 2,
                lanczos3: 3
              },
              q2f: ["box", "hamming", "lanczos2", "lanczos3"]
            };
          }, {}], 8: [function(_dereq_, module3, exports3) {
            var createFilters = _dereq_("./resize_filter_gen");
            function hasAlpha(src, width, height) {
              var ptr = 3, len = width * height * 4 | 0;
              while (ptr < len) {
                if (src[ptr] !== 255) return true;
                ptr = ptr + 4 | 0;
              }
              return false;
            }
            function resetAlpha(dst, width, height) {
              var ptr = 3, len = width * height * 4 | 0;
              while (ptr < len) {
                dst[ptr] = 255;
                ptr = ptr + 4 | 0;
              }
            }
            function asUint8Array(src) {
              return new Uint8Array(src.buffer, 0, src.byteLength);
            }
            var IS_LE = true;
            try {
              IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
            } catch (__) {
            }
            function copyInt16asLE(src, target, target_offset) {
              if (IS_LE) {
                target.set(asUint8Array(src), target_offset);
                return;
              }
              for (var ptr = target_offset, i = 0; i < src.length; i++) {
                var data2 = src[i];
                target[ptr++] = data2 & 255;
                target[ptr++] = data2 >> 8 & 255;
              }
            }
            module3.exports = function resize_wasm(options) {
              var src = options.src;
              var srcW = options.width;
              var srcH = options.height;
              var destW = options.toWidth;
              var destH = options.toHeight;
              var scaleX = options.scaleX || options.toWidth / options.width;
              var scaleY = options.scaleY || options.toHeight / options.height;
              var offsetX = options.offsetX || 0;
              var offsetY = options.offsetY || 0;
              var dest = options.dest || new Uint8Array(destW * destH * 4);
              var filter = typeof options.filter === "undefined" ? "mks2013" : options.filter;
              var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);
              var src_offset = 0;
              var src_size = Math.max(src.byteLength, dest.byteLength);
              var tmp_offset = this.__align(src_offset + src_size);
              var tmp_size = srcH * destW * 4 * 2;
              var filtersX_offset = this.__align(tmp_offset + tmp_size);
              var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);
              var alloc_bytes = filtersY_offset + filtersY.byteLength;
              var instance = this.__instance("resize", alloc_bytes);
              var mem = new Uint8Array(this.__memory.buffer);
              var mem32 = new Uint32Array(this.__memory.buffer);
              var src32 = new Uint32Array(src.buffer);
              mem32.set(src32);
              copyInt16asLE(filtersX, mem, filtersX_offset);
              copyInt16asLE(filtersY, mem, filtersY_offset);
              var fn = instance.exports.convolveHV || instance.exports._convolveHV;
              if (hasAlpha(src, srcW, srcH)) {
                fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 1);
              } else {
                fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 0);
                resetAlpha(dest, destW, destH);
              }
              var dest32 = new Uint32Array(dest.buffer);
              dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW));
              return dest;
            };
          }, { "./resize_filter_gen": 6 }], 9: [function(_dereq_, module3, exports3) {
            module3.exports = {
              name: "unsharp_mask",
              fn: _dereq_("./unsharp_mask"),
              wasm_fn: _dereq_("./unsharp_mask_wasm"),
              wasm_src: _dereq_("./unsharp_mask_wasm_base64")
            };
          }, { "./unsharp_mask": 10, "./unsharp_mask_wasm": 11, "./unsharp_mask_wasm_base64": 12 }], 10: [function(_dereq_, module3, exports3) {
            var glur_mono16 = _dereq_("glur/mono16");
            function hsv_v16(img, width, height) {
              var size = width * height;
              var out = new Uint16Array(size);
              var r2, g, b, max;
              for (var i = 0; i < size; i++) {
                r2 = img[4 * i];
                g = img[4 * i + 1];
                b = img[4 * i + 2];
                max = r2 >= g && r2 >= b ? r2 : g >= b && g >= r2 ? g : b;
                out[i] = max << 8;
              }
              return out;
            }
            module3.exports = function unsharp(img, width, height, amount, radius, threshold) {
              var v1, v2, vmul;
              var diff, iTimes4;
              if (amount === 0 || radius < 0.5) {
                return;
              }
              if (radius > 2) {
                radius = 2;
              }
              var brightness = hsv_v16(img, width, height);
              var blured = new Uint16Array(brightness);
              glur_mono16(blured, width, height, radius);
              var amountFp = amount / 100 * 4096 + 0.5 | 0;
              var thresholdFp = threshold << 8;
              var size = width * height;
              for (var i = 0; i < size; i++) {
                v1 = brightness[i];
                diff = v1 - blured[i];
                if (Math.abs(diff) >= thresholdFp) {
                  v2 = v1 + (amountFp * diff + 2048 >> 12);
                  v2 = v2 > 65280 ? 65280 : v2;
                  v2 = v2 < 0 ? 0 : v2;
                  v1 = v1 !== 0 ? v1 : 1;
                  vmul = (v2 << 12) / v1 | 0;
                  iTimes4 = i * 4;
                  img[iTimes4] = img[iTimes4] * vmul + 2048 >> 12;
                  img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 2048 >> 12;
                  img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 2048 >> 12;
                }
              }
            };
          }, { "glur/mono16": 18 }], 11: [function(_dereq_, module3, exports3) {
            module3.exports = function unsharp(img, width, height, amount, radius, threshold) {
              if (amount === 0 || radius < 0.5) {
                return;
              }
              if (radius > 2) {
                radius = 2;
              }
              var pixels = width * height;
              var img_bytes_cnt = pixels * 4;
              var hsv_bytes_cnt = pixels * 2;
              var blur_bytes_cnt = pixels * 2;
              var blur_line_byte_cnt = Math.max(width, height) * 4;
              var blur_coeffs_byte_cnt = 8 * 4;
              var img_offset = 0;
              var hsv_offset = img_bytes_cnt;
              var blur_offset = hsv_offset + hsv_bytes_cnt;
              var blur_tmp_offset = blur_offset + blur_bytes_cnt;
              var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;
              var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;
              var instance = this.__instance("unsharp_mask", img_bytes_cnt + hsv_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {
                exp: Math.exp
              });
              var img32 = new Uint32Array(img.buffer);
              var mem32 = new Uint32Array(this.__memory.buffer);
              mem32.set(img32);
              var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;
              fn(img_offset, hsv_offset, width, height);
              fn = instance.exports.blurMono16 || instance.exports._blurMono16;
              fn(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius);
              fn = instance.exports.unsharp || instance.exports._unsharp;
              fn(img_offset, img_offset, hsv_offset, blur_offset, width, height, amount, threshold);
              img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));
            };
          }, {}], 12: [function(_dereq_, module3, exports3) {
            module3.exports = "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";
          }, {}], 13: [function(_dereq_, module3, exports3) {
            var GC_INTERVAL = 100;
            function Pool(create, idle) {
              this.create = create;
              this.available = [];
              this.acquired = {};
              this.lastId = 1;
              this.timeoutId = 0;
              this.idle = idle || 2e3;
            }
            Pool.prototype.acquire = function() {
              var _this = this;
              var resource;
              if (this.available.length !== 0) {
                resource = this.available.pop();
              } else {
                resource = this.create();
                resource.id = this.lastId++;
                resource.release = function() {
                  return _this.release(resource);
                };
              }
              this.acquired[resource.id] = resource;
              return resource;
            };
            Pool.prototype.release = function(resource) {
              var _this2 = this;
              delete this.acquired[resource.id];
              resource.lastUsed = Date.now();
              this.available.push(resource);
              if (this.timeoutId === 0) {
                this.timeoutId = setTimeout(function() {
                  return _this2.gc();
                }, GC_INTERVAL);
              }
            };
            Pool.prototype.gc = function() {
              var _this3 = this;
              var now = Date.now();
              this.available = this.available.filter(function(resource) {
                if (now - resource.lastUsed > _this3.idle) {
                  resource.destroy();
                  return false;
                }
                return true;
              });
              if (this.available.length !== 0) {
                this.timeoutId = setTimeout(function() {
                  return _this3.gc();
                }, GC_INTERVAL);
              } else {
                this.timeoutId = 0;
              }
            };
            module3.exports = Pool;
          }, {}], 14: [function(_dereq_, module3, exports3) {
            var MIN_INNER_TILE_SIZE = 2;
            module3.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {
              var scaleX = toWidth / fromWidth;
              var scaleY = toHeight / fromHeight;
              var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize;
              if (minScale > 0.5) return [[toWidth, toHeight]];
              var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale));
              if (stageCount <= 1) return [[toWidth, toHeight]];
              var result = [];
              for (var i = 0; i < stageCount; i++) {
                var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));
                var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));
                result.push([width, height]);
              }
              return result;
            };
          }, {}], 15: [function(_dereq_, module3, exports3) {
            var PIXEL_EPSILON = 1e-5;
            function pixelFloor(x) {
              var nearest = Math.round(x);
              if (Math.abs(x - nearest) < PIXEL_EPSILON) {
                return nearest;
              }
              return Math.floor(x);
            }
            function pixelCeil(x) {
              var nearest = Math.round(x);
              if (Math.abs(x - nearest) < PIXEL_EPSILON) {
                return nearest;
              }
              return Math.ceil(x);
            }
            module3.exports = function createRegions(options) {
              var scaleX = options.toWidth / options.width;
              var scaleY = options.toHeight / options.height;
              var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;
              var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder;
              if (innerTileWidth < 1 || innerTileHeight < 1) {
                throw new Error("Internal error in pica: target tile width/height is too small.");
              }
              var x, y;
              var innerX, innerY, toTileWidth, toTileHeight;
              var tiles = [];
              var tile;
              for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {
                for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {
                  x = innerX - options.destTileBorder;
                  if (x < 0) {
                    x = 0;
                  }
                  toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;
                  if (x + toTileWidth >= options.toWidth) {
                    toTileWidth = options.toWidth - x;
                  }
                  y = innerY - options.destTileBorder;
                  if (y < 0) {
                    y = 0;
                  }
                  toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;
                  if (y + toTileHeight >= options.toHeight) {
                    toTileHeight = options.toHeight - y;
                  }
                  tile = {
                    toX: x,
                    toY: y,
                    toWidth: toTileWidth,
                    toHeight: toTileHeight,
                    toInnerX: innerX,
                    toInnerY: innerY,
                    toInnerWidth: innerTileWidth,
                    toInnerHeight: innerTileHeight,
                    offsetX: x / scaleX - pixelFloor(x / scaleX),
                    offsetY: y / scaleY - pixelFloor(y / scaleY),
                    scaleX,
                    scaleY,
                    x: pixelFloor(x / scaleX),
                    y: pixelFloor(y / scaleY),
                    width: pixelCeil(toTileWidth / scaleX),
                    height: pixelCeil(toTileHeight / scaleY)
                  };
                  tiles.push(tile);
                }
              }
              return tiles;
            };
          }, {}], 16: [function(_dereq_, module3, exports3) {
            function objClass(obj) {
              return Object.prototype.toString.call(obj);
            }
            module3.exports.isCanvas = function isCanvas(element) {
              var cname = objClass(element);
              return cname === "[object HTMLCanvasElement]" || cname === "[object OffscreenCanvas]" || cname === "[object Canvas]";
            };
            module3.exports.isImage = function isImage(element) {
              return objClass(element) === "[object HTMLImageElement]";
            };
            module3.exports.isImageBitmap = function isImageBitmap(element) {
              return objClass(element) === "[object ImageBitmap]";
            };
            module3.exports.limiter = function limiter(concurrency) {
              var active = 0, queue = [];
              function roll() {
                if (active < concurrency && queue.length) {
                  active++;
                  queue.shift()();
                }
              }
              return function limit(fn) {
                return new Promise(function(resolve, reject) {
                  queue.push(function() {
                    fn().then(function(result) {
                      resolve(result);
                      active--;
                      roll();
                    }, function(err2) {
                      reject(err2);
                      active--;
                      roll();
                    });
                  });
                  roll();
                });
              };
            };
            module3.exports.cib_quality_name = function cib_quality_name(num) {
              switch (num) {
                case 0:
                  return "pixelated";
                case 1:
                  return "low";
                case 2:
                  return "medium";
              }
              return "high";
            };
            module3.exports.cib_support = function cib_support(createCanvas) {
              return Promise.resolve().then(function() {
                if (typeof createImageBitmap === "undefined") {
                  return false;
                }
                var c = createCanvas(100, 100);
                return createImageBitmap(c, 0, 0, 100, 100, {
                  resizeWidth: 10,
                  resizeHeight: 10,
                  resizeQuality: "high"
                }).then(function(bitmap) {
                  var status = bitmap.width === 10;
                  bitmap.close();
                  c = null;
                  return status;
                });
              })["catch"](function() {
                return false;
              });
            };
            module3.exports.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {
              return new Promise(function(resolve, reject) {
                if (typeof OffscreenCanvas === "undefined") {
                  resolve(false);
                  return;
                }
                function workerPayload(self2) {
                  if (typeof createImageBitmap === "undefined") {
                    self2.postMessage(false);
                    return;
                  }
                  Promise.resolve().then(function() {
                    var canvas2 = new OffscreenCanvas(10, 10);
                    var ctx = canvas2.getContext("2d");
                    ctx.rect(0, 0, 1, 1);
                    return createImageBitmap(canvas2, 0, 0, 1, 1);
                  }).then(function() {
                    return self2.postMessage(true);
                  }, function() {
                    return self2.postMessage(false);
                  });
                }
                var code = btoa("(".concat(workerPayload.toString(), ")(self);"));
                var w = new Worker("data:text/javascript;base64,".concat(code));
                w.onmessage = function(ev) {
                  return resolve(ev.data);
                };
                w.onerror = reject;
              }).then(function(result) {
                return result;
              }, function() {
                return false;
              });
            };
            module3.exports.can_use_canvas = function can_use_canvas(createCanvas) {
              var usable = false;
              try {
                var canvas2 = createCanvas(2, 1);
                var ctx = canvas2.getContext("2d");
                var d = ctx.createImageData(2, 1);
                d.data[0] = 12;
                d.data[1] = 23;
                d.data[2] = 34;
                d.data[3] = 255;
                d.data[4] = 45;
                d.data[5] = 56;
                d.data[6] = 67;
                d.data[7] = 255;
                ctx.putImageData(d, 0, 0);
                d = null;
                d = ctx.getImageData(0, 0, 2, 1);
                if (d.data[0] === 12 && d.data[1] === 23 && d.data[2] === 34 && d.data[3] === 255 && d.data[4] === 45 && d.data[5] === 56 && d.data[6] === 67 && d.data[7] === 255) {
                  usable = true;
                }
              } catch (err2) {
              }
              return usable;
            };
            module3.exports.cib_can_use_region = function cib_can_use_region() {
              return new Promise(function(resolve) {
                if (typeof Image === "undefined" || typeof createImageBitmap === "undefined") {
                  resolve(false);
                  return;
                }
                var image = new Image();
                image.src = "data:image/jpeg;base64,/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRcZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRAf/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z";
                image.onload = function() {
                  createImageBitmap(image, 0, 0, image.width, image.height).then(function(bitmap) {
                    if (bitmap.width === image.width && bitmap.height === image.height) {
                      resolve(true);
                    } else {
                      resolve(false);
                    }
                  }, function() {
                    return resolve(false);
                  });
                };
                image.onerror = function() {
                  return resolve(false);
                };
              });
            };
          }, {}], 17: [function(_dereq_, module3, exports3) {
            module3.exports = function() {
              var MathLib = _dereq_("./mathlib");
              var mathLib;
              onmessage = function onmessage2(ev) {
                var tileOpts = ev.data.opts;
                if (!tileOpts.src && tileOpts.srcBitmap) {
                  var canvas2 = new OffscreenCanvas(tileOpts.width, tileOpts.height);
                  var ctx = canvas2.getContext("2d");
                  ctx.drawImage(tileOpts.srcBitmap, 0, 0);
                  tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data;
                  canvas2.width = canvas2.height = 0;
                  canvas2 = null;
                  tileOpts.srcBitmap.close();
                  tileOpts.srcBitmap = null;
                }
                if (!mathLib) mathLib = new MathLib(ev.data.features);
                var data2 = mathLib.resizeAndUnsharp(tileOpts);
                {
                  postMessage({
                    data: data2
                  }, [data2.buffer]);
                }
              };
            };
          }, { "./mathlib": 1 }], 18: [function(_dereq_, module3, exports3) {
            var a0, a1, a2, a3, b1, b2, left_corner, right_corner;
            function gaussCoef(sigma) {
              if (sigma < 0.5) {
                sigma = 0.5;
              }
              var a = Math.exp(0.726 * 0.726) / sigma, g1 = Math.exp(-a), g2 = Math.exp(-2 * a), k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);
              a0 = k;
              a1 = k * (a - 1) * g1;
              a2 = k * (a + 1) * g1;
              a3 = -k * g2;
              b1 = 2 * g1;
              b2 = -g2;
              left_corner = (a0 + a1) / (1 - b1 - b2);
              right_corner = (a2 + a3) / (1 - b1 - b2);
              return new Float32Array([a0, a1, a2, a3, b1, b2, left_corner, right_corner]);
            }
            function convolveMono16(src, out, line, coeff, width, height) {
              var prev_src, curr_src, curr_out, prev_out, prev_prev_out;
              var src_index, out_index, line_index;
              var i, j;
              var coeff_a0, coeff_a1, coeff_b1, coeff_b2;
              for (i = 0; i < height; i++) {
                src_index = i * width;
                out_index = i;
                line_index = 0;
                prev_src = src[src_index];
                prev_prev_out = prev_src * coeff[6];
                prev_out = prev_prev_out;
                coeff_a0 = coeff[0];
                coeff_a1 = coeff[1];
                coeff_b1 = coeff[4];
                coeff_b2 = coeff[5];
                for (j = 0; j < width; j++) {
                  curr_src = src[src_index];
                  curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
                  prev_prev_out = prev_out;
                  prev_out = curr_out;
                  prev_src = curr_src;
                  line[line_index] = prev_out;
                  line_index++;
                  src_index++;
                }
                src_index--;
                line_index--;
                out_index += height * (width - 1);
                prev_src = src[src_index];
                prev_prev_out = prev_src * coeff[7];
                prev_out = prev_prev_out;
                curr_src = prev_src;
                coeff_a0 = coeff[2];
                coeff_a1 = coeff[3];
                for (j = width - 1; j >= 0; j--) {
                  curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2;
                  prev_prev_out = prev_out;
                  prev_out = curr_out;
                  prev_src = curr_src;
                  curr_src = src[src_index];
                  out[out_index] = line[line_index] + prev_out;
                  src_index--;
                  line_index--;
                  out_index -= height;
                }
              }
            }
            function blurMono16(src, width, height, radius) {
              if (!radius) {
                return;
              }
              var out = new Uint16Array(src.length), tmp_line = new Float32Array(Math.max(width, height));
              var coeff = gaussCoef(radius);
              convolveMono16(src, out, tmp_line, coeff, width, height);
              convolveMono16(out, src, tmp_line, coeff, height, width);
            }
            module3.exports = blurMono16;
          }, {}], 19: [function(_dereq_, module3, exports3) {
            var assign = _dereq_("object-assign");
            var base64decode = _dereq_("./lib/base64decode");
            var hasWebAssembly = _dereq_("./lib/wa_detect");
            var DEFAULT_OPTIONS = {
              js: true,
              wasm: true
            };
            function MultiMath(options) {
              if (!(this instanceof MultiMath)) return new MultiMath(options);
              var opts = assign({}, DEFAULT_OPTIONS, options || {});
              this.options = opts;
              this.__cache = {};
              this.__init_promise = null;
              this.__modules = opts.modules || {};
              this.__memory = null;
              this.__wasm = {};
              this.__isLE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;
              if (!this.options.js && !this.options.wasm) {
                throw new Error('mathlib: at least "js" or "wasm" should be enabled');
              }
            }
            MultiMath.prototype.has_wasm = hasWebAssembly;
            MultiMath.prototype.use = function(module4) {
              this.__modules[module4.name] = module4;
              if (this.options.wasm && this.has_wasm() && module4.wasm_fn) {
                this[module4.name] = module4.wasm_fn;
              } else {
                this[module4.name] = module4.fn;
              }
              return this;
            };
            MultiMath.prototype.init = function() {
              if (this.__init_promise) return this.__init_promise;
              if (!this.options.js && this.options.wasm && !this.has_wasm()) {
                return Promise.reject(new Error(`mathlib: only "wasm" was enabled, but it's not supported`));
              }
              var self2 = this;
              this.__init_promise = Promise.all(Object.keys(self2.__modules).map(function(name) {
                var module4 = self2.__modules[name];
                if (!self2.options.wasm || !self2.has_wasm() || !module4.wasm_fn) return null;
                if (self2.__wasm[name]) return null;
                return WebAssembly.compile(self2.__base64decode(module4.wasm_src)).then(function(m) {
                  self2.__wasm[name] = m;
                });
              })).then(function() {
                return self2;
              });
              return this.__init_promise;
            };
            MultiMath.prototype.__base64decode = base64decode;
            MultiMath.prototype.__reallocate = function mem_grow_to(bytes) {
              if (!this.__memory) {
                this.__memory = new WebAssembly.Memory({
                  initial: Math.ceil(bytes / (64 * 1024))
                });
                return this.__memory;
              }
              var mem_size = this.__memory.buffer.byteLength;
              if (mem_size < bytes) {
                this.__memory.grow(Math.ceil((bytes - mem_size) / (64 * 1024)));
              }
              return this.__memory;
            };
            MultiMath.prototype.__instance = function instance(name, memsize, env_extra) {
              if (memsize) this.__reallocate(memsize);
              if (!this.__wasm[name]) {
                var module4 = this.__modules[name];
                this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module4.wasm_src));
              }
              if (!this.__cache[name]) {
                var env_base = {
                  memoryBase: 0,
                  memory: this.__memory,
                  tableBase: 0,
                  table: new WebAssembly.Table({ initial: 0, element: "anyfunc" })
                };
                this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {
                  env: assign(env_base, env_extra || {})
                });
              }
              return this.__cache[name];
            };
            MultiMath.prototype.__align = function align(number2, base) {
              base = base || 8;
              var reminder = number2 % base;
              return number2 + (reminder ? base - reminder : 0);
            };
            module3.exports = MultiMath;
          }, { "./lib/base64decode": 20, "./lib/wa_detect": 21, "object-assign": 22 }], 20: [function(_dereq_, module3, exports3) {
            var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            module3.exports = function base64decode(str) {
              var input = str.replace(/[\r\n=]/g, ""), max = input.length;
              var out = new Uint8Array(max * 3 >> 2);
              var bits = 0;
              var ptr = 0;
              for (var idx = 0; idx < max; idx++) {
                if (idx % 4 === 0 && idx) {
                  out[ptr++] = bits >> 16 & 255;
                  out[ptr++] = bits >> 8 & 255;
                  out[ptr++] = bits & 255;
                }
                bits = bits << 6 | BASE64_MAP.indexOf(input.charAt(idx));
              }
              var tailbits = max % 4 * 6;
              if (tailbits === 0) {
                out[ptr++] = bits >> 16 & 255;
                out[ptr++] = bits >> 8 & 255;
                out[ptr++] = bits & 255;
              } else if (tailbits === 18) {
                out[ptr++] = bits >> 10 & 255;
                out[ptr++] = bits >> 2 & 255;
              } else if (tailbits === 12) {
                out[ptr++] = bits >> 4 & 255;
              }
              return out;
            };
          }, {}], 21: [function(_dereq_, module3, exports3) {
            var wa;
            module3.exports = function hasWebAssembly() {
              if (typeof wa !== "undefined") return wa;
              wa = false;
              if (typeof WebAssembly === "undefined") return wa;
              try {
                var bin2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]);
                var module4 = new WebAssembly.Module(bin2);
                var instance = new WebAssembly.Instance(module4, {});
                if (instance.exports.test(4) !== 0) wa = true;
                return wa;
              } catch (__) {
              }
              return wa;
            };
          }, {}], 22: [function(_dereq_, module3, exports3) {
            var getOwnPropertySymbols = Object.getOwnPropertySymbols;
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var propIsEnumerable = Object.prototype.propertyIsEnumerable;
            function toObject(val) {
              if (val === null || val === void 0) {
                throw new TypeError("Object.assign cannot be called with null or undefined");
              }
              return Object(val);
            }
            function shouldUseNative() {
              try {
                if (!Object.assign) {
                  return false;
                }
                var test1 = new String("abc");
                test1[5] = "de";
                if (Object.getOwnPropertyNames(test1)[0] === "5") {
                  return false;
                }
                var test2 = {};
                for (var i = 0; i < 10; i++) {
                  test2["_" + String.fromCharCode(i)] = i;
                }
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                  return test2[n];
                });
                if (order2.join("") !== "0123456789") {
                  return false;
                }
                var test3 = {};
                "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                  test3[letter] = letter;
                });
                if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                  return false;
                }
                return true;
              } catch (err2) {
                return false;
              }
            }
            module3.exports = shouldUseNative() ? Object.assign : function(target, source) {
              var from;
              var to = toObject(target);
              var symbols;
              for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) {
                  if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                  }
                }
                if (getOwnPropertySymbols) {
                  symbols = getOwnPropertySymbols(from);
                  for (var i = 0; i < symbols.length; i++) {
                    if (propIsEnumerable.call(from, symbols[i])) {
                      to[symbols[i]] = from[symbols[i]];
                    }
                  }
                }
              }
              return to;
            };
          }, {}], 23: [function(_dereq_, module3, exports3) {
            var bundleFn = arguments[3];
            var sources = arguments[4];
            var cache = arguments[5];
            var stringify = JSON.stringify;
            module3.exports = function(fn, options) {
              var wkey;
              var cacheKeys = Object.keys(cache);
              for (var i = 0, l = cacheKeys.length; i < l; i++) {
                var key = cacheKeys[i];
                var exp = cache[key].exports;
                if (exp === fn || exp && exp.default === fn) {
                  wkey = key;
                  break;
                }
              }
              if (!wkey) {
                wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
                var wcache = {};
                for (var i = 0, l = cacheKeys.length; i < l; i++) {
                  var key = cacheKeys[i];
                  wcache[key] = key;
                }
                sources[wkey] = [
                  "function(require,module,exports){" + fn + "(self); }",
                  wcache
                ];
              }
              var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
              var scache = {};
              scache[wkey] = wkey;
              sources[skey] = [
                "function(require,module,exports){var f = require(" + stringify(wkey) + ");(f.default ? f.default : f)(self);}",
                scache
              ];
              var workerSources = {};
              resolveSources(skey);
              function resolveSources(key2) {
                workerSources[key2] = true;
                for (var depPath in sources[key2][1]) {
                  var depKey = sources[key2][1][depPath];
                  if (!workerSources[depKey]) {
                    resolveSources(depKey);
                  }
                }
              }
              var src = "(" + bundleFn + ")({" + Object.keys(workerSources).map(function(key2) {
                return stringify(key2) + ":[" + sources[key2][0] + "," + stringify(sources[key2][1]) + "]";
              }).join(",") + "},{},[" + stringify(skey) + "])";
              var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
              var blob = new Blob([src], { type: "text/javascript" });
              if (options && options.bare) {
                return blob;
              }
              var workerUrl = URL2.createObjectURL(blob);
              var worker = new Worker(workerUrl);
              worker.objectURL = workerUrl;
              return worker;
            };
          }, {}], "/index.js": [function(_dereq_, module3, exports3) {
            function _slicedToArray(arr, i) {
              return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
            }
            function _nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _unsupportedIterableToArray(o, minLen) {
              if (!o) return;
              if (typeof o === "string") return _arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor) n = o.constructor.name;
              if (n === "Map" || n === "Set") return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
            }
            function _arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _iterableToArrayLimit(arr, i) {
              var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
              if (_i == null) return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i) break;
                }
              } catch (err2) {
                _d = true;
                _e = err2;
              } finally {
                try {
                  if (!_n && _i["return"] != null) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles(arr) {
              if (Array.isArray(arr)) return arr;
            }
            var assign = _dereq_("object-assign");
            var webworkify = _dereq_("webworkify");
            var MathLib = _dereq_("./lib/mathlib");
            var Pool = _dereq_("./lib/pool");
            var utils2 = _dereq_("./lib/utils");
            var worker = _dereq_("./lib/worker");
            var createStages = _dereq_("./lib/stepper");
            var createRegions = _dereq_("./lib/tiler");
            var filter_info = _dereq_("./lib/mm_resize/resize_filter_info");
            var singletones = {};
            var NEED_SAFARI_FIX = false;
            try {
              if (typeof navigator !== "undefined" && navigator.userAgent) {
                NEED_SAFARI_FIX = navigator.userAgent.indexOf("Safari") >= 0;
              }
            } catch (e) {
            }
            var concurrency = 1;
            if (typeof navigator !== "undefined") {
              concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);
            }
            var DEFAULT_PICA_OPTS = {
              tile: 1024,
              concurrency,
              features: ["js", "wasm", "ww"],
              idle: 2e3,
              createCanvas: function createCanvas(width, height) {
                var tmpCanvas = document.createElement("canvas");
                tmpCanvas.width = width;
                tmpCanvas.height = height;
                return tmpCanvas;
              }
            };
            var DEFAULT_RESIZE_OPTS = {
              filter: "mks2013",
              unsharpAmount: 0,
              unsharpRadius: 0,
              unsharpThreshold: 0
            };
            var CAN_NEW_IMAGE_DATA = false;
            var CAN_CREATE_IMAGE_BITMAP = false;
            var CAN_USE_CANVAS_GET_IMAGE_DATA = false;
            var CAN_USE_OFFSCREEN_CANVAS = false;
            var CAN_USE_CIB_REGION_FOR_IMAGE = false;
            function workerFabric() {
              return {
                value: webworkify(worker),
                destroy: function destroy() {
                  this.value.terminate();
                  if (typeof window !== "undefined") {
                    var url2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
                    if (url2 && url2.revokeObjectURL && this.value.objectURL) {
                      url2.revokeObjectURL(this.value.objectURL);
                    }
                  }
                }
              };
            }
            function Pica(options) {
              if (!(this instanceof Pica)) return new Pica(options);
              this.options = assign({}, DEFAULT_PICA_OPTS, options || {});
              var limiter_key = "lk_".concat(this.options.concurrency);
              this.__limit = singletones[limiter_key] || utils2.limiter(this.options.concurrency);
              if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit;
              this.features = {
                js: false,
                // pure JS implementation, can be disabled for testing
                wasm: false,
                // webassembly implementation for heavy functions
                cib: false,
                // resize via createImageBitmap (only FF at this moment)
                ww: false
                // webworkers
              };
              this.__workersPool = null;
              this.__requested_features = [];
              this.__mathlib = null;
            }
            Pica.prototype.init = function() {
              var _this = this;
              if (this.__initPromise) return this.__initPromise;
              if (typeof ImageData !== "undefined" && typeof Uint8ClampedArray !== "undefined") {
                try {
                  new ImageData(new Uint8ClampedArray(400), 10, 10);
                  CAN_NEW_IMAGE_DATA = true;
                } catch (__) {
                }
              }
              if (typeof ImageBitmap !== "undefined") {
                if (ImageBitmap.prototype && ImageBitmap.prototype.close) {
                  CAN_CREATE_IMAGE_BITMAP = true;
                } else {
                  this.debug("ImageBitmap does not support .close(), disabled");
                }
              }
              var features = this.options.features.slice();
              if (features.indexOf("all") >= 0) {
                features = ["cib", "wasm", "js", "ww"];
              }
              this.__requested_features = features;
              this.__mathlib = new MathLib(features);
              if (features.indexOf("ww") >= 0) {
                if (typeof window !== "undefined" && "Worker" in window) {
                  try {
                    var wkr = _dereq_("webworkify")(function() {
                    });
                    wkr.terminate();
                    this.features.ww = true;
                    var wpool_key = "wp_".concat(JSON.stringify(this.options));
                    if (singletones[wpool_key]) {
                      this.__workersPool = singletones[wpool_key];
                    } else {
                      this.__workersPool = new Pool(workerFabric, this.options.idle);
                      singletones[wpool_key] = this.__workersPool;
                    }
                  } catch (__) {
                  }
                }
              }
              var initMath = this.__mathlib.init().then(function(mathlib) {
                assign(_this.features, mathlib.features);
              });
              var checkCibResize;
              if (!CAN_CREATE_IMAGE_BITMAP) {
                checkCibResize = Promise.resolve(false);
              } else {
                checkCibResize = utils2.cib_support(this.options.createCanvas).then(function(status) {
                  if (_this.features.cib && features.indexOf("cib") < 0) {
                    _this.debug("createImageBitmap() resize supported, but disabled by config");
                    return;
                  }
                  if (features.indexOf("cib") >= 0) _this.features.cib = status;
                });
              }
              CAN_USE_CANVAS_GET_IMAGE_DATA = utils2.can_use_canvas(this.options.createCanvas);
              var checkOffscreenCanvas;
              if (CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && features.indexOf("ww") !== -1) {
                checkOffscreenCanvas = utils2.worker_offscreen_canvas_support();
              } else {
                checkOffscreenCanvas = Promise.resolve(false);
              }
              checkOffscreenCanvas = checkOffscreenCanvas.then(function(result) {
                CAN_USE_OFFSCREEN_CANVAS = result;
              });
              var checkCibRegion = utils2.cib_can_use_region().then(function(result) {
                CAN_USE_CIB_REGION_FOR_IMAGE = result;
              });
              this.__initPromise = Promise.all([initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion]).then(function() {
                return _this;
              });
              return this.__initPromise;
            };
            Pica.prototype.__invokeResize = function(tileOpts, opts) {
              var _this2 = this;
              opts.__mathCache = opts.__mathCache || {};
              return Promise.resolve().then(function() {
                if (!_this2.features.ww) {
                  return {
                    data: _this2.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)
                  };
                }
                return new Promise(function(resolve, reject) {
                  var w = _this2.__workersPool.acquire();
                  if (opts.cancelToken) opts.cancelToken["catch"](function(err2) {
                    return reject(err2);
                  });
                  w.value.onmessage = function(ev) {
                    w.release();
                    if (ev.data.err) reject(ev.data.err);
                    else resolve(ev.data);
                  };
                  var transfer = [];
                  if (tileOpts.src) transfer.push(tileOpts.src.buffer);
                  if (tileOpts.srcBitmap) transfer.push(tileOpts.srcBitmap);
                  w.value.postMessage({
                    opts: tileOpts,
                    features: _this2.__requested_features,
                    preload: {
                      wasm_nodule: _this2.__mathlib.__
                    }
                  }, transfer);
                });
              });
            };
            Pica.prototype.__extractTileData = function(tile, from, opts, stageEnv, extractTo) {
              if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,
              // can use canvas because canvas doesn't have orientation;
              // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671
              (utils2.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) {
                this.debug("Create tile for OffscreenCanvas");
                return createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then(function(bitmap) {
                  extractTo.srcBitmap = bitmap;
                  return extractTo;
                });
              }
              if (utils2.isCanvas(from)) {
                if (!stageEnv.srcCtx) stageEnv.srcCtx = from.getContext("2d");
                this.debug("Get tile pixel data");
                extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data;
                return extractTo;
              }
              this.debug("Draw tile imageBitmap/image to temporary canvas");
              var tmpCanvas = this.options.createCanvas(tile.width, tile.height);
              var tmpCtx = tmpCanvas.getContext("2d");
              tmpCtx.globalCompositeOperation = "copy";
              tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);
              this.debug("Get tile pixel data");
              extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data;
              tmpCanvas.width = tmpCanvas.height = 0;
              return extractTo;
            };
            Pica.prototype.__landTileData = function(tile, result, stageEnv) {
              var toImageData;
              this.debug("Convert raw rgba tile result to ImageData");
              if (result.bitmap) {
                stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY);
                return null;
              }
              if (CAN_NEW_IMAGE_DATA) {
                toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight);
              } else {
                toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight);
                if (toImageData.data.set) {
                  toImageData.data.set(result.data);
                } else {
                  for (var i = toImageData.data.length - 1; i >= 0; i--) {
                    toImageData.data[i] = result.data[i];
                  }
                }
              }
              this.debug("Draw tile");
              if (NEED_SAFARI_FIX) {
                stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);
              } else {
                stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);
              }
              return null;
            };
            Pica.prototype.__tileAndResize = function(from, to, opts) {
              var _this3 = this;
              var stageEnv = {
                srcCtx: null,
                srcImageBitmap: null,
                isImageBitmapReused: false,
                toCtx: null
              };
              var processTile = function processTile2(tile) {
                return _this3.__limit(function() {
                  if (opts.canceled) return opts.cancelToken;
                  var tileOpts = {
                    width: tile.width,
                    height: tile.height,
                    toWidth: tile.toWidth,
                    toHeight: tile.toHeight,
                    scaleX: tile.scaleX,
                    scaleY: tile.scaleY,
                    offsetX: tile.offsetX,
                    offsetY: tile.offsetY,
                    filter: opts.filter,
                    unsharpAmount: opts.unsharpAmount,
                    unsharpRadius: opts.unsharpRadius,
                    unsharpThreshold: opts.unsharpThreshold
                  };
                  _this3.debug("Invoke resize math");
                  return Promise.resolve(tileOpts).then(function(tileOpts2) {
                    return _this3.__extractTileData(tile, from, opts, stageEnv, tileOpts2);
                  }).then(function(tileOpts2) {
                    _this3.debug("Invoke resize math");
                    return _this3.__invokeResize(tileOpts2, opts);
                  }).then(function(result) {
                    if (opts.canceled) return opts.cancelToken;
                    stageEnv.srcImageData = null;
                    return _this3.__landTileData(tile, result, stageEnv);
                  });
                });
              };
              return Promise.resolve().then(function() {
                stageEnv.toCtx = to.getContext("2d");
                if (utils2.isCanvas(from)) return null;
                if (utils2.isImageBitmap(from)) {
                  stageEnv.srcImageBitmap = from;
                  stageEnv.isImageBitmapReused = true;
                  return null;
                }
                if (utils2.isImage(from)) {
                  if (!CAN_CREATE_IMAGE_BITMAP) return null;
                  _this3.debug("Decode image via createImageBitmap");
                  return createImageBitmap(from).then(function(imageBitmap) {
                    stageEnv.srcImageBitmap = imageBitmap;
                  })["catch"](function(e) {
                    return null;
                  });
                }
                throw new Error('Pica: ".from" should be Image, Canvas or ImageBitmap');
              }).then(function() {
                if (opts.canceled) return opts.cancelToken;
                _this3.debug("Calculate tiles");
                var regions = createRegions({
                  width: opts.width,
                  height: opts.height,
                  srcTileSize: _this3.options.tile,
                  toWidth: opts.toWidth,
                  toHeight: opts.toHeight,
                  destTileBorder: opts.__destTileBorder
                });
                var jobs = regions.map(function(tile) {
                  return processTile(tile);
                });
                function cleanup(stageEnv2) {
                  if (stageEnv2.srcImageBitmap) {
                    if (!stageEnv2.isImageBitmapReused) stageEnv2.srcImageBitmap.close();
                    stageEnv2.srcImageBitmap = null;
                  }
                }
                _this3.debug("Process tiles");
                return Promise.all(jobs).then(function() {
                  _this3.debug("Finished!");
                  cleanup(stageEnv);
                  return to;
                }, function(err2) {
                  cleanup(stageEnv);
                  throw err2;
                });
              });
            };
            Pica.prototype.__processStages = function(stages, from, to, opts) {
              var _this4 = this;
              if (opts.canceled) return opts.cancelToken;
              var _stages$shift = stages.shift(), _stages$shift2 = _slicedToArray(_stages$shift, 2), toWidth = _stages$shift2[0], toHeight = _stages$shift2[1];
              var isLastStage = stages.length === 0;
              var filter;
              if (isLastStage || filter_info.q2f.indexOf(opts.filter) < 0) filter = opts.filter;
              else if (opts.filter === "box") filter = "box";
              else filter = "hamming";
              opts = assign({}, opts, {
                toWidth,
                toHeight,
                filter
              });
              var tmpCanvas;
              if (!isLastStage) {
                tmpCanvas = this.options.createCanvas(toWidth, toHeight);
              }
              return this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function() {
                if (isLastStage) return to;
                opts.width = toWidth;
                opts.height = toHeight;
                return _this4.__processStages(stages, tmpCanvas, to, opts);
              }).then(function(res) {
                if (tmpCanvas) {
                  tmpCanvas.width = tmpCanvas.height = 0;
                }
                return res;
              });
            };
            Pica.prototype.__resizeViaCreateImageBitmap = function(from, to, opts) {
              var _this5 = this;
              var toCtx = to.getContext("2d");
              this.debug("Resize via createImageBitmap()");
              return createImageBitmap(from, {
                resizeWidth: opts.toWidth,
                resizeHeight: opts.toHeight,
                resizeQuality: utils2.cib_quality_name(filter_info.f2q[opts.filter])
              }).then(function(imageBitmap) {
                if (opts.canceled) return opts.cancelToken;
                if (!opts.unsharpAmount) {
                  toCtx.drawImage(imageBitmap, 0, 0);
                  imageBitmap.close();
                  toCtx = null;
                  _this5.debug("Finished!");
                  return to;
                }
                _this5.debug("Unsharp result");
                var tmpCanvas = _this5.options.createCanvas(opts.toWidth, opts.toHeight);
                var tmpCtx = tmpCanvas.getContext("2d");
                tmpCtx.drawImage(imageBitmap, 0, 0);
                imageBitmap.close();
                var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);
                _this5.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);
                toCtx.putImageData(iData, 0, 0);
                tmpCanvas.width = tmpCanvas.height = 0;
                iData = tmpCtx = tmpCanvas = toCtx = null;
                _this5.debug("Finished!");
                return to;
              });
            };
            Pica.prototype.resize = function(from, to, options) {
              var _this6 = this;
              this.debug("Start resize...");
              var opts = assign({}, DEFAULT_RESIZE_OPTS);
              if (!isNaN(options)) {
                opts = assign(opts, {
                  quality: options
                });
              } else if (options) {
                opts = assign(opts, options);
              }
              opts.toWidth = to.width;
              opts.toHeight = to.height;
              opts.width = from.naturalWidth || from.width;
              opts.height = from.naturalHeight || from.height;
              if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
                if (opts.quality < 0 || opts.quality > 3) {
                  throw new Error("Pica: .quality should be [0..3], got ".concat(opts.quality));
                }
                opts.filter = filter_info.q2f[opts.quality];
              }
              if (to.width === 0 || to.height === 0) {
                return Promise.reject(new Error("Invalid output size: ".concat(to.width, "x").concat(to.height)));
              }
              if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;
              opts.canceled = false;
              if (opts.cancelToken) {
                opts.cancelToken = opts.cancelToken.then(function(data2) {
                  opts.canceled = true;
                  throw data2;
                }, function(err2) {
                  opts.canceled = true;
                  throw err2;
                });
              }
              var DEST_TILE_BORDER = 3;
              opts.__destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));
              return this.init().then(function() {
                if (opts.canceled) return opts.cancelToken;
                if (_this6.features.cib) {
                  if (filter_info.q2f.indexOf(opts.filter) >= 0) {
                    return _this6.__resizeViaCreateImageBitmap(from, to, opts);
                  }
                  _this6.debug("cib is enabled, but not supports provided filter, fallback to manual math");
                }
                if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {
                  var err2 = new Error("Pica: cannot use getImageData on canvas, make sure fingerprinting protection isn't enabled");
                  err2.code = "ERR_GET_IMAGE_DATA";
                  throw err2;
                }
                var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this6.options.tile, opts.__destTileBorder);
                return _this6.__processStages(stages, from, to, opts);
              });
            };
            Pica.prototype.resizeBuffer = function(options) {
              var _this7 = this;
              var opts = assign({}, DEFAULT_RESIZE_OPTS, options);
              if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
                if (opts.quality < 0 || opts.quality > 3) {
                  throw new Error("Pica: .quality should be [0..3], got ".concat(opts.quality));
                }
                opts.filter = filter_info.q2f[opts.quality];
              }
              return this.init().then(function() {
                return _this7.__mathlib.resizeAndUnsharp(opts);
              });
            };
            Pica.prototype.toBlob = function(canvas2, mimeType, quality) {
              mimeType = mimeType || "image/png";
              return new Promise(function(resolve) {
                if (canvas2.toBlob) {
                  canvas2.toBlob(function(blob) {
                    return resolve(blob);
                  }, mimeType, quality);
                  return;
                }
                if (canvas2.convertToBlob) {
                  resolve(canvas2.convertToBlob({
                    type: mimeType,
                    quality
                  }));
                  return;
                }
                var asString = atob(canvas2.toDataURL(mimeType, quality).split(",")[1]);
                var len = asString.length;
                var asBuffer = new Uint8Array(len);
                for (var i = 0; i < len; i++) {
                  asBuffer[i] = asString.charCodeAt(i);
                }
                resolve(new Blob([asBuffer], {
                  type: mimeType
                }));
              });
            };
            Pica.prototype.debug = function() {
            };
            module3.exports = Pica;
          }, { "./lib/mathlib": 1, "./lib/mm_resize/resize_filter_info": 7, "./lib/pool": 13, "./lib/stepper": 14, "./lib/tiler": 15, "./lib/utils": 16, "./lib/worker": 17, "object-assign": 22, "webworkify": 23 }] }, {}, [])("/index.js");
        });
      })(pica);
      return pica.exports;
    }
    requirePica();
    function JazzReactProvider({
      children,
      guestMode,
      sync,
      storage,
      AccountSchema,
      defaultProfileName,
      onLogOut,
      logOutReplacement,
      onAnonymousAccountDiscarded,
      enableSSR
    }) {
      const [contextManager] = React.useState(
        () => new JazzBrowserContextManager({
          useAnonymousFallback: enableSSR
        })
      );
      const onLogOutRefCallback = useRefCallback(onLogOut);
      const logOutReplacementRefCallback = useRefCallback(logOutReplacement);
      const onAnonymousAccountDiscardedRefCallback = useRefCallback(
        onAnonymousAccountDiscarded
      );
      const logoutReplacementActiveRef = reactExports.useRef(false);
      logoutReplacementActiveRef.current = Boolean(logOutReplacement);
      const value = React.useSyncExternalStore(
        React.useCallback(
          (callback) => {
            const props = {
              AccountSchema,
              guestMode,
              sync,
              storage,
              defaultProfileName,
              onLogOut: onLogOutRefCallback,
              logOutReplacement: logoutReplacementActiveRef.current ? logOutReplacementRefCallback : void 0,
              onAnonymousAccountDiscarded: onAnonymousAccountDiscardedRefCallback
            };
            if (contextManager.propsChanged(props)) {
              contextManager.createContext(props).catch((error2) => {
                console.log(error2.stack);
                console.error("Error creating Jazz browser context:", error2);
              });
            }
            return contextManager.subscribe(callback);
          },
          [sync, guestMode].concat(storage)
        ),
        () => contextManager.getCurrentValue(),
        () => contextManager.getCurrentValue()
      );
      reactExports.useEffect(() => {
        return () => {
          contextManager.done();
        };
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(JazzContext.Provider, { value, children: /* @__PURE__ */ jsxRuntimeExports.jsx(JazzContextManagerContext.Provider, { value: contextManager, children: value && children }) });
    }
    function useRefCallback(callback) {
      const callbackRef = React.useRef(callback);
      callbackRef.current = callback;
      return reactExports.useRef(
        (...args) => {
          var _a;
          return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
        }
      ).current;
    }
    function useAcceptInvite({
      invitedObjectSchema,
      onAccept,
      forValueHint
    }) {
      const context = useJazzContext();
      if (!("me" in context)) {
        throw new Error(
          "useAcceptInvite can't be used in a JazzProvider with auth === 'guest'."
        );
      }
      reactExports.useEffect(() => {
        const handleInvite = () => {
          const result = consumeInviteLinkFromWindowLocation({
            as: context.me,
            invitedObjectSchema,
            forValueHint
          });
          result.then((result2) => result2 && onAccept(result2 == null ? void 0 : result2.valueID)).catch((e) => {
            console.error("Failed to accept invite", e);
          });
        };
        handleInvite();
        window.addEventListener("hashchange", handleInvite);
        return () => window.removeEventListener("hashchange", handleInvite);
      }, [onAccept]);
    }
    function PassphraseAuthBasicUI(props) {
      const auth = usePassphraseAuth({
        wordlist: props.wordlist
      });
      const [step, setStep] = reactExports.useState("initial");
      const [loginPassphrase, setLoginPassphrase] = reactExports.useState("");
      const [isCopied, setIsCopied] = reactExports.useState(false);
      if (auth.state === "signedIn") {
        return props.children ?? null;
      }
      const handleCreateAccount = async () => {
        setStep("create");
      };
      const handleLogin = () => {
        setStep("login");
      };
      const handleBack = () => {
        setStep("initial");
        setLoginPassphrase("");
      };
      const handleCopy = async () => {
        await navigator.clipboard.writeText(auth.passphrase);
        setIsCopied(true);
      };
      const handleLoginSubmit = async () => {
        await auth.logIn(loginPassphrase);
        setStep("initial");
        setLoginPassphrase("");
      };
      const handleNext = async () => {
        await auth.signUp();
        setStep("initial");
        setLoginPassphrase("");
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: containerStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: cardStyle, children: [
        step === "initial" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { style: headingStyle, children: props.appName }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleCreateAccount, style: primaryButtonStyle, children: "Create new account" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleLogin, style: secondaryButtonStyle, children: "Log in" })
        ] }),
        step === "create" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { style: headingStyle, children: "Your Passphrase" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: "0.875rem",
                color: "#4b5563",
                textAlign: "center",
                marginBottom: "1rem"
              },
              children: "Please copy and store this passphrase somewhere safe. You'll need it to log in."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              readOnly: true,
              value: auth.passphrase,
              style: textareaStyle,
              rows: 5
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                gap: "1rem"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleBack, style: secondaryButtonStyle, children: "Back" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleCopy, style: primaryButtonStyle, children: isCopied ? "Copied!" : "Copy Passphrase" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleNext, style: primaryButtonStyle, children: "I have saved it!" })
              ]
            }
          )
        ] }),
        step === "login" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { style: headingStyle, children: "Log In" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: loginPassphrase,
              onChange: (e) => setLoginPassphrase(e.target.value),
              placeholder: "Enter your passphrase",
              style: textareaStyle,
              rows: 5
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                gap: "1rem"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleBack, style: secondaryButtonStyle, children: "Back" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleLoginSubmit, style: primaryButtonStyle, children: "Log In" })
              ]
            }
          )
        ] })
      ] }) });
    }
    var containerStyle = {
      minHeight: "100vh",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      backgroundColor: "#f3f4f6"
    };
    var cardStyle = {
      backgroundColor: "white",
      padding: "2rem",
      borderRadius: "0.5rem",
      boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
      width: "24rem"
    };
    var buttonStyle = {
      width: "100%",
      padding: "0.5rem 1rem",
      borderRadius: "0.25rem",
      fontWeight: "bold",
      cursor: "pointer",
      marginBottom: "1rem"
    };
    var primaryButtonStyle = {
      ...buttonStyle,
      backgroundColor: "black",
      color: "white",
      border: "none"
    };
    var secondaryButtonStyle = {
      ...buttonStyle,
      backgroundColor: "white",
      color: "black",
      border: "1px solid black"
    };
    var headingStyle = {
      color: "black",
      fontSize: "1.5rem",
      fontWeight: "bold",
      textAlign: "center",
      marginBottom: "1rem"
    };
    var textareaStyle = {
      width: "100%",
      padding: "0.5rem",
      border: "1px solid #d1d5db",
      borderRadius: "0.25rem",
      marginBottom: "1rem",
      boxSizing: "border-box"
    };
    const Task = coExport_exports.map({
      done: zodReExport_exports.boolean(),
      text: coExport_exports.plainText(),
      version: zodReExport_exports.literal(1)
    }).withMigration((task) => {
      if (!task.version) {
        const task_v1 = task.castAs(Task_V1);
        if (!task_v1.text.startsWith("co_z")) {
          task.text = CoPlainText.create(task_v1.text, task._owner);
        }
        task.version = 1;
      }
    });
    const Task_V1 = coExport_exports.map({
      done: zodReExport_exports.boolean(),
      text: zodReExport_exports.string()
    });
    const TodoProject = coExport_exports.map({
      title: zodReExport_exports.string(),
      tasks: coExport_exports.list(Task)
    });
    const TodoAccountRoot = coExport_exports.map({
      projects: coExport_exports.list(TodoProject)
    });
    const TodoAccount = coExport_exports.account({
      profile: coExport_exports.profile(),
      root: TodoAccountRoot
    }).withMigration(async (account) => {
      if (account.root === void 0) {
        account.root = TodoAccountRoot.create({
          projects: coExport_exports.list(TodoProject).create([], { owner: account })
        });
      }
    });
    function setRef(ref2, value) {
      if (typeof ref2 === "function") {
        return ref2(value);
      } else if (ref2 !== null && ref2 !== void 0) {
        ref2.current = value;
      }
    }
    function composeRefs(...refs) {
      return (node) => {
        let hasCleanup = false;
        const cleanups = refs.map((ref2) => {
          const cleanup = setRef(ref2, node);
          if (!hasCleanup && typeof cleanup == "function") {
            hasCleanup = true;
          }
          return cleanup;
        });
        if (hasCleanup) {
          return () => {
            for (let i = 0; i < cleanups.length; i++) {
              const cleanup = cleanups[i];
              if (typeof cleanup == "function") {
                cleanup();
              } else {
                setRef(refs[i], null);
              }
            }
          };
        }
      };
    }
    function useComposedRefs(...refs) {
      return reactExports.useCallback(composeRefs(...refs), refs);
    }
    // @__NO_SIDE_EFFECTS__
    function createSlot(ownerName) {
      const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
      const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
        const { children, ...slotProps } = props;
        const childrenArray = reactExports.Children.toArray(children);
        const slottable = childrenArray.find(isSlottable);
        if (slottable) {
          const newElement = slottable.props.children;
          const newChildren = childrenArray.map((child) => {
            if (child === slottable) {
              if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
              return reactExports.isValidElement(newElement) ? newElement.props.children : null;
            } else {
              return child;
            }
          });
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
      });
      Slot2.displayName = `${ownerName}.Slot`;
      return Slot2;
    }
    var Slot = /* @__PURE__ */ createSlot("Slot");
    // @__NO_SIDE_EFFECTS__
    function createSlotClone(ownerName) {
      const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
        const { children, ...slotProps } = props;
        if (reactExports.isValidElement(children)) {
          const childrenRef = getElementRef$1(children);
          const props2 = mergeProps(slotProps, children.props);
          if (children.type !== reactExports.Fragment) {
            props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
          }
          return reactExports.cloneElement(children, props2);
        }
        return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
      });
      SlotClone.displayName = `${ownerName}.SlotClone`;
      return SlotClone;
    }
    var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
    function isSlottable(child) {
      return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
    }
    function mergeProps(slotProps, childProps) {
      const overrideProps = { ...childProps };
      for (const propName in childProps) {
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName);
        if (isHandler) {
          if (slotPropValue && childPropValue) {
            overrideProps[propName] = (...args) => {
              const result = childPropValue(...args);
              slotPropValue(...args);
              return result;
            };
          } else if (slotPropValue) {
            overrideProps[propName] = slotPropValue;
          }
        } else if (propName === "style") {
          overrideProps[propName] = { ...slotPropValue, ...childPropValue };
        } else if (propName === "className") {
          overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
        }
      }
      return { ...slotProps, ...overrideProps };
    }
    function getElementRef$1(element) {
      var _a, _b;
      let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
      let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
      if (mayWarn) {
        return element.ref;
      }
      getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
      mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
      if (mayWarn) {
        return element.props.ref;
      }
      return element.props.ref || element.ref;
    }
    function r(e) {
      var t, f, n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;
      else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
      } else for (f in e) e[f] && (n && (n += " "), n += f);
      return n;
    }
    function clsx() {
      for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
      return n;
    }
    const falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
    const cx = clsx;
    const cva = (base, config2) => (props) => {
      var _config_compoundVariants;
      if ((config2 === null || config2 === void 0 ? void 0 : config2.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
      const { variants, defaultVariants } = config2;
      const getVariantClassNames = Object.keys(variants).map((variant) => {
        const variantProp = props === null || props === void 0 ? void 0 : props[variant];
        const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
        if (variantProp === null) return null;
        const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
        return variants[variant][variantKey];
      });
      const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
        let [key, value] = param;
        if (value === void 0) {
          return acc;
        }
        acc[key] = value;
        return acc;
      }, {});
      const getCompoundVariantClassNames = config2 === null || config2 === void 0 ? void 0 : (_config_compoundVariants = config2.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
        let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
        return Object.entries(compoundVariantOptions).every((param2) => {
          let [key, value] = param2;
          return Array.isArray(value) ? value.includes({
            ...defaultVariants,
            ...propsWithoutUndefined
          }[key]) : {
            ...defaultVariants,
            ...propsWithoutUndefined
          }[key] === value;
        }) ? [
          ...acc,
          cvClass,
          cvClassName
        ] : acc;
      }, []);
      return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    };
    function twJoin() {
      var index2 = 0;
      var argument;
      var resolvedValue;
      var string2 = "";
      while (index2 < arguments.length) {
        if (argument = arguments[index2++]) {
          if (resolvedValue = toValue(argument)) {
            string2 && (string2 += " ");
            string2 += resolvedValue;
          }
        }
      }
      return string2;
    }
    function toValue(mix) {
      if (typeof mix === "string") {
        return mix;
      }
      var resolvedValue;
      var string2 = "";
      for (var k = 0; k < mix.length; k++) {
        if (mix[k]) {
          if (resolvedValue = toValue(mix[k])) {
            string2 && (string2 += " ");
            string2 += resolvedValue;
          }
        }
      }
      return string2;
    }
    var CLASS_PART_SEPARATOR = "-";
    function createClassUtils(config2) {
      var classMap = createClassMap(config2);
      var conflictingClassGroups = config2.conflictingClassGroups, _config$conflictingCl = config2.conflictingClassGroupModifiers, conflictingClassGroupModifiers = _config$conflictingCl === void 0 ? {} : _config$conflictingCl;
      function getClassGroupId(className) {
        var classParts = className.split(CLASS_PART_SEPARATOR);
        if (classParts[0] === "" && classParts.length !== 1) {
          classParts.shift();
        }
        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
      }
      function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
        var conflicts = conflictingClassGroups[classGroupId] || [];
        if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
          return [].concat(conflicts, conflictingClassGroupModifiers[classGroupId]);
        }
        return conflicts;
      }
      return {
        getClassGroupId,
        getConflictingClassGroupIds
      };
    }
    function getGroupRecursive(classParts, classPartObject) {
      var _a;
      if (classParts.length === 0) {
        return classPartObject.classGroupId;
      }
      var currentClassPart = classParts[0];
      var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
      var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
      if (classGroupFromNextClassPart) {
        return classGroupFromNextClassPart;
      }
      if (classPartObject.validators.length === 0) {
        return void 0;
      }
      var classRest = classParts.join(CLASS_PART_SEPARATOR);
      return (_a = classPartObject.validators.find(function(_ref) {
        var validator = _ref.validator;
        return validator(classRest);
      })) == null ? void 0 : _a.classGroupId;
    }
    var arbitraryPropertyRegex = /^\[(.+)\]$/;
    function getGroupIdForArbitraryProperty(className) {
      if (arbitraryPropertyRegex.test(className)) {
        var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
        var property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
        if (property) {
          return "arbitrary.." + property;
        }
      }
    }
    function createClassMap(config2) {
      var theme = config2.theme, prefix = config2.prefix;
      var classMap = {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      };
      var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config2.classGroups), prefix);
      prefixedClassGroupEntries.forEach(function(_ref2) {
        var classGroupId = _ref2[0], classGroup = _ref2[1];
        processClassesRecursively(classGroup, classMap, classGroupId, theme);
      });
      return classMap;
    }
    function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
      classGroup.forEach(function(classDefinition) {
        if (typeof classDefinition === "string") {
          var classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
          classPartObjectToEdit.classGroupId = classGroupId;
          return;
        }
        if (typeof classDefinition === "function") {
          if (isThemeGetter(classDefinition)) {
            processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
            return;
          }
          classPartObject.validators.push({
            validator: classDefinition,
            classGroupId
          });
          return;
        }
        Object.entries(classDefinition).forEach(function(_ref3) {
          var key = _ref3[0], classGroup2 = _ref3[1];
          processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
        });
      });
    }
    function getPart(classPartObject, path) {
      var currentClassPartObject = classPartObject;
      path.split(CLASS_PART_SEPARATOR).forEach(function(pathPart) {
        if (!currentClassPartObject.nextPart.has(pathPart)) {
          currentClassPartObject.nextPart.set(pathPart, {
            nextPart: /* @__PURE__ */ new Map(),
            validators: []
          });
        }
        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
      });
      return currentClassPartObject;
    }
    function isThemeGetter(func) {
      return func.isThemeGetter;
    }
    function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
      if (!prefix) {
        return classGroupEntries;
      }
      return classGroupEntries.map(function(_ref4) {
        var classGroupId = _ref4[0], classGroup = _ref4[1];
        var prefixedClassGroup = classGroup.map(function(classDefinition) {
          if (typeof classDefinition === "string") {
            return prefix + classDefinition;
          }
          if (typeof classDefinition === "object") {
            return Object.fromEntries(Object.entries(classDefinition).map(function(_ref5) {
              var key = _ref5[0], value = _ref5[1];
              return [prefix + key, value];
            }));
          }
          return classDefinition;
        });
        return [classGroupId, prefixedClassGroup];
      });
    }
    function createLruCache(maxCacheSize) {
      if (maxCacheSize < 1) {
        return {
          get: function get() {
            return void 0;
          },
          set: function set2() {
          }
        };
      }
      var cacheSize = 0;
      var cache = /* @__PURE__ */ new Map();
      var previousCache = /* @__PURE__ */ new Map();
      function update(key, value) {
        cache.set(key, value);
        cacheSize++;
        if (cacheSize > maxCacheSize) {
          cacheSize = 0;
          previousCache = cache;
          cache = /* @__PURE__ */ new Map();
        }
      }
      return {
        get: function get(key) {
          var value = cache.get(key);
          if (value !== void 0) {
            return value;
          }
          if ((value = previousCache.get(key)) !== void 0) {
            update(key, value);
            return value;
          }
        },
        set: function set2(key, value) {
          if (cache.has(key)) {
            cache.set(key, value);
          } else {
            update(key, value);
          }
        }
      };
    }
    var IMPORTANT_MODIFIER = "!";
    function createSplitModifiers(config2) {
      var separator = config2.separator || ":";
      var isSeparatorSingleCharacter = separator.length === 1;
      var firstSeparatorCharacter = separator[0];
      var separatorLength = separator.length;
      return function splitModifiers(className) {
        var modifiers = [];
        var bracketDepth = 0;
        var modifierStart = 0;
        var postfixModifierPosition;
        for (var index2 = 0; index2 < className.length; index2++) {
          var currentCharacter = className[index2];
          if (bracketDepth === 0) {
            if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
              modifiers.push(className.slice(modifierStart, index2));
              modifierStart = index2 + separatorLength;
              continue;
            }
            if (currentCharacter === "/") {
              postfixModifierPosition = index2;
              continue;
            }
          }
          if (currentCharacter === "[") {
            bracketDepth++;
          } else if (currentCharacter === "]") {
            bracketDepth--;
          }
        }
        var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
        var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
        var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
        var maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
        return {
          modifiers,
          hasImportantModifier,
          baseClassName,
          maybePostfixModifierPosition
        };
      };
    }
    function sortModifiers(modifiers) {
      if (modifiers.length <= 1) {
        return modifiers;
      }
      var sortedModifiers = [];
      var unsortedModifiers = [];
      modifiers.forEach(function(modifier) {
        var isArbitraryVariant = modifier[0] === "[";
        if (isArbitraryVariant) {
          sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));
          unsortedModifiers = [];
        } else {
          unsortedModifiers.push(modifier);
        }
      });
      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());
      return sortedModifiers;
    }
    function createConfigUtils(config2) {
      return {
        cache: createLruCache(config2.cacheSize),
        splitModifiers: createSplitModifiers(config2),
        ...createClassUtils(config2)
      };
    }
    var SPLIT_CLASSES_REGEX = /\s+/;
    function mergeClassList(classList, configUtils) {
      var splitModifiers = configUtils.splitModifiers, getClassGroupId = configUtils.getClassGroupId, getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;
      var classGroupsInConflict = /* @__PURE__ */ new Set();
      return classList.trim().split(SPLIT_CLASSES_REGEX).map(function(originalClassName) {
        var _splitModifiers = splitModifiers(originalClassName), modifiers = _splitModifiers.modifiers, hasImportantModifier = _splitModifiers.hasImportantModifier, baseClassName = _splitModifiers.baseClassName, maybePostfixModifierPosition = _splitModifiers.maybePostfixModifierPosition;
        var classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
        var hasPostfixModifier = Boolean(maybePostfixModifierPosition);
        if (!classGroupId) {
          if (!maybePostfixModifierPosition) {
            return {
              isTailwindClass: false,
              originalClassName
            };
          }
          classGroupId = getClassGroupId(baseClassName);
          if (!classGroupId) {
            return {
              isTailwindClass: false,
              originalClassName
            };
          }
          hasPostfixModifier = false;
        }
        var variantModifier = sortModifiers(modifiers).join(":");
        var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
        return {
          isTailwindClass: true,
          modifierId,
          classGroupId,
          originalClassName,
          hasPostfixModifier
        };
      }).reverse().filter(function(parsed) {
        if (!parsed.isTailwindClass) {
          return true;
        }
        var modifierId = parsed.modifierId, classGroupId = parsed.classGroupId, hasPostfixModifier = parsed.hasPostfixModifier;
        var classId = modifierId + classGroupId;
        if (classGroupsInConflict.has(classId)) {
          return false;
        }
        classGroupsInConflict.add(classId);
        getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(function(group) {
          return classGroupsInConflict.add(modifierId + group);
        });
        return true;
      }).reverse().map(function(parsed) {
        return parsed.originalClassName;
      }).join(" ");
    }
    function createTailwindMerge() {
      for (var _len = arguments.length, createConfig = new Array(_len), _key = 0; _key < _len; _key++) {
        createConfig[_key] = arguments[_key];
      }
      var configUtils;
      var cacheGet;
      var cacheSet;
      var functionToCall = initTailwindMerge;
      function initTailwindMerge(classList) {
        var firstCreateConfig = createConfig[0], restCreateConfig = createConfig.slice(1);
        var config2 = restCreateConfig.reduce(function(previousConfig, createConfigCurrent) {
          return createConfigCurrent(previousConfig);
        }, firstCreateConfig());
        configUtils = createConfigUtils(config2);
        cacheGet = configUtils.cache.get;
        cacheSet = configUtils.cache.set;
        functionToCall = tailwindMerge;
        return tailwindMerge(classList);
      }
      function tailwindMerge(classList) {
        var cachedResult = cacheGet(classList);
        if (cachedResult) {
          return cachedResult;
        }
        var result = mergeClassList(classList, configUtils);
        cacheSet(classList, result);
        return result;
      }
      return function callTailwindMerge() {
        return functionToCall(twJoin.apply(null, arguments));
      };
    }
    function fromTheme(key) {
      var themeGetter = function themeGetter2(theme) {
        return theme[key] || [];
      };
      themeGetter.isThemeGetter = true;
      return themeGetter;
    }
    var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    var fractionRegex = /^\d+\/\d+$/;
    var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    var shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
    function isLength(value) {
      return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value) || isArbitraryLength(value);
    }
    function isArbitraryLength(value) {
      return getIsArbitraryValue(value, "length", isLengthOnly);
    }
    function isArbitrarySize(value) {
      return getIsArbitraryValue(value, "size", isNever);
    }
    function isArbitraryPosition(value) {
      return getIsArbitraryValue(value, "position", isNever);
    }
    function isArbitraryUrl(value) {
      return getIsArbitraryValue(value, "url", isUrl);
    }
    function isArbitraryNumber(value) {
      return getIsArbitraryValue(value, "number", isNumber);
    }
    function isNumber(value) {
      return !Number.isNaN(Number(value));
    }
    function isPercent(value) {
      return value.endsWith("%") && isNumber(value.slice(0, -1));
    }
    function isInteger(value) {
      return isIntegerOnly(value) || getIsArbitraryValue(value, "number", isIntegerOnly);
    }
    function isArbitraryValue(value) {
      return arbitraryValueRegex.test(value);
    }
    function isAny() {
      return true;
    }
    function isTshirtSize(value) {
      return tshirtUnitRegex.test(value);
    }
    function isArbitraryShadow(value) {
      return getIsArbitraryValue(value, "", isShadow);
    }
    function getIsArbitraryValue(value, label, testValue) {
      var result = arbitraryValueRegex.exec(value);
      if (result) {
        if (result[1]) {
          return result[1] === label;
        }
        return testValue(result[2]);
      }
      return false;
    }
    function isLengthOnly(value) {
      return lengthUnitRegex.test(value);
    }
    function isNever() {
      return false;
    }
    function isUrl(value) {
      return value.startsWith("url(");
    }
    function isIntegerOnly(value) {
      return Number.isInteger(Number(value));
    }
    function isShadow(value) {
      return shadowRegex.test(value);
    }
    function getDefaultConfig() {
      var colors = fromTheme("colors");
      var spacing = fromTheme("spacing");
      var blur = fromTheme("blur");
      var brightness = fromTheme("brightness");
      var borderColor = fromTheme("borderColor");
      var borderRadius = fromTheme("borderRadius");
      var borderSpacing = fromTheme("borderSpacing");
      var borderWidth = fromTheme("borderWidth");
      var contrast = fromTheme("contrast");
      var grayscale = fromTheme("grayscale");
      var hueRotate = fromTheme("hueRotate");
      var invert2 = fromTheme("invert");
      var gap = fromTheme("gap");
      var gradientColorStops = fromTheme("gradientColorStops");
      var gradientColorStopPositions = fromTheme("gradientColorStopPositions");
      var inset = fromTheme("inset");
      var margin = fromTheme("margin");
      var opacity = fromTheme("opacity");
      var padding2 = fromTheme("padding");
      var saturate = fromTheme("saturate");
      var scale = fromTheme("scale");
      var sepia = fromTheme("sepia");
      var skew = fromTheme("skew");
      var space = fromTheme("space");
      var translate = fromTheme("translate");
      var getOverscroll = function getOverscroll2() {
        return ["auto", "contain", "none"];
      };
      var getOverflow = function getOverflow2() {
        return ["auto", "hidden", "clip", "visible", "scroll"];
      };
      var getSpacingWithAutoAndArbitrary = function getSpacingWithAutoAndArbitrary2() {
        return ["auto", isArbitraryValue, spacing];
      };
      var getSpacingWithArbitrary = function getSpacingWithArbitrary2() {
        return [isArbitraryValue, spacing];
      };
      var getLengthWithEmpty = function getLengthWithEmpty2() {
        return ["", isLength];
      };
      var getNumberWithAutoAndArbitrary = function getNumberWithAutoAndArbitrary2() {
        return ["auto", isNumber, isArbitraryValue];
      };
      var getPositions = function getPositions2() {
        return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
      };
      var getLineStyles = function getLineStyles2() {
        return ["solid", "dashed", "dotted", "double", "none"];
      };
      var getBlendModes = function getBlendModes2() {
        return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
      };
      var getAlign = function getAlign2() {
        return ["start", "end", "center", "between", "around", "evenly", "stretch"];
      };
      var getZeroAndEmpty = function getZeroAndEmpty2() {
        return ["", "0", isArbitraryValue];
      };
      var getBreaks = function getBreaks2() {
        return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
      };
      var getNumber = function getNumber2() {
        return [isNumber, isArbitraryNumber];
      };
      var getNumberAndArbitrary = function getNumberAndArbitrary2() {
        return [isNumber, isArbitraryValue];
      };
      return {
        cacheSize: 500,
        theme: {
          colors: [isAny],
          spacing: [isLength],
          blur: ["none", "", isTshirtSize, isArbitraryValue],
          brightness: getNumber(),
          borderColor: [colors],
          borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
          borderSpacing: getSpacingWithArbitrary(),
          borderWidth: getLengthWithEmpty(),
          contrast: getNumber(),
          grayscale: getZeroAndEmpty(),
          hueRotate: getNumberAndArbitrary(),
          invert: getZeroAndEmpty(),
          gap: getSpacingWithArbitrary(),
          gradientColorStops: [colors],
          gradientColorStopPositions: [isPercent, isArbitraryLength],
          inset: getSpacingWithAutoAndArbitrary(),
          margin: getSpacingWithAutoAndArbitrary(),
          opacity: getNumber(),
          padding: getSpacingWithArbitrary(),
          saturate: getNumber(),
          scale: getNumber(),
          sepia: getZeroAndEmpty(),
          skew: getNumberAndArbitrary(),
          space: getSpacingWithArbitrary(),
          translate: getSpacingWithArbitrary()
        },
        classGroups: {
          // Layout
          /**
           * Aspect Ratio
           * @see https://tailwindcss.com/docs/aspect-ratio
           */
          aspect: [{
            aspect: ["auto", "square", "video", isArbitraryValue]
          }],
          /**
           * Container
           * @see https://tailwindcss.com/docs/container
           */
          container: ["container"],
          /**
           * Columns
           * @see https://tailwindcss.com/docs/columns
           */
          columns: [{
            columns: [isTshirtSize]
          }],
          /**
           * Break After
           * @see https://tailwindcss.com/docs/break-after
           */
          "break-after": [{
            "break-after": getBreaks()
          }],
          /**
           * Break Before
           * @see https://tailwindcss.com/docs/break-before
           */
          "break-before": [{
            "break-before": getBreaks()
          }],
          /**
           * Break Inside
           * @see https://tailwindcss.com/docs/break-inside
           */
          "break-inside": [{
            "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
          }],
          /**
           * Box Decoration Break
           * @see https://tailwindcss.com/docs/box-decoration-break
           */
          "box-decoration": [{
            "box-decoration": ["slice", "clone"]
          }],
          /**
           * Box Sizing
           * @see https://tailwindcss.com/docs/box-sizing
           */
          box: [{
            box: ["border", "content"]
          }],
          /**
           * Display
           * @see https://tailwindcss.com/docs/display
           */
          display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
          /**
           * Floats
           * @see https://tailwindcss.com/docs/float
           */
          "float": [{
            "float": ["right", "left", "none"]
          }],
          /**
           * Clear
           * @see https://tailwindcss.com/docs/clear
           */
          clear: [{
            clear: ["left", "right", "both", "none"]
          }],
          /**
           * Isolation
           * @see https://tailwindcss.com/docs/isolation
           */
          isolation: ["isolate", "isolation-auto"],
          /**
           * Object Fit
           * @see https://tailwindcss.com/docs/object-fit
           */
          "object-fit": [{
            object: ["contain", "cover", "fill", "none", "scale-down"]
          }],
          /**
           * Object Position
           * @see https://tailwindcss.com/docs/object-position
           */
          "object-position": [{
            object: [].concat(getPositions(), [isArbitraryValue])
          }],
          /**
           * Overflow
           * @see https://tailwindcss.com/docs/overflow
           */
          overflow: [{
            overflow: getOverflow()
          }],
          /**
           * Overflow X
           * @see https://tailwindcss.com/docs/overflow
           */
          "overflow-x": [{
            "overflow-x": getOverflow()
          }],
          /**
           * Overflow Y
           * @see https://tailwindcss.com/docs/overflow
           */
          "overflow-y": [{
            "overflow-y": getOverflow()
          }],
          /**
           * Overscroll Behavior
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          overscroll: [{
            overscroll: getOverscroll()
          }],
          /**
           * Overscroll Behavior X
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          "overscroll-x": [{
            "overscroll-x": getOverscroll()
          }],
          /**
           * Overscroll Behavior Y
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          "overscroll-y": [{
            "overscroll-y": getOverscroll()
          }],
          /**
           * Position
           * @see https://tailwindcss.com/docs/position
           */
          position: ["static", "fixed", "absolute", "relative", "sticky"],
          /**
           * Top / Right / Bottom / Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          inset: [{
            inset: [inset]
          }],
          /**
           * Right / Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          "inset-x": [{
            "inset-x": [inset]
          }],
          /**
           * Top / Bottom
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          "inset-y": [{
            "inset-y": [inset]
          }],
          /**
           * Start
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          start: [{
            start: [inset]
          }],
          /**
           * End
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          end: [{
            end: [inset]
          }],
          /**
           * Top
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          top: [{
            top: [inset]
          }],
          /**
           * Right
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          right: [{
            right: [inset]
          }],
          /**
           * Bottom
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          bottom: [{
            bottom: [inset]
          }],
          /**
           * Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          left: [{
            left: [inset]
          }],
          /**
           * Visibility
           * @see https://tailwindcss.com/docs/visibility
           */
          visibility: ["visible", "invisible", "collapse"],
          /**
           * Z-Index
           * @see https://tailwindcss.com/docs/z-index
           */
          z: [{
            z: ["auto", isInteger]
          }],
          // Flexbox and Grid
          /**
           * Flex Basis
           * @see https://tailwindcss.com/docs/flex-basis
           */
          basis: [{
            basis: getSpacingWithAutoAndArbitrary()
          }],
          /**
           * Flex Direction
           * @see https://tailwindcss.com/docs/flex-direction
           */
          "flex-direction": [{
            flex: ["row", "row-reverse", "col", "col-reverse"]
          }],
          /**
           * Flex Wrap
           * @see https://tailwindcss.com/docs/flex-wrap
           */
          "flex-wrap": [{
            flex: ["wrap", "wrap-reverse", "nowrap"]
          }],
          /**
           * Flex
           * @see https://tailwindcss.com/docs/flex
           */
          flex: [{
            flex: ["1", "auto", "initial", "none", isArbitraryValue]
          }],
          /**
           * Flex Grow
           * @see https://tailwindcss.com/docs/flex-grow
           */
          grow: [{
            grow: getZeroAndEmpty()
          }],
          /**
           * Flex Shrink
           * @see https://tailwindcss.com/docs/flex-shrink
           */
          shrink: [{
            shrink: getZeroAndEmpty()
          }],
          /**
           * Order
           * @see https://tailwindcss.com/docs/order
           */
          order: [{
            order: ["first", "last", "none", isInteger]
          }],
          /**
           * Grid Template Columns
           * @see https://tailwindcss.com/docs/grid-template-columns
           */
          "grid-cols": [{
            "grid-cols": [isAny]
          }],
          /**
           * Grid Column Start / End
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-start-end": [{
            col: ["auto", {
              span: ["full", isInteger]
            }, isArbitraryValue]
          }],
          /**
           * Grid Column Start
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-start": [{
            "col-start": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Column End
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-end": [{
            "col-end": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Template Rows
           * @see https://tailwindcss.com/docs/grid-template-rows
           */
          "grid-rows": [{
            "grid-rows": [isAny]
          }],
          /**
           * Grid Row Start / End
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-start-end": [{
            row: ["auto", {
              span: [isInteger]
            }, isArbitraryValue]
          }],
          /**
           * Grid Row Start
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-start": [{
            "row-start": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Row End
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-end": [{
            "row-end": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Auto Flow
           * @see https://tailwindcss.com/docs/grid-auto-flow
           */
          "grid-flow": [{
            "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
          }],
          /**
           * Grid Auto Columns
           * @see https://tailwindcss.com/docs/grid-auto-columns
           */
          "auto-cols": [{
            "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
          }],
          /**
           * Grid Auto Rows
           * @see https://tailwindcss.com/docs/grid-auto-rows
           */
          "auto-rows": [{
            "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
          }],
          /**
           * Gap
           * @see https://tailwindcss.com/docs/gap
           */
          gap: [{
            gap: [gap]
          }],
          /**
           * Gap X
           * @see https://tailwindcss.com/docs/gap
           */
          "gap-x": [{
            "gap-x": [gap]
          }],
          /**
           * Gap Y
           * @see https://tailwindcss.com/docs/gap
           */
          "gap-y": [{
            "gap-y": [gap]
          }],
          /**
           * Justify Content
           * @see https://tailwindcss.com/docs/justify-content
           */
          "justify-content": [{
            justify: ["normal"].concat(getAlign())
          }],
          /**
           * Justify Items
           * @see https://tailwindcss.com/docs/justify-items
           */
          "justify-items": [{
            "justify-items": ["start", "end", "center", "stretch"]
          }],
          /**
           * Justify Self
           * @see https://tailwindcss.com/docs/justify-self
           */
          "justify-self": [{
            "justify-self": ["auto", "start", "end", "center", "stretch"]
          }],
          /**
           * Align Content
           * @see https://tailwindcss.com/docs/align-content
           */
          "align-content": [{
            content: ["normal"].concat(getAlign(), ["baseline"])
          }],
          /**
           * Align Items
           * @see https://tailwindcss.com/docs/align-items
           */
          "align-items": [{
            items: ["start", "end", "center", "baseline", "stretch"]
          }],
          /**
           * Align Self
           * @see https://tailwindcss.com/docs/align-self
           */
          "align-self": [{
            self: ["auto", "start", "end", "center", "stretch", "baseline"]
          }],
          /**
           * Place Content
           * @see https://tailwindcss.com/docs/place-content
           */
          "place-content": [{
            "place-content": [].concat(getAlign(), ["baseline"])
          }],
          /**
           * Place Items
           * @see https://tailwindcss.com/docs/place-items
           */
          "place-items": [{
            "place-items": ["start", "end", "center", "baseline", "stretch"]
          }],
          /**
           * Place Self
           * @see https://tailwindcss.com/docs/place-self
           */
          "place-self": [{
            "place-self": ["auto", "start", "end", "center", "stretch"]
          }],
          // Spacing
          /**
           * Padding
           * @see https://tailwindcss.com/docs/padding
           */
          p: [{
            p: [padding2]
          }],
          /**
           * Padding X
           * @see https://tailwindcss.com/docs/padding
           */
          px: [{
            px: [padding2]
          }],
          /**
           * Padding Y
           * @see https://tailwindcss.com/docs/padding
           */
          py: [{
            py: [padding2]
          }],
          /**
           * Padding Start
           * @see https://tailwindcss.com/docs/padding
           */
          ps: [{
            ps: [padding2]
          }],
          /**
           * Padding End
           * @see https://tailwindcss.com/docs/padding
           */
          pe: [{
            pe: [padding2]
          }],
          /**
           * Padding Top
           * @see https://tailwindcss.com/docs/padding
           */
          pt: [{
            pt: [padding2]
          }],
          /**
           * Padding Right
           * @see https://tailwindcss.com/docs/padding
           */
          pr: [{
            pr: [padding2]
          }],
          /**
           * Padding Bottom
           * @see https://tailwindcss.com/docs/padding
           */
          pb: [{
            pb: [padding2]
          }],
          /**
           * Padding Left
           * @see https://tailwindcss.com/docs/padding
           */
          pl: [{
            pl: [padding2]
          }],
          /**
           * Margin
           * @see https://tailwindcss.com/docs/margin
           */
          m: [{
            m: [margin]
          }],
          /**
           * Margin X
           * @see https://tailwindcss.com/docs/margin
           */
          mx: [{
            mx: [margin]
          }],
          /**
           * Margin Y
           * @see https://tailwindcss.com/docs/margin
           */
          my: [{
            my: [margin]
          }],
          /**
           * Margin Start
           * @see https://tailwindcss.com/docs/margin
           */
          ms: [{
            ms: [margin]
          }],
          /**
           * Margin End
           * @see https://tailwindcss.com/docs/margin
           */
          me: [{
            me: [margin]
          }],
          /**
           * Margin Top
           * @see https://tailwindcss.com/docs/margin
           */
          mt: [{
            mt: [margin]
          }],
          /**
           * Margin Right
           * @see https://tailwindcss.com/docs/margin
           */
          mr: [{
            mr: [margin]
          }],
          /**
           * Margin Bottom
           * @see https://tailwindcss.com/docs/margin
           */
          mb: [{
            mb: [margin]
          }],
          /**
           * Margin Left
           * @see https://tailwindcss.com/docs/margin
           */
          ml: [{
            ml: [margin]
          }],
          /**
           * Space Between X
           * @see https://tailwindcss.com/docs/space
           */
          "space-x": [{
            "space-x": [space]
          }],
          /**
           * Space Between X Reverse
           * @see https://tailwindcss.com/docs/space
           */
          "space-x-reverse": ["space-x-reverse"],
          /**
           * Space Between Y
           * @see https://tailwindcss.com/docs/space
           */
          "space-y": [{
            "space-y": [space]
          }],
          /**
           * Space Between Y Reverse
           * @see https://tailwindcss.com/docs/space
           */
          "space-y-reverse": ["space-y-reverse"],
          // Sizing
          /**
           * Width
           * @see https://tailwindcss.com/docs/width
           */
          w: [{
            w: ["auto", "min", "max", "fit", isArbitraryValue, spacing]
          }],
          /**
           * Min-Width
           * @see https://tailwindcss.com/docs/min-width
           */
          "min-w": [{
            "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
          }],
          /**
           * Max-Width
           * @see https://tailwindcss.com/docs/max-width
           */
          "max-w": [{
            "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
              screen: [isTshirtSize]
            }, isTshirtSize, isArbitraryValue]
          }],
          /**
           * Height
           * @see https://tailwindcss.com/docs/height
           */
          h: [{
            h: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
          }],
          /**
           * Min-Height
           * @see https://tailwindcss.com/docs/min-height
           */
          "min-h": [{
            "min-h": ["min", "max", "fit", isArbitraryValue, isLength]
          }],
          /**
           * Max-Height
           * @see https://tailwindcss.com/docs/max-height
           */
          "max-h": [{
            "max-h": [isArbitraryValue, spacing, "min", "max", "fit"]
          }],
          // Typography
          /**
           * Font Size
           * @see https://tailwindcss.com/docs/font-size
           */
          "font-size": [{
            text: ["base", isTshirtSize, isArbitraryLength]
          }],
          /**
           * Font Smoothing
           * @see https://tailwindcss.com/docs/font-smoothing
           */
          "font-smoothing": ["antialiased", "subpixel-antialiased"],
          /**
           * Font Style
           * @see https://tailwindcss.com/docs/font-style
           */
          "font-style": ["italic", "not-italic"],
          /**
           * Font Weight
           * @see https://tailwindcss.com/docs/font-weight
           */
          "font-weight": [{
            font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
          }],
          /**
           * Font Family
           * @see https://tailwindcss.com/docs/font-family
           */
          "font-family": [{
            font: [isAny]
          }],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-normal": ["normal-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-ordinal": ["ordinal"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-slashed-zero": ["slashed-zero"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-figure": ["lining-nums", "oldstyle-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-spacing": ["proportional-nums", "tabular-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
          /**
           * Letter Spacing
           * @see https://tailwindcss.com/docs/letter-spacing
           */
          tracking: [{
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
          }],
          /**
           * Line Clamp
           * @see https://tailwindcss.com/docs/line-clamp
           */
          "line-clamp": [{
            "line-clamp": ["none", isNumber, isArbitraryNumber]
          }],
          /**
           * Line Height
           * @see https://tailwindcss.com/docs/line-height
           */
          leading: [{
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isArbitraryValue, isLength]
          }],
          /**
           * List Style Image
           * @see https://tailwindcss.com/docs/list-style-image
           */
          "list-image": [{
            "list-image": ["none", isArbitraryValue]
          }],
          /**
           * List Style Type
           * @see https://tailwindcss.com/docs/list-style-type
           */
          "list-style-type": [{
            list: ["none", "disc", "decimal", isArbitraryValue]
          }],
          /**
           * List Style Position
           * @see https://tailwindcss.com/docs/list-style-position
           */
          "list-style-position": [{
            list: ["inside", "outside"]
          }],
          /**
           * Placeholder Color
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/placeholder-color
           */
          "placeholder-color": [{
            placeholder: [colors]
          }],
          /**
           * Placeholder Opacity
           * @see https://tailwindcss.com/docs/placeholder-opacity
           */
          "placeholder-opacity": [{
            "placeholder-opacity": [opacity]
          }],
          /**
           * Text Alignment
           * @see https://tailwindcss.com/docs/text-align
           */
          "text-alignment": [{
            text: ["left", "center", "right", "justify", "start", "end"]
          }],
          /**
           * Text Color
           * @see https://tailwindcss.com/docs/text-color
           */
          "text-color": [{
            text: [colors]
          }],
          /**
           * Text Opacity
           * @see https://tailwindcss.com/docs/text-opacity
           */
          "text-opacity": [{
            "text-opacity": [opacity]
          }],
          /**
           * Text Decoration
           * @see https://tailwindcss.com/docs/text-decoration
           */
          "text-decoration": ["underline", "overline", "line-through", "no-underline"],
          /**
           * Text Decoration Style
           * @see https://tailwindcss.com/docs/text-decoration-style
           */
          "text-decoration-style": [{
            decoration: [].concat(getLineStyles(), ["wavy"])
          }],
          /**
           * Text Decoration Thickness
           * @see https://tailwindcss.com/docs/text-decoration-thickness
           */
          "text-decoration-thickness": [{
            decoration: ["auto", "from-font", isLength]
          }],
          /**
           * Text Underline Offset
           * @see https://tailwindcss.com/docs/text-underline-offset
           */
          "underline-offset": [{
            "underline-offset": ["auto", isArbitraryValue, isLength]
          }],
          /**
           * Text Decoration Color
           * @see https://tailwindcss.com/docs/text-decoration-color
           */
          "text-decoration-color": [{
            decoration: [colors]
          }],
          /**
           * Text Transform
           * @see https://tailwindcss.com/docs/text-transform
           */
          "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
          /**
           * Text Overflow
           * @see https://tailwindcss.com/docs/text-overflow
           */
          "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
          /**
           * Text Indent
           * @see https://tailwindcss.com/docs/text-indent
           */
          indent: [{
            indent: getSpacingWithArbitrary()
          }],
          /**
           * Vertical Alignment
           * @see https://tailwindcss.com/docs/vertical-align
           */
          "vertical-align": [{
            align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
          }],
          /**
           * Whitespace
           * @see https://tailwindcss.com/docs/whitespace
           */
          whitespace: [{
            whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
          }],
          /**
           * Word Break
           * @see https://tailwindcss.com/docs/word-break
           */
          "break": [{
            "break": ["normal", "words", "all", "keep"]
          }],
          /**
           * Hyphens
           * @see https://tailwindcss.com/docs/hyphens
           */
          hyphens: [{
            hyphens: ["none", "manual", "auto"]
          }],
          /**
           * Content
           * @see https://tailwindcss.com/docs/content
           */
          content: [{
            content: ["none", isArbitraryValue]
          }],
          // Backgrounds
          /**
           * Background Attachment
           * @see https://tailwindcss.com/docs/background-attachment
           */
          "bg-attachment": [{
            bg: ["fixed", "local", "scroll"]
          }],
          /**
           * Background Clip
           * @see https://tailwindcss.com/docs/background-clip
           */
          "bg-clip": [{
            "bg-clip": ["border", "padding", "content", "text"]
          }],
          /**
           * Background Opacity
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/background-opacity
           */
          "bg-opacity": [{
            "bg-opacity": [opacity]
          }],
          /**
           * Background Origin
           * @see https://tailwindcss.com/docs/background-origin
           */
          "bg-origin": [{
            "bg-origin": ["border", "padding", "content"]
          }],
          /**
           * Background Position
           * @see https://tailwindcss.com/docs/background-position
           */
          "bg-position": [{
            bg: [].concat(getPositions(), [isArbitraryPosition])
          }],
          /**
           * Background Repeat
           * @see https://tailwindcss.com/docs/background-repeat
           */
          "bg-repeat": [{
            bg: ["no-repeat", {
              repeat: ["", "x", "y", "round", "space"]
            }]
          }],
          /**
           * Background Size
           * @see https://tailwindcss.com/docs/background-size
           */
          "bg-size": [{
            bg: ["auto", "cover", "contain", isArbitrarySize]
          }],
          /**
           * Background Image
           * @see https://tailwindcss.com/docs/background-image
           */
          "bg-image": [{
            bg: ["none", {
              "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
            }, isArbitraryUrl]
          }],
          /**
           * Background Color
           * @see https://tailwindcss.com/docs/background-color
           */
          "bg-color": [{
            bg: [colors]
          }],
          /**
           * Gradient Color Stops From Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-from-pos": [{
            from: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops Via Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-via-pos": [{
            via: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops To Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-to-pos": [{
            to: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops From
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-from": [{
            from: [gradientColorStops]
          }],
          /**
           * Gradient Color Stops Via
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-via": [{
            via: [gradientColorStops]
          }],
          /**
           * Gradient Color Stops To
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-to": [{
            to: [gradientColorStops]
          }],
          // Borders
          /**
           * Border Radius
           * @see https://tailwindcss.com/docs/border-radius
           */
          rounded: [{
            rounded: [borderRadius]
          }],
          /**
           * Border Radius Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-s": [{
            "rounded-s": [borderRadius]
          }],
          /**
           * Border Radius End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-e": [{
            "rounded-e": [borderRadius]
          }],
          /**
           * Border Radius Top
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-t": [{
            "rounded-t": [borderRadius]
          }],
          /**
           * Border Radius Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-r": [{
            "rounded-r": [borderRadius]
          }],
          /**
           * Border Radius Bottom
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-b": [{
            "rounded-b": [borderRadius]
          }],
          /**
           * Border Radius Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-l": [{
            "rounded-l": [borderRadius]
          }],
          /**
           * Border Radius Start Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-ss": [{
            "rounded-ss": [borderRadius]
          }],
          /**
           * Border Radius Start End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-se": [{
            "rounded-se": [borderRadius]
          }],
          /**
           * Border Radius End End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-ee": [{
            "rounded-ee": [borderRadius]
          }],
          /**
           * Border Radius End Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-es": [{
            "rounded-es": [borderRadius]
          }],
          /**
           * Border Radius Top Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-tl": [{
            "rounded-tl": [borderRadius]
          }],
          /**
           * Border Radius Top Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-tr": [{
            "rounded-tr": [borderRadius]
          }],
          /**
           * Border Radius Bottom Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-br": [{
            "rounded-br": [borderRadius]
          }],
          /**
           * Border Radius Bottom Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-bl": [{
            "rounded-bl": [borderRadius]
          }],
          /**
           * Border Width
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w": [{
            border: [borderWidth]
          }],
          /**
           * Border Width X
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-x": [{
            "border-x": [borderWidth]
          }],
          /**
           * Border Width Y
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-y": [{
            "border-y": [borderWidth]
          }],
          /**
           * Border Width Start
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-s": [{
            "border-s": [borderWidth]
          }],
          /**
           * Border Width End
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-e": [{
            "border-e": [borderWidth]
          }],
          /**
           * Border Width Top
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-t": [{
            "border-t": [borderWidth]
          }],
          /**
           * Border Width Right
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-r": [{
            "border-r": [borderWidth]
          }],
          /**
           * Border Width Bottom
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-b": [{
            "border-b": [borderWidth]
          }],
          /**
           * Border Width Left
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-l": [{
            "border-l": [borderWidth]
          }],
          /**
           * Border Opacity
           * @see https://tailwindcss.com/docs/border-opacity
           */
          "border-opacity": [{
            "border-opacity": [opacity]
          }],
          /**
           * Border Style
           * @see https://tailwindcss.com/docs/border-style
           */
          "border-style": [{
            border: [].concat(getLineStyles(), ["hidden"])
          }],
          /**
           * Divide Width X
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-x": [{
            "divide-x": [borderWidth]
          }],
          /**
           * Divide Width X Reverse
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-x-reverse": ["divide-x-reverse"],
          /**
           * Divide Width Y
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-y": [{
            "divide-y": [borderWidth]
          }],
          /**
           * Divide Width Y Reverse
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-y-reverse": ["divide-y-reverse"],
          /**
           * Divide Opacity
           * @see https://tailwindcss.com/docs/divide-opacity
           */
          "divide-opacity": [{
            "divide-opacity": [opacity]
          }],
          /**
           * Divide Style
           * @see https://tailwindcss.com/docs/divide-style
           */
          "divide-style": [{
            divide: getLineStyles()
          }],
          /**
           * Border Color
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color": [{
            border: [borderColor]
          }],
          /**
           * Border Color X
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-x": [{
            "border-x": [borderColor]
          }],
          /**
           * Border Color Y
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-y": [{
            "border-y": [borderColor]
          }],
          /**
           * Border Color Top
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-t": [{
            "border-t": [borderColor]
          }],
          /**
           * Border Color Right
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-r": [{
            "border-r": [borderColor]
          }],
          /**
           * Border Color Bottom
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-b": [{
            "border-b": [borderColor]
          }],
          /**
           * Border Color Left
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-l": [{
            "border-l": [borderColor]
          }],
          /**
           * Divide Color
           * @see https://tailwindcss.com/docs/divide-color
           */
          "divide-color": [{
            divide: [borderColor]
          }],
          /**
           * Outline Style
           * @see https://tailwindcss.com/docs/outline-style
           */
          "outline-style": [{
            outline: [""].concat(getLineStyles())
          }],
          /**
           * Outline Offset
           * @see https://tailwindcss.com/docs/outline-offset
           */
          "outline-offset": [{
            "outline-offset": [isArbitraryValue, isLength]
          }],
          /**
           * Outline Width
           * @see https://tailwindcss.com/docs/outline-width
           */
          "outline-w": [{
            outline: [isLength]
          }],
          /**
           * Outline Color
           * @see https://tailwindcss.com/docs/outline-color
           */
          "outline-color": [{
            outline: [colors]
          }],
          /**
           * Ring Width
           * @see https://tailwindcss.com/docs/ring-width
           */
          "ring-w": [{
            ring: getLengthWithEmpty()
          }],
          /**
           * Ring Width Inset
           * @see https://tailwindcss.com/docs/ring-width
           */
          "ring-w-inset": ["ring-inset"],
          /**
           * Ring Color
           * @see https://tailwindcss.com/docs/ring-color
           */
          "ring-color": [{
            ring: [colors]
          }],
          /**
           * Ring Opacity
           * @see https://tailwindcss.com/docs/ring-opacity
           */
          "ring-opacity": [{
            "ring-opacity": [opacity]
          }],
          /**
           * Ring Offset Width
           * @see https://tailwindcss.com/docs/ring-offset-width
           */
          "ring-offset-w": [{
            "ring-offset": [isLength]
          }],
          /**
           * Ring Offset Color
           * @see https://tailwindcss.com/docs/ring-offset-color
           */
          "ring-offset-color": [{
            "ring-offset": [colors]
          }],
          // Effects
          /**
           * Box Shadow
           * @see https://tailwindcss.com/docs/box-shadow
           */
          shadow: [{
            shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
          }],
          /**
           * Box Shadow Color
           * @see https://tailwindcss.com/docs/box-shadow-color
           */
          "shadow-color": [{
            shadow: [isAny]
          }],
          /**
           * Opacity
           * @see https://tailwindcss.com/docs/opacity
           */
          opacity: [{
            opacity: [opacity]
          }],
          /**
           * Mix Blend Mode
           * @see https://tailwindcss.com/docs/mix-blend-mode
           */
          "mix-blend": [{
            "mix-blend": getBlendModes()
          }],
          /**
           * Background Blend Mode
           * @see https://tailwindcss.com/docs/background-blend-mode
           */
          "bg-blend": [{
            "bg-blend": getBlendModes()
          }],
          // Filters
          /**
           * Filter
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/filter
           */
          filter: [{
            filter: ["", "none"]
          }],
          /**
           * Blur
           * @see https://tailwindcss.com/docs/blur
           */
          blur: [{
            blur: [blur]
          }],
          /**
           * Brightness
           * @see https://tailwindcss.com/docs/brightness
           */
          brightness: [{
            brightness: [brightness]
          }],
          /**
           * Contrast
           * @see https://tailwindcss.com/docs/contrast
           */
          contrast: [{
            contrast: [contrast]
          }],
          /**
           * Drop Shadow
           * @see https://tailwindcss.com/docs/drop-shadow
           */
          "drop-shadow": [{
            "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
          }],
          /**
           * Grayscale
           * @see https://tailwindcss.com/docs/grayscale
           */
          grayscale: [{
            grayscale: [grayscale]
          }],
          /**
           * Hue Rotate
           * @see https://tailwindcss.com/docs/hue-rotate
           */
          "hue-rotate": [{
            "hue-rotate": [hueRotate]
          }],
          /**
           * Invert
           * @see https://tailwindcss.com/docs/invert
           */
          invert: [{
            invert: [invert2]
          }],
          /**
           * Saturate
           * @see https://tailwindcss.com/docs/saturate
           */
          saturate: [{
            saturate: [saturate]
          }],
          /**
           * Sepia
           * @see https://tailwindcss.com/docs/sepia
           */
          sepia: [{
            sepia: [sepia]
          }],
          /**
           * Backdrop Filter
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/backdrop-filter
           */
          "backdrop-filter": [{
            "backdrop-filter": ["", "none"]
          }],
          /**
           * Backdrop Blur
           * @see https://tailwindcss.com/docs/backdrop-blur
           */
          "backdrop-blur": [{
            "backdrop-blur": [blur]
          }],
          /**
           * Backdrop Brightness
           * @see https://tailwindcss.com/docs/backdrop-brightness
           */
          "backdrop-brightness": [{
            "backdrop-brightness": [brightness]
          }],
          /**
           * Backdrop Contrast
           * @see https://tailwindcss.com/docs/backdrop-contrast
           */
          "backdrop-contrast": [{
            "backdrop-contrast": [contrast]
          }],
          /**
           * Backdrop Grayscale
           * @see https://tailwindcss.com/docs/backdrop-grayscale
           */
          "backdrop-grayscale": [{
            "backdrop-grayscale": [grayscale]
          }],
          /**
           * Backdrop Hue Rotate
           * @see https://tailwindcss.com/docs/backdrop-hue-rotate
           */
          "backdrop-hue-rotate": [{
            "backdrop-hue-rotate": [hueRotate]
          }],
          /**
           * Backdrop Invert
           * @see https://tailwindcss.com/docs/backdrop-invert
           */
          "backdrop-invert": [{
            "backdrop-invert": [invert2]
          }],
          /**
           * Backdrop Opacity
           * @see https://tailwindcss.com/docs/backdrop-opacity
           */
          "backdrop-opacity": [{
            "backdrop-opacity": [opacity]
          }],
          /**
           * Backdrop Saturate
           * @see https://tailwindcss.com/docs/backdrop-saturate
           */
          "backdrop-saturate": [{
            "backdrop-saturate": [saturate]
          }],
          /**
           * Backdrop Sepia
           * @see https://tailwindcss.com/docs/backdrop-sepia
           */
          "backdrop-sepia": [{
            "backdrop-sepia": [sepia]
          }],
          // Tables
          /**
           * Border Collapse
           * @see https://tailwindcss.com/docs/border-collapse
           */
          "border-collapse": [{
            border: ["collapse", "separate"]
          }],
          /**
           * Border Spacing
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing": [{
            "border-spacing": [borderSpacing]
          }],
          /**
           * Border Spacing X
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing-x": [{
            "border-spacing-x": [borderSpacing]
          }],
          /**
           * Border Spacing Y
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing-y": [{
            "border-spacing-y": [borderSpacing]
          }],
          /**
           * Table Layout
           * @see https://tailwindcss.com/docs/table-layout
           */
          "table-layout": [{
            table: ["auto", "fixed"]
          }],
          /**
           * Caption Side
           * @see https://tailwindcss.com/docs/caption-side
           */
          caption: [{
            caption: ["top", "bottom"]
          }],
          // Transitions and Animation
          /**
           * Tranisition Property
           * @see https://tailwindcss.com/docs/transition-property
           */
          transition: [{
            transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
          }],
          /**
           * Transition Duration
           * @see https://tailwindcss.com/docs/transition-duration
           */
          duration: [{
            duration: getNumberAndArbitrary()
          }],
          /**
           * Transition Timing Function
           * @see https://tailwindcss.com/docs/transition-timing-function
           */
          ease: [{
            ease: ["linear", "in", "out", "in-out", isArbitraryValue]
          }],
          /**
           * Transition Delay
           * @see https://tailwindcss.com/docs/transition-delay
           */
          delay: [{
            delay: getNumberAndArbitrary()
          }],
          /**
           * Animation
           * @see https://tailwindcss.com/docs/animation
           */
          animate: [{
            animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
          }],
          // Transforms
          /**
           * Transform
           * @see https://tailwindcss.com/docs/transform
           */
          transform: [{
            transform: ["", "gpu", "none"]
          }],
          /**
           * Scale
           * @see https://tailwindcss.com/docs/scale
           */
          scale: [{
            scale: [scale]
          }],
          /**
           * Scale X
           * @see https://tailwindcss.com/docs/scale
           */
          "scale-x": [{
            "scale-x": [scale]
          }],
          /**
           * Scale Y
           * @see https://tailwindcss.com/docs/scale
           */
          "scale-y": [{
            "scale-y": [scale]
          }],
          /**
           * Rotate
           * @see https://tailwindcss.com/docs/rotate
           */
          rotate: [{
            rotate: [isInteger, isArbitraryValue]
          }],
          /**
           * Translate X
           * @see https://tailwindcss.com/docs/translate
           */
          "translate-x": [{
            "translate-x": [translate]
          }],
          /**
           * Translate Y
           * @see https://tailwindcss.com/docs/translate
           */
          "translate-y": [{
            "translate-y": [translate]
          }],
          /**
           * Skew X
           * @see https://tailwindcss.com/docs/skew
           */
          "skew-x": [{
            "skew-x": [skew]
          }],
          /**
           * Skew Y
           * @see https://tailwindcss.com/docs/skew
           */
          "skew-y": [{
            "skew-y": [skew]
          }],
          /**
           * Transform Origin
           * @see https://tailwindcss.com/docs/transform-origin
           */
          "transform-origin": [{
            origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
          }],
          // Interactivity
          /**
           * Accent Color
           * @see https://tailwindcss.com/docs/accent-color
           */
          accent: [{
            accent: ["auto", colors]
          }],
          /**
           * Appearance
           * @see https://tailwindcss.com/docs/appearance
           */
          appearance: ["appearance-none"],
          /**
           * Cursor
           * @see https://tailwindcss.com/docs/cursor
           */
          cursor: [{
            cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
          }],
          /**
           * Caret Color
           * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
           */
          "caret-color": [{
            caret: [colors]
          }],
          /**
           * Pointer Events
           * @see https://tailwindcss.com/docs/pointer-events
           */
          "pointer-events": [{
            "pointer-events": ["none", "auto"]
          }],
          /**
           * Resize
           * @see https://tailwindcss.com/docs/resize
           */
          resize: [{
            resize: ["none", "y", "x", ""]
          }],
          /**
           * Scroll Behavior
           * @see https://tailwindcss.com/docs/scroll-behavior
           */
          "scroll-behavior": [{
            scroll: ["auto", "smooth"]
          }],
          /**
           * Scroll Margin
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-m": [{
            "scroll-m": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin X
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mx": [{
            "scroll-mx": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Y
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-my": [{
            "scroll-my": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Start
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-ms": [{
            "scroll-ms": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin End
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-me": [{
            "scroll-me": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Top
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mt": [{
            "scroll-mt": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Right
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mr": [{
            "scroll-mr": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Bottom
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mb": [{
            "scroll-mb": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Left
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-ml": [{
            "scroll-ml": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-p": [{
            "scroll-p": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding X
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-px": [{
            "scroll-px": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Y
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-py": [{
            "scroll-py": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Start
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-ps": [{
            "scroll-ps": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding End
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pe": [{
            "scroll-pe": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Top
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pt": [{
            "scroll-pt": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Right
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pr": [{
            "scroll-pr": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Bottom
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pb": [{
            "scroll-pb": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Left
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pl": [{
            "scroll-pl": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Snap Align
           * @see https://tailwindcss.com/docs/scroll-snap-align
           */
          "snap-align": [{
            snap: ["start", "end", "center", "align-none"]
          }],
          /**
           * Scroll Snap Stop
           * @see https://tailwindcss.com/docs/scroll-snap-stop
           */
          "snap-stop": [{
            snap: ["normal", "always"]
          }],
          /**
           * Scroll Snap Type
           * @see https://tailwindcss.com/docs/scroll-snap-type
           */
          "snap-type": [{
            snap: ["none", "x", "y", "both"]
          }],
          /**
           * Scroll Snap Type Strictness
           * @see https://tailwindcss.com/docs/scroll-snap-type
           */
          "snap-strictness": [{
            snap: ["mandatory", "proximity"]
          }],
          /**
           * Touch Action
           * @see https://tailwindcss.com/docs/touch-action
           */
          touch: [{
            touch: ["auto", "none", "pinch-zoom", "manipulation", {
              pan: ["x", "left", "right", "y", "up", "down"]
            }]
          }],
          /**
           * User Select
           * @see https://tailwindcss.com/docs/user-select
           */
          select: [{
            select: ["none", "text", "all", "auto"]
          }],
          /**
           * Will Change
           * @see https://tailwindcss.com/docs/will-change
           */
          "will-change": [{
            "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
          }],
          // SVG
          /**
           * Fill
           * @see https://tailwindcss.com/docs/fill
           */
          fill: [{
            fill: [colors, "none"]
          }],
          /**
           * Stroke Width
           * @see https://tailwindcss.com/docs/stroke-width
           */
          "stroke-w": [{
            stroke: [isLength, isArbitraryNumber]
          }],
          /**
           * Stroke
           * @see https://tailwindcss.com/docs/stroke
           */
          stroke: [{
            stroke: [colors, "none"]
          }],
          // Accessibility
          /**
           * Screen Readers
           * @see https://tailwindcss.com/docs/screen-readers
           */
          sr: ["sr-only", "not-sr-only"]
        },
        conflictingClassGroups: {
          overflow: ["overflow-x", "overflow-y"],
          overscroll: ["overscroll-x", "overscroll-y"],
          inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
          "inset-x": ["right", "left"],
          "inset-y": ["top", "bottom"],
          flex: ["basis", "grow", "shrink"],
          gap: ["gap-x", "gap-y"],
          p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
          px: ["pr", "pl"],
          py: ["pt", "pb"],
          m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
          mx: ["mr", "ml"],
          my: ["mt", "mb"],
          "font-size": ["leading"],
          "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
          "fvn-ordinal": ["fvn-normal"],
          "fvn-slashed-zero": ["fvn-normal"],
          "fvn-figure": ["fvn-normal"],
          "fvn-spacing": ["fvn-normal"],
          "fvn-fraction": ["fvn-normal"],
          rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
          "rounded-s": ["rounded-ss", "rounded-es"],
          "rounded-e": ["rounded-se", "rounded-ee"],
          "rounded-t": ["rounded-tl", "rounded-tr"],
          "rounded-r": ["rounded-tr", "rounded-br"],
          "rounded-b": ["rounded-br", "rounded-bl"],
          "rounded-l": ["rounded-tl", "rounded-bl"],
          "border-spacing": ["border-spacing-x", "border-spacing-y"],
          "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
          "border-w-x": ["border-w-r", "border-w-l"],
          "border-w-y": ["border-w-t", "border-w-b"],
          "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
          "border-color-x": ["border-color-r", "border-color-l"],
          "border-color-y": ["border-color-t", "border-color-b"],
          "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
          "scroll-mx": ["scroll-mr", "scroll-ml"],
          "scroll-my": ["scroll-mt", "scroll-mb"],
          "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
          "scroll-px": ["scroll-pr", "scroll-pl"],
          "scroll-py": ["scroll-pt", "scroll-pb"]
        },
        conflictingClassGroupModifiers: {
          "font-size": ["leading"]
        }
      };
    }
    var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
    function cn(...inputs) {
      return twMerge(clsx(inputs));
    }
    const buttonVariants = cva(
      "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      {
        variants: {
          variant: {
            default: "bg-primary text-primary-foreground hover:bg-primary/90",
            destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
            outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
            secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline"
          },
          size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-11 rounded-md px-8",
            icon: "h-10 w-10"
          }
        },
        defaultVariants: {
          variant: "default",
          size: "default"
        }
      }
    );
    const Button = reactExports.forwardRef(
      ({ className, variant, size, asChild = false, ...props }, ref2) => {
        const Comp = asChild ? Slot : "button";
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Comp,
          {
            className: cn(buttonVariants({ variant, size, className })),
            ref: ref2,
            ...props
          }
        );
      }
    );
    Button.displayName = "Button";
    function createContextScope(scopeName, createContextScopeDeps = []) {
      let defaultContexts = [];
      function createContext3(rootComponentName, defaultContext) {
        const BaseContext = reactExports.createContext(defaultContext);
        const index2 = defaultContexts.length;
        defaultContexts = [...defaultContexts, defaultContext];
        const Provider2 = (props) => {
          var _a;
          const { scope, children, ...context } = props;
          const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
          const value = reactExports.useMemo(() => context, Object.values(context));
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
        };
        Provider2.displayName = rootComponentName + "Provider";
        function useContext2(consumerName, scope) {
          var _a;
          const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
          const context = reactExports.useContext(Context);
          if (context) return context;
          if (defaultContext !== void 0) return defaultContext;
          throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
        }
        return [Provider2, useContext2];
      }
      const createScope = () => {
        const scopeContexts = defaultContexts.map((defaultContext) => {
          return reactExports.createContext(defaultContext);
        });
        return function useScope(scope) {
          const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
          return reactExports.useMemo(
            () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
            [scope, contexts]
          );
        };
      };
      createScope.scopeName = scopeName;
      return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
    }
    function composeContextScopes(...scopes) {
      const baseScope = scopes[0];
      if (scopes.length === 1) return baseScope;
      const createScope = () => {
        const scopeHooks = scopes.map((createScope2) => ({
          useScope: createScope2(),
          scopeName: createScope2.scopeName
        }));
        return function useComposedScopes(overrideScopes) {
          const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
            const scopeProps = useScope(overrideScopes);
            const currentScope = scopeProps[`__scope${scopeName}`];
            return { ...nextScopes2, ...currentScope };
          }, {});
          return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
        };
      };
      createScope.scopeName = baseScope.scopeName;
      return createScope;
    }
    function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
      return function handleEvent(event) {
        originalEventHandler == null ? void 0 : originalEventHandler(event);
        if (checkForDefaultPrevented === false || !event.defaultPrevented) {
          return ourEventHandler == null ? void 0 : ourEventHandler(event);
        }
      };
    }
    var useLayoutEffect2 = (globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
    };
    var useInsertionEffect = React$1[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
    function useControllableState({
      prop,
      defaultProp,
      onChange = () => {
      },
      caller
    }) {
      const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
        defaultProp,
        onChange
      });
      const isControlled = prop !== void 0;
      const value = isControlled ? prop : uncontrolledProp;
      {
        const isControlledRef = reactExports.useRef(prop !== void 0);
        reactExports.useEffect(() => {
          const wasControlled = isControlledRef.current;
          if (wasControlled !== isControlled) {
            const from = wasControlled ? "controlled" : "uncontrolled";
            const to = isControlled ? "controlled" : "uncontrolled";
            console.warn(
              `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
            );
          }
          isControlledRef.current = isControlled;
        }, [isControlled, caller]);
      }
      const setValue = reactExports.useCallback(
        (nextValue) => {
          var _a;
          if (isControlled) {
            const value2 = isFunction$1(nextValue) ? nextValue(prop) : nextValue;
            if (value2 !== prop) {
              (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, value2);
            }
          } else {
            setUncontrolledProp(nextValue);
          }
        },
        [isControlled, prop, setUncontrolledProp, onChangeRef]
      );
      return [value, setValue];
    }
    function useUncontrolledState({
      defaultProp,
      onChange
    }) {
      const [value, setValue] = reactExports.useState(defaultProp);
      const prevValueRef = reactExports.useRef(value);
      const onChangeRef = reactExports.useRef(onChange);
      useInsertionEffect(() => {
        onChangeRef.current = onChange;
      }, [onChange]);
      reactExports.useEffect(() => {
        var _a;
        if (prevValueRef.current !== value) {
          (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, value);
          prevValueRef.current = value;
        }
      }, [value, prevValueRef]);
      return [value, setValue, onChangeRef];
    }
    function isFunction$1(value) {
      return typeof value === "function";
    }
    function usePrevious(value) {
      const ref2 = reactExports.useRef({ value, previous: value });
      return reactExports.useMemo(() => {
        if (ref2.current.value !== value) {
          ref2.current.previous = ref2.current.value;
          ref2.current.value = value;
        }
        return ref2.current.previous;
      }, [value]);
    }
    function useSize(element) {
      const [size, setSize] = reactExports.useState(void 0);
      useLayoutEffect2(() => {
        if (element) {
          setSize({ width: element.offsetWidth, height: element.offsetHeight });
          const resizeObserver = new ResizeObserver((entries) => {
            if (!Array.isArray(entries)) {
              return;
            }
            if (!entries.length) {
              return;
            }
            const entry = entries[0];
            let width;
            let height;
            if ("borderBoxSize" in entry) {
              const borderSizeEntry = entry["borderBoxSize"];
              const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
              width = borderSize["inlineSize"];
              height = borderSize["blockSize"];
            } else {
              width = element.offsetWidth;
              height = element.offsetHeight;
            }
            setSize({ width, height });
          });
          resizeObserver.observe(element, { box: "border-box" });
          return () => resizeObserver.unobserve(element);
        } else {
          setSize(void 0);
        }
      }, [element]);
      return size;
    }
    function useStateMachine(initialState2, machine) {
      return reactExports.useReducer((state, event) => {
        const nextState = machine[state][event];
        return nextState ?? state;
      }, initialState2);
    }
    var Presence = (props) => {
      const { present, children } = props;
      const presence = usePresence(present);
      const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
      const ref2 = useComposedRefs(presence.ref, getElementRef(child));
      const forceMount = typeof children === "function";
      return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref: ref2 }) : null;
    };
    Presence.displayName = "Presence";
    function usePresence(present) {
      const [node, setNode] = reactExports.useState();
      const stylesRef = reactExports.useRef(null);
      const prevPresentRef = reactExports.useRef(present);
      const prevAnimationNameRef = reactExports.useRef("none");
      const initialState2 = present ? "mounted" : "unmounted";
      const [state, send] = useStateMachine(initialState2, {
        mounted: {
          UNMOUNT: "unmounted",
          ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
          MOUNT: "mounted",
          ANIMATION_END: "unmounted"
        },
        unmounted: {
          MOUNT: "mounted"
        }
      });
      reactExports.useEffect(() => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
      }, [state]);
      useLayoutEffect2(() => {
        const styles = stylesRef.current;
        const wasPresent = prevPresentRef.current;
        const hasPresentChanged = wasPresent !== present;
        if (hasPresentChanged) {
          const prevAnimationName = prevAnimationNameRef.current;
          const currentAnimationName = getAnimationName(styles);
          if (present) {
            send("MOUNT");
          } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
            send("UNMOUNT");
          } else {
            const isAnimating = prevAnimationName !== currentAnimationName;
            if (wasPresent && isAnimating) {
              send("ANIMATION_OUT");
            } else {
              send("UNMOUNT");
            }
          }
          prevPresentRef.current = present;
        }
      }, [present, send]);
      useLayoutEffect2(() => {
        if (node) {
          let timeoutId;
          const ownerWindow = node.ownerDocument.defaultView ?? window;
          const handleAnimationEnd = (event) => {
            const currentAnimationName = getAnimationName(stylesRef.current);
            const isCurrentAnimation = currentAnimationName.includes(event.animationName);
            if (event.target === node && isCurrentAnimation) {
              send("ANIMATION_END");
              if (!prevPresentRef.current) {
                const currentFillMode = node.style.animationFillMode;
                node.style.animationFillMode = "forwards";
                timeoutId = ownerWindow.setTimeout(() => {
                  if (node.style.animationFillMode === "forwards") {
                    node.style.animationFillMode = currentFillMode;
                  }
                });
              }
            }
          };
          const handleAnimationStart = (event) => {
            if (event.target === node) {
              prevAnimationNameRef.current = getAnimationName(stylesRef.current);
            }
          };
          node.addEventListener("animationstart", handleAnimationStart);
          node.addEventListener("animationcancel", handleAnimationEnd);
          node.addEventListener("animationend", handleAnimationEnd);
          return () => {
            ownerWindow.clearTimeout(timeoutId);
            node.removeEventListener("animationstart", handleAnimationStart);
            node.removeEventListener("animationcancel", handleAnimationEnd);
            node.removeEventListener("animationend", handleAnimationEnd);
          };
        } else {
          send("ANIMATION_END");
        }
      }, [node, send]);
      return {
        isPresent: ["mounted", "unmountSuspended"].includes(state),
        ref: reactExports.useCallback((node2) => {
          stylesRef.current = node2 ? getComputedStyle(node2) : null;
          setNode(node2);
        }, [])
      };
    }
    function getAnimationName(styles) {
      return (styles == null ? void 0 : styles.animationName) || "none";
    }
    function getElementRef(element) {
      var _a, _b;
      let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
      let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
      if (mayWarn) {
        return element.ref;
      }
      getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
      mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
      if (mayWarn) {
        return element.props.ref;
      }
      return element.props.ref || element.ref;
    }
    var NODES = [
      "a",
      "button",
      "div",
      "form",
      "h2",
      "h3",
      "img",
      "input",
      "label",
      "li",
      "nav",
      "ol",
      "p",
      "select",
      "span",
      "svg",
      "ul"
    ];
    var Primitive = NODES.reduce((primitive, node) => {
      const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
      const Node = reactExports.forwardRef((props, forwardedRef) => {
        const { asChild, ...primitiveProps } = props;
        const Comp = asChild ? Slot2 : node;
        if (typeof window !== "undefined") {
          window[Symbol.for("radix-ui")] = true;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
      });
      Node.displayName = `Primitive.${node}`;
      return { ...primitive, [node]: Node };
    }, {});
    function dispatchDiscreteCustomEvent(target, event) {
      if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
    }
    var CHECKBOX_NAME = "Checkbox";
    var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
    var [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
    function CheckboxProvider(props) {
      const {
        __scopeCheckbox,
        checked: checkedProp,
        children,
        defaultChecked,
        disabled,
        form,
        name,
        onCheckedChange,
        required: required2,
        value = "on",
        // @ts-expect-error
        internal_do_not_use_render
      } = props;
      const [checked, setChecked] = useControllableState({
        prop: checkedProp,
        defaultProp: defaultChecked ?? false,
        onChange: onCheckedChange,
        caller: CHECKBOX_NAME
      });
      const [control, setControl] = reactExports.useState(null);
      const [bubbleInput, setBubbleInput] = reactExports.useState(null);
      const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
      const isFormControl = control ? !!form || !!control.closest("form") : (
        // We set this to true by default so that events bubble to forms without JS (SSR)
        true
      );
      const context = {
        checked,
        disabled,
        setChecked,
        control,
        setControl,
        name,
        form,
        value,
        hasConsumerStoppedPropagationRef,
        required: required2,
        defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked,
        isFormControl,
        bubbleInput,
        setBubbleInput
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CheckboxProviderImpl,
        {
          scope: __scopeCheckbox,
          ...context,
          children: isFunction(internal_do_not_use_render) ? internal_do_not_use_render(context) : children
        }
      );
    }
    var TRIGGER_NAME = "CheckboxTrigger";
    var CheckboxTrigger = reactExports.forwardRef(
      ({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {
        const {
          control,
          value,
          disabled,
          checked,
          required: required2,
          setControl,
          setChecked,
          hasConsumerStoppedPropagationRef,
          isFormControl,
          bubbleInput
        } = useCheckboxContext(TRIGGER_NAME, __scopeCheckbox);
        const composedRefs = useComposedRefs(forwardedRef, setControl);
        const initialCheckedStateRef = reactExports.useRef(checked);
        reactExports.useEffect(() => {
          const form = control == null ? void 0 : control.form;
          if (form) {
            const reset = () => setChecked(initialCheckedStateRef.current);
            form.addEventListener("reset", reset);
            return () => form.removeEventListener("reset", reset);
          }
        }, [control, setChecked]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "checkbox",
            "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
            "aria-required": required2,
            "data-state": getState(checked),
            "data-disabled": disabled ? "" : void 0,
            disabled,
            value,
            ...checkboxProps,
            ref: composedRefs,
            onKeyDown: composeEventHandlers(onKeyDown, (event) => {
              if (event.key === "Enter") event.preventDefault();
            }),
            onClick: composeEventHandlers(onClick, (event) => {
              setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
              if (bubbleInput && isFormControl) {
                hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
                if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
              }
            })
          }
        );
      }
    );
    CheckboxTrigger.displayName = TRIGGER_NAME;
    var Checkbox$1 = reactExports.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeCheckbox,
          name,
          checked,
          defaultChecked,
          required: required2,
          disabled,
          value,
          onCheckedChange,
          form,
          ...checkboxProps
        } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CheckboxProvider,
          {
            __scopeCheckbox,
            checked,
            defaultChecked,
            disabled,
            required: required2,
            onCheckedChange,
            name,
            form,
            value,
            internal_do_not_use_render: ({ isFormControl }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CheckboxTrigger,
                {
                  ...checkboxProps,
                  ref: forwardedRef,
                  __scopeCheckbox
                }
              ),
              isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
                CheckboxBubbleInput,
                {
                  __scopeCheckbox
                }
              )
            ] })
          }
        );
      }
    );
    Checkbox$1.displayName = CHECKBOX_NAME;
    var INDICATOR_NAME = "CheckboxIndicator";
    var CheckboxIndicator = reactExports.forwardRef(
      (props, forwardedRef) => {
        const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
        const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Presence,
          {
            present: forceMount || isIndeterminate(context.checked) || context.checked === true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.span,
              {
                "data-state": getState(context.checked),
                "data-disabled": context.disabled ? "" : void 0,
                ...indicatorProps,
                ref: forwardedRef,
                style: { pointerEvents: "none", ...props.style }
              }
            )
          }
        );
      }
    );
    CheckboxIndicator.displayName = INDICATOR_NAME;
    var BUBBLE_INPUT_NAME = "CheckboxBubbleInput";
    var CheckboxBubbleInput = reactExports.forwardRef(
      ({ __scopeCheckbox, ...props }, forwardedRef) => {
        const {
          control,
          hasConsumerStoppedPropagationRef,
          checked,
          defaultChecked,
          required: required2,
          disabled,
          name,
          value,
          form,
          bubbleInput,
          setBubbleInput
        } = useCheckboxContext(BUBBLE_INPUT_NAME, __scopeCheckbox);
        const composedRefs = useComposedRefs(forwardedRef, setBubbleInput);
        const prevChecked = usePrevious(checked);
        const controlSize = useSize(control);
        reactExports.useEffect(() => {
          const input = bubbleInput;
          if (!input) return;
          const inputProto = window.HTMLInputElement.prototype;
          const descriptor = Object.getOwnPropertyDescriptor(
            inputProto,
            "checked"
          );
          const setChecked = descriptor.set;
          const bubbles = !hasConsumerStoppedPropagationRef.current;
          if (prevChecked !== checked && setChecked) {
            const event = new Event("click", { bubbles });
            input.indeterminate = isIndeterminate(checked);
            setChecked.call(input, isIndeterminate(checked) ? false : checked);
            input.dispatchEvent(event);
          }
        }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);
        const defaultCheckedRef = reactExports.useRef(isIndeterminate(checked) ? false : checked);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.input,
          {
            type: "checkbox",
            "aria-hidden": true,
            defaultChecked: defaultChecked ?? defaultCheckedRef.current,
            required: required2,
            disabled,
            name,
            value,
            form,
            ...props,
            tabIndex: -1,
            ref: composedRefs,
            style: {
              ...props.style,
              ...controlSize,
              position: "absolute",
              pointerEvents: "none",
              opacity: 0,
              margin: 0,
              // We transform because the input is absolutely positioned but we have
              // rendered it **after** the button. This pulls it back to sit on top
              // of the button.
              transform: "translateX(-100%)"
            }
          }
        );
      }
    );
    CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;
    function isFunction(value) {
      return typeof value === "function";
    }
    function isIndeterminate(checked) {
      return checked === "indeterminate";
    }
    function getState(checked) {
      return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
    }
    var defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    const toKebabCase = (string2) => string2.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    const createLucideIcon = (iconName, iconNode) => {
      const Component = reactExports.forwardRef(
        ({ color = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, children, ...rest }, ref2) => reactExports.createElement(
          "svg",
          {
            ref: ref2,
            ...defaultAttributes,
            width: size,
            height: size,
            stroke: color,
            strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
            className: `lucide lucide-${toKebabCase(iconName)}`,
            ...rest
          },
          [
            ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
            ...(Array.isArray(children) ? children : [children]) || []
          ]
        )
      );
      Component.displayName = `${iconName}`;
      return Component;
    };
    const Check = createLucideIcon("Check", [
      ["polyline", { points: "20 6 9 17 4 12", key: "10jjfj" }]
    ]);
    const X = createLucideIcon("X", [
      ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
      ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
    ]);
    const Checkbox = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox$1,
      {
        ref: ref2,
        className: cn(
          "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          CheckboxIndicator,
          {
            className: cn("flex items-center justify-center text-current"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" })
          }
        )
      }
    ));
    Checkbox.displayName = Checkbox$1.displayName;
    const Input = reactExports.forwardRef(
      ({ className, type, ...props }, ref2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type,
            className: cn(
              "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
              className
            ),
            ref: ref2,
            ...props
          }
        );
      }
    );
    Input.displayName = "Input";
    function Skeleton({
      className,
      ...props
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: cn("animate-pulse rounded-md bg-muted", className),
          ...props
        }
      );
    }
    function createCollection(name) {
      const PROVIDER_NAME2 = name + "CollectionProvider";
      const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
      const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
        PROVIDER_NAME2,
        { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
      );
      const CollectionProvider = (props) => {
        const { scope, children } = props;
        const ref2 = React.useRef(null);
        const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref2, children });
      };
      CollectionProvider.displayName = PROVIDER_NAME2;
      const COLLECTION_SLOT_NAME = name + "CollectionSlot";
      const CollectionSlotImpl = /* @__PURE__ */ createSlot(COLLECTION_SLOT_NAME);
      const CollectionSlot = React.forwardRef(
        (props, forwardedRef) => {
          const { scope, children } = props;
          const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
          const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionSlotImpl, { ref: composedRefs, children });
        }
      );
      CollectionSlot.displayName = COLLECTION_SLOT_NAME;
      const ITEM_SLOT_NAME = name + "CollectionItemSlot";
      const ITEM_DATA_ATTR = "data-radix-collection-item";
      const CollectionItemSlotImpl = /* @__PURE__ */ createSlot(ITEM_SLOT_NAME);
      const CollectionItemSlot = React.forwardRef(
        (props, forwardedRef) => {
          const { scope, children, ...itemData } = props;
          const ref2 = React.useRef(null);
          const composedRefs = useComposedRefs(forwardedRef, ref2);
          const context = useCollectionContext(ITEM_SLOT_NAME, scope);
          React.useEffect(() => {
            context.itemMap.set(ref2, { ref: ref2, ...itemData });
            return () => void context.itemMap.delete(ref2);
          });
          return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
        }
      );
      CollectionItemSlot.displayName = ITEM_SLOT_NAME;
      function useCollection2(scope) {
        const context = useCollectionContext(name + "CollectionConsumer", scope);
        const getItems = React.useCallback(() => {
          const collectionNode = context.collectionRef.current;
          if (!collectionNode) return [];
          const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
          const items = Array.from(context.itemMap.values());
          const orderedItems = items.sort(
            (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
          );
          return orderedItems;
        }, [context.collectionRef, context.itemMap]);
        return getItems;
      }
      return [
        { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
        useCollection2,
        createCollectionScope2
      ];
    }
    function useCallbackRef(callback) {
      const callbackRef = reactExports.useRef(callback);
      reactExports.useEffect(() => {
        callbackRef.current = callback;
      });
      return reactExports.useMemo(() => (...args) => {
        var _a;
        return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
      }, []);
    }
    function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
      const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
      reactExports.useEffect(() => {
        const handleKeyDown = (event) => {
          if (event.key === "Escape") {
            onEscapeKeyDown(event);
          }
        };
        ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
        return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
      }, [onEscapeKeyDown, ownerDocument]);
    }
    var DISMISSABLE_LAYER_NAME = "DismissableLayer";
    var CONTEXT_UPDATE = "dismissableLayer.update";
    var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
    var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
    var originalBodyPointerEvents;
    var DismissableLayerContext = reactExports.createContext({
      layers: /* @__PURE__ */ new Set(),
      layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
      branches: /* @__PURE__ */ new Set()
    });
    var DismissableLayer = reactExports.forwardRef(
      (props, forwardedRef) => {
        const {
          disableOutsidePointerEvents = false,
          onEscapeKeyDown,
          onPointerDownOutside,
          onFocusOutside,
          onInteractOutside,
          onDismiss,
          ...layerProps
        } = props;
        const context = reactExports.useContext(DismissableLayerContext);
        const [node, setNode] = reactExports.useState(null);
        const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
        const [, force] = reactExports.useState({});
        const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
        const layers = Array.from(context.layers);
        const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
        const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
        const index2 = node ? layers.indexOf(node) : -1;
        const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
        const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
        const pointerDownOutside = usePointerDownOutside((event) => {
          const target = event.target;
          const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
          if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
          onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
          onInteractOutside == null ? void 0 : onInteractOutside(event);
          if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
        }, ownerDocument);
        const focusOutside = useFocusOutside((event) => {
          const target = event.target;
          const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
          if (isFocusInBranch) return;
          onFocusOutside == null ? void 0 : onFocusOutside(event);
          onInteractOutside == null ? void 0 : onInteractOutside(event);
          if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
        }, ownerDocument);
        useEscapeKeydown((event) => {
          const isHighestLayer = index2 === context.layers.size - 1;
          if (!isHighestLayer) return;
          onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
          if (!event.defaultPrevented && onDismiss) {
            event.preventDefault();
            onDismiss();
          }
        }, ownerDocument);
        reactExports.useEffect(() => {
          if (!node) return;
          if (disableOutsidePointerEvents) {
            if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
              originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
              ownerDocument.body.style.pointerEvents = "none";
            }
            context.layersWithOutsidePointerEventsDisabled.add(node);
          }
          context.layers.add(node);
          dispatchUpdate();
          return () => {
            if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
              ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
            }
          };
        }, [node, ownerDocument, disableOutsidePointerEvents, context]);
        reactExports.useEffect(() => {
          return () => {
            if (!node) return;
            context.layers.delete(node);
            context.layersWithOutsidePointerEventsDisabled.delete(node);
            dispatchUpdate();
          };
        }, [node, context]);
        reactExports.useEffect(() => {
          const handleUpdate = () => force({});
          document.addEventListener(CONTEXT_UPDATE, handleUpdate);
          return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
        }, []);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            ...layerProps,
            ref: composedRefs,
            style: {
              pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
              ...props.style
            },
            onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
            onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
            onPointerDownCapture: composeEventHandlers(
              props.onPointerDownCapture,
              pointerDownOutside.onPointerDownCapture
            )
          }
        );
      }
    );
    DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
    var BRANCH_NAME = "DismissableLayerBranch";
    var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
      const context = reactExports.useContext(DismissableLayerContext);
      const ref2 = reactExports.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref2);
      reactExports.useEffect(() => {
        const node = ref2.current;
        if (node) {
          context.branches.add(node);
          return () => {
            context.branches.delete(node);
          };
        }
      }, [context.branches]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
    });
    DismissableLayerBranch.displayName = BRANCH_NAME;
    function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
      const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
      const isPointerInsideReactTreeRef = reactExports.useRef(false);
      const handleClickRef = reactExports.useRef(() => {
      });
      reactExports.useEffect(() => {
        const handlePointerDown = (event) => {
          if (event.target && !isPointerInsideReactTreeRef.current) {
            let handleAndDispatchPointerDownOutsideEvent2 = function() {
              handleAndDispatchCustomEvent$1(
                POINTER_DOWN_OUTSIDE,
                handlePointerDownOutside,
                eventDetail,
                { discrete: true }
              );
            };
            const eventDetail = { originalEvent: event };
            if (event.pointerType === "touch") {
              ownerDocument.removeEventListener("click", handleClickRef.current);
              handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
              ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
            } else {
              handleAndDispatchPointerDownOutsideEvent2();
            }
          } else {
            ownerDocument.removeEventListener("click", handleClickRef.current);
          }
          isPointerInsideReactTreeRef.current = false;
        };
        const timerId = window.setTimeout(() => {
          ownerDocument.addEventListener("pointerdown", handlePointerDown);
        }, 0);
        return () => {
          window.clearTimeout(timerId);
          ownerDocument.removeEventListener("pointerdown", handlePointerDown);
          ownerDocument.removeEventListener("click", handleClickRef.current);
        };
      }, [ownerDocument, handlePointerDownOutside]);
      return {
        // ensures we check React component tree (not just DOM tree)
        onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
      };
    }
    function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
      const handleFocusOutside = useCallbackRef(onFocusOutside);
      const isFocusInsideReactTreeRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        const handleFocus = (event) => {
          if (event.target && !isFocusInsideReactTreeRef.current) {
            const eventDetail = { originalEvent: event };
            handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
              discrete: false
            });
          }
        };
        ownerDocument.addEventListener("focusin", handleFocus);
        return () => ownerDocument.removeEventListener("focusin", handleFocus);
      }, [ownerDocument, handleFocusOutside]);
      return {
        onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
        onBlurCapture: () => isFocusInsideReactTreeRef.current = false
      };
    }
    function dispatchUpdate() {
      const event = new CustomEvent(CONTEXT_UPDATE);
      document.dispatchEvent(event);
    }
    function handleAndDispatchCustomEvent$1(name, handler, detail, { discrete }) {
      const target = detail.originalEvent.target;
      const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
      if (handler) target.addEventListener(name, handler, { once: true });
      if (discrete) {
        dispatchDiscreteCustomEvent(target, event);
      } else {
        target.dispatchEvent(event);
      }
    }
    var Root = DismissableLayer;
    var Branch = DismissableLayerBranch;
    var PORTAL_NAME = "Portal";
    var Portal = reactExports.forwardRef((props, forwardedRef) => {
      var _a;
      const { container: containerProp, ...portalProps } = props;
      const [mounted, setMounted] = reactExports.useState(false);
      useLayoutEffect2(() => setMounted(true), []);
      const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
      return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
    });
    Portal.displayName = PORTAL_NAME;
    var VISUALLY_HIDDEN_STYLES = Object.freeze({
      // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
      position: "absolute",
      border: 0,
      width: 1,
      height: 1,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    });
    var NAME = "VisuallyHidden";
    var VisuallyHidden = reactExports.forwardRef(
      (props, forwardedRef) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            ...props,
            ref: forwardedRef,
            style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
          }
        );
      }
    );
    VisuallyHidden.displayName = NAME;
    var PROVIDER_NAME = "ToastProvider";
    var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
    var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
    var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
    var ToastProvider$1 = (props) => {
      const {
        __scopeToast,
        label = "Notification",
        duration: duration2 = 5e3,
        swipeDirection = "right",
        swipeThreshold = 50,
        children
      } = props;
      const [viewport, setViewport] = reactExports.useState(null);
      const [toastCount, setToastCount] = reactExports.useState(0);
      const isFocusedToastEscapeKeyDownRef = reactExports.useRef(false);
      const isClosePausedRef = reactExports.useRef(false);
      if (!label.trim()) {
        console.error(
          `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastProviderProvider,
        {
          scope: __scopeToast,
          label,
          duration: duration2,
          swipeDirection,
          swipeThreshold,
          toastCount,
          viewport,
          onViewportChange: setViewport,
          onToastAdd: reactExports.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
          onToastRemove: reactExports.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
          isFocusedToastEscapeKeyDownRef,
          isClosePausedRef,
          children
        }
      ) });
    };
    ToastProvider$1.displayName = PROVIDER_NAME;
    var VIEWPORT_NAME = "ToastViewport";
    var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
    var VIEWPORT_PAUSE = "toast.viewportPause";
    var VIEWPORT_RESUME = "toast.viewportResume";
    var ToastViewport$1 = reactExports.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeToast,
          hotkey = VIEWPORT_DEFAULT_HOTKEY,
          label = "Notifications ({hotkey})",
          ...viewportProps
        } = props;
        const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
        const getItems = useCollection(__scopeToast);
        const wrapperRef = reactExports.useRef(null);
        const headFocusProxyRef = reactExports.useRef(null);
        const tailFocusProxyRef = reactExports.useRef(null);
        const ref2 = reactExports.useRef(null);
        const composedRefs = useComposedRefs(forwardedRef, ref2, context.onViewportChange);
        const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
        const hasToasts = context.toastCount > 0;
        reactExports.useEffect(() => {
          const handleKeyDown = (event) => {
            var _a;
            const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
            if (isHotkeyPressed) (_a = ref2.current) == null ? void 0 : _a.focus();
          };
          document.addEventListener("keydown", handleKeyDown);
          return () => document.removeEventListener("keydown", handleKeyDown);
        }, [hotkey]);
        reactExports.useEffect(() => {
          const wrapper = wrapperRef.current;
          const viewport = ref2.current;
          if (hasToasts && wrapper && viewport) {
            const handlePause = () => {
              if (!context.isClosePausedRef.current) {
                const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
                viewport.dispatchEvent(pauseEvent);
                context.isClosePausedRef.current = true;
              }
            };
            const handleResume = () => {
              if (context.isClosePausedRef.current) {
                const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
                viewport.dispatchEvent(resumeEvent);
                context.isClosePausedRef.current = false;
              }
            };
            const handleFocusOutResume = (event) => {
              const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
              if (isFocusMovingOutside) handleResume();
            };
            const handlePointerLeaveResume = () => {
              const isFocusInside = wrapper.contains(document.activeElement);
              if (!isFocusInside) handleResume();
            };
            wrapper.addEventListener("focusin", handlePause);
            wrapper.addEventListener("focusout", handleFocusOutResume);
            wrapper.addEventListener("pointermove", handlePause);
            wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
            window.addEventListener("blur", handlePause);
            window.addEventListener("focus", handleResume);
            return () => {
              wrapper.removeEventListener("focusin", handlePause);
              wrapper.removeEventListener("focusout", handleFocusOutResume);
              wrapper.removeEventListener("pointermove", handlePause);
              wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
              window.removeEventListener("blur", handlePause);
              window.removeEventListener("focus", handleResume);
            };
          }
        }, [hasToasts, context.isClosePausedRef]);
        const getSortedTabbableCandidates = reactExports.useCallback(
          ({ tabbingDirection }) => {
            const toastItems = getItems();
            const tabbableCandidates = toastItems.map((toastItem) => {
              const toastNode = toastItem.ref.current;
              const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
              return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
            });
            return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
          },
          [getItems]
        );
        reactExports.useEffect(() => {
          const viewport = ref2.current;
          if (viewport) {
            const handleKeyDown = (event) => {
              var _a, _b, _c;
              const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
              const isTabKey = event.key === "Tab" && !isMetaKey;
              if (isTabKey) {
                const focusedElement = document.activeElement;
                const isTabbingBackwards = event.shiftKey;
                const targetIsViewport = event.target === viewport;
                if (targetIsViewport && isTabbingBackwards) {
                  (_a = headFocusProxyRef.current) == null ? void 0 : _a.focus();
                  return;
                }
                const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
                const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
                const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
                if (focusFirst(sortedCandidates.slice(index2 + 1))) {
                  event.preventDefault();
                } else {
                  isTabbingBackwards ? (_b = headFocusProxyRef.current) == null ? void 0 : _b.focus() : (_c = tailFocusProxyRef.current) == null ? void 0 : _c.focus();
                }
              }
            };
            viewport.addEventListener("keydown", handleKeyDown);
            return () => viewport.removeEventListener("keydown", handleKeyDown);
          }
        }, [getItems, getSortedTabbableCandidates]);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Branch,
          {
            ref: wrapperRef,
            role: "region",
            "aria-label": label.replace("{hotkey}", hotkeyLabel),
            tabIndex: -1,
            style: { pointerEvents: hasToasts ? void 0 : "none" },
            children: [
              hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
                FocusProxy,
                {
                  ref: headFocusProxyRef,
                  onFocusFromOutsideViewport: () => {
                    const tabbableCandidates = getSortedTabbableCandidates({
                      tabbingDirection: "forwards"
                    });
                    focusFirst(tabbableCandidates);
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
              hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
                FocusProxy,
                {
                  ref: tailFocusProxyRef,
                  onFocusFromOutsideViewport: () => {
                    const tabbableCandidates = getSortedTabbableCandidates({
                      tabbingDirection: "backwards"
                    });
                    focusFirst(tabbableCandidates);
                  }
                }
              )
            ]
          }
        );
      }
    );
    ToastViewport$1.displayName = VIEWPORT_NAME;
    var FOCUS_PROXY_NAME = "ToastFocusProxy";
    var FocusProxy = reactExports.forwardRef(
      (props, forwardedRef) => {
        const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
        const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          VisuallyHidden,
          {
            "aria-hidden": true,
            tabIndex: 0,
            ...proxyProps,
            ref: forwardedRef,
            style: { position: "fixed" },
            onFocus: (event) => {
              var _a;
              const prevFocusedElement = event.relatedTarget;
              const isFocusFromOutsideViewport = !((_a = context.viewport) == null ? void 0 : _a.contains(prevFocusedElement));
              if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
            }
          }
        );
      }
    );
    FocusProxy.displayName = FOCUS_PROXY_NAME;
    var TOAST_NAME = "Toast";
    var TOAST_SWIPE_START = "toast.swipeStart";
    var TOAST_SWIPE_MOVE = "toast.swipeMove";
    var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
    var TOAST_SWIPE_END = "toast.swipeEnd";
    var Toast$1 = reactExports.forwardRef(
      (props, forwardedRef) => {
        const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
        const [open, setOpen] = useControllableState({
          prop: openProp,
          defaultProp: defaultOpen ?? true,
          onChange: onOpenChange,
          caller: TOAST_NAME
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToastImpl,
          {
            open,
            ...toastProps,
            ref: forwardedRef,
            onClose: () => setOpen(false),
            onPause: useCallbackRef(props.onPause),
            onResume: useCallbackRef(props.onResume),
            onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
              event.currentTarget.setAttribute("data-swipe", "start");
            }),
            onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
              const { x, y } = event.detail.delta;
              event.currentTarget.setAttribute("data-swipe", "move");
              event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
              event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
            }),
            onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
              event.currentTarget.setAttribute("data-swipe", "cancel");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
            }),
            onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
              const { x, y } = event.detail.delta;
              event.currentTarget.setAttribute("data-swipe", "end");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
              event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
              event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
              setOpen(false);
            })
          }
        ) });
      }
    );
    Toast$1.displayName = TOAST_NAME;
    var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
      onClose() {
      }
    });
    var ToastImpl = reactExports.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeToast,
          type = "foreground",
          duration: durationProp,
          open,
          onClose,
          onEscapeKeyDown,
          onPause,
          onResume,
          onSwipeStart,
          onSwipeMove,
          onSwipeCancel,
          onSwipeEnd,
          ...toastProps
        } = props;
        const context = useToastProviderContext(TOAST_NAME, __scopeToast);
        const [node, setNode] = reactExports.useState(null);
        const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
        const pointerStartRef = reactExports.useRef(null);
        const swipeDeltaRef = reactExports.useRef(null);
        const duration2 = durationProp || context.duration;
        const closeTimerStartTimeRef = reactExports.useRef(0);
        const closeTimerRemainingTimeRef = reactExports.useRef(duration2);
        const closeTimerRef = reactExports.useRef(0);
        const { onToastAdd, onToastRemove } = context;
        const handleClose = useCallbackRef(() => {
          var _a;
          const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
          if (isFocusInToast) (_a = context.viewport) == null ? void 0 : _a.focus();
          onClose();
        });
        const startTimer = reactExports.useCallback(
          (duration22) => {
            if (!duration22 || duration22 === Infinity) return;
            window.clearTimeout(closeTimerRef.current);
            closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
            closeTimerRef.current = window.setTimeout(handleClose, duration22);
          },
          [handleClose]
        );
        reactExports.useEffect(() => {
          const viewport = context.viewport;
          if (viewport) {
            const handleResume = () => {
              startTimer(closeTimerRemainingTimeRef.current);
              onResume == null ? void 0 : onResume();
            };
            const handlePause = () => {
              const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
              closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
              window.clearTimeout(closeTimerRef.current);
              onPause == null ? void 0 : onPause();
            };
            viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
            viewport.addEventListener(VIEWPORT_RESUME, handleResume);
            return () => {
              viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
              viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
            };
          }
        }, [context.viewport, duration2, onPause, onResume, startTimer]);
        reactExports.useEffect(() => {
          if (open && !context.isClosePausedRef.current) startTimer(duration2);
        }, [open, duration2, context.isClosePausedRef, startTimer]);
        reactExports.useEffect(() => {
          onToastAdd();
          return () => onToastRemove();
        }, [onToastAdd, onToastRemove]);
        const announceTextContent = reactExports.useMemo(() => {
          return node ? getAnnounceTextContent(node) : null;
        }, [node]);
        if (!context.viewport) return null;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ToastAnnounce,
            {
              __scopeToast,
              role: "status",
              "aria-live": type === "foreground" ? "assertive" : "polite",
              "aria-atomic": true,
              children: announceTextContent
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: reactDomExports.createPortal(
            /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Root,
              {
                asChild: true,
                onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
                  context.isFocusedToastEscapeKeyDownRef.current = false;
                }),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Primitive.li,
                  {
                    role: "status",
                    "aria-live": "off",
                    "aria-atomic": true,
                    tabIndex: 0,
                    "data-state": open ? "open" : "closed",
                    "data-swipe-direction": context.swipeDirection,
                    ...toastProps,
                    ref: composedRefs,
                    style: { userSelect: "none", touchAction: "none", ...props.style },
                    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                      if (event.key !== "Escape") return;
                      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                      if (!event.nativeEvent.defaultPrevented) {
                        context.isFocusedToastEscapeKeyDownRef.current = true;
                        handleClose();
                      }
                    }),
                    onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                      if (event.button !== 0) return;
                      pointerStartRef.current = { x: event.clientX, y: event.clientY };
                    }),
                    onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                      if (!pointerStartRef.current) return;
                      const x = event.clientX - pointerStartRef.current.x;
                      const y = event.clientY - pointerStartRef.current.y;
                      const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                      const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                      const clamp = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                      const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
                      const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
                      const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                      const delta = { x: clampedX, y: clampedY };
                      const eventDetail = { originalEvent: event, delta };
                      if (hasSwipeMoveStarted) {
                        swipeDeltaRef.current = delta;
                        handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                          discrete: false
                        });
                      } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                        swipeDeltaRef.current = delta;
                        handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                          discrete: false
                        });
                        event.target.setPointerCapture(event.pointerId);
                      } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                        pointerStartRef.current = null;
                      }
                    }),
                    onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                      const delta = swipeDeltaRef.current;
                      const target = event.target;
                      if (target.hasPointerCapture(event.pointerId)) {
                        target.releasePointerCapture(event.pointerId);
                      }
                      swipeDeltaRef.current = null;
                      pointerStartRef.current = null;
                      if (delta) {
                        const toast2 = event.currentTarget;
                        const eventDetail = { originalEvent: event, delta };
                        if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                          handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                            discrete: true
                          });
                        } else {
                          handleAndDispatchCustomEvent(
                            TOAST_SWIPE_CANCEL,
                            onSwipeCancel,
                            eventDetail,
                            {
                              discrete: true
                            }
                          );
                        }
                        toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                          once: true
                        });
                      }
                    })
                  }
                )
              }
            ) }),
            context.viewport
          ) })
        ] });
      }
    );
    var ToastAnnounce = (props) => {
      const { __scopeToast, children, ...announceProps } = props;
      const context = useToastProviderContext(TOAST_NAME, __scopeToast);
      const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
      const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
      useNextFrame(() => setRenderAnnounceText(true));
      reactExports.useEffect(() => {
        const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
        return () => window.clearTimeout(timer);
      }, []);
      return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        context.label,
        " ",
        children
      ] }) }) });
    };
    var TITLE_NAME = "ToastTitle";
    var ToastTitle$1 = reactExports.forwardRef(
      (props, forwardedRef) => {
        const { __scopeToast, ...titleProps } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...titleProps, ref: forwardedRef });
      }
    );
    ToastTitle$1.displayName = TITLE_NAME;
    var DESCRIPTION_NAME = "ToastDescription";
    var ToastDescription$1 = reactExports.forwardRef(
      (props, forwardedRef) => {
        const { __scopeToast, ...descriptionProps } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...descriptionProps, ref: forwardedRef });
      }
    );
    ToastDescription$1.displayName = DESCRIPTION_NAME;
    var ACTION_NAME = "ToastAction";
    var ToastAction$1 = reactExports.forwardRef(
      (props, forwardedRef) => {
        const { altText, ...actionProps } = props;
        if (!altText.trim()) {
          console.error(
            `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
          );
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose$1, { ...actionProps, ref: forwardedRef }) });
      }
    );
    ToastAction$1.displayName = ACTION_NAME;
    var CLOSE_NAME = "ToastClose";
    var ToastClose$1 = reactExports.forwardRef(
      (props, forwardedRef) => {
        const { __scopeToast, ...closeProps } = props;
        const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            ...closeProps,
            ref: forwardedRef,
            onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
          }
        ) });
      }
    );
    ToastClose$1.displayName = CLOSE_NAME;
    var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeToast, altText, ...announceExcludeProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-toast-announce-exclude": "",
          "data-radix-toast-announce-alt": altText || void 0,
          ...announceExcludeProps,
          ref: forwardedRef
        }
      );
    });
    function getAnnounceTextContent(container) {
      const textContent = [];
      const childNodes = Array.from(container.childNodes);
      childNodes.forEach((node) => {
        if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
        if (isHTMLElement(node)) {
          const isHidden = node.ariaHidden || node.hidden || node.style.display === "none";
          const isExcluded = node.dataset.radixToastAnnounceExclude === "";
          if (!isHidden) {
            if (isExcluded) {
              const altText = node.dataset.radixToastAnnounceAlt;
              if (altText) textContent.push(altText);
            } else {
              textContent.push(...getAnnounceTextContent(node));
            }
          }
        }
      });
      return textContent;
    }
    function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
      const currentTarget = detail.originalEvent.currentTarget;
      const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
      if (handler) currentTarget.addEventListener(name, handler, { once: true });
      if (discrete) {
        dispatchDiscreteCustomEvent(currentTarget, event);
      } else {
        currentTarget.dispatchEvent(event);
      }
    }
    var isDeltaInDirection = (delta, direction, threshold = 0) => {
      const deltaX = Math.abs(delta.x);
      const deltaY = Math.abs(delta.y);
      const isDeltaX = deltaX > deltaY;
      if (direction === "left" || direction === "right") {
        return isDeltaX && deltaX > threshold;
      } else {
        return !isDeltaX && deltaY > threshold;
      }
    };
    function useNextFrame(callback = () => {
    }) {
      const fn = useCallbackRef(callback);
      useLayoutEffect2(() => {
        let raf1 = 0;
        let raf2 = 0;
        raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
        return () => {
          window.cancelAnimationFrame(raf1);
          window.cancelAnimationFrame(raf2);
        };
      }, [fn]);
    }
    function isHTMLElement(node) {
      return node.nodeType === node.ELEMENT_NODE;
    }
    function getTabbableCandidates(container) {
      const nodes = [];
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node) => {
          const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
          if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
          return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      });
      while (walker.nextNode()) nodes.push(walker.currentNode);
      return nodes;
    }
    function focusFirst(candidates) {
      const previouslyFocusedElement = document.activeElement;
      return candidates.some((candidate) => {
        if (candidate === previouslyFocusedElement) return true;
        candidate.focus();
        return document.activeElement !== previouslyFocusedElement;
      });
    }
    var Provider = ToastProvider$1;
    var Viewport = ToastViewport$1;
    var Root2 = Toast$1;
    var Title = ToastTitle$1;
    var Description = ToastDescription$1;
    var Action = ToastAction$1;
    var Close = ToastClose$1;
    const ToastProvider = Provider;
    const ToastViewport = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Viewport,
      {
        ref: ref2,
        className: cn(
          "fixed top-0 z-100 flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
          className
        ),
        ...props
      }
    ));
    ToastViewport.displayName = Viewport.displayName;
    const toastVariants = cva(
      "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-(--radix-toast-swipe-end-x) data-[swipe=move]:translate-x-(--radix-toast-swipe-move-x) data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
      {
        variants: {
          variant: {
            default: "border bg-background text-foreground",
            destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
          }
        },
        defaultVariants: {
          variant: "default"
        }
      }
    );
    const Toast = reactExports.forwardRef(({ className, variant, ...props }, ref2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root2,
        {
          ref: ref2,
          className: cn(toastVariants({ variant }), className),
          ...props
        }
      );
    });
    Toast.displayName = Root2.displayName;
    const ToastAction = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Action,
      {
        ref: ref2,
        className: cn(
          "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 hover:group-[.destructive]:border-destructive/30 hover:group-[.destructive]:bg-destructive hover:group-[.destructive]:text-destructive-foreground focus:group-[.destructive]:ring-destructive",
          className
        ),
        ...props
      }
    ));
    ToastAction.displayName = Action.displayName;
    const ToastClose = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Close,
      {
        ref: ref2,
        className: cn(
          "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-hidden focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 hover:group-[.destructive]:text-red-50 focus:group-[.destructive]:ring-red-400 focus:group-[.destructive]:ring-offset-red-600",
          className
        ),
        "toast-close": "",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-4 w-4" })
      }
    ));
    ToastClose.displayName = Close.displayName;
    const ToastTitle = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Title,
      {
        ref: ref2,
        className: cn("text-sm font-semibold", className),
        ...props
      }
    ));
    ToastTitle.displayName = Title.displayName;
    const ToastDescription = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Description,
      {
        ref: ref2,
        className: cn("text-sm opacity-90", className),
        ...props
      }
    ));
    ToastDescription.displayName = Description.displayName;
    const TOAST_LIMIT = 1;
    const TOAST_REMOVE_DELAY = 1e6;
    let count = 0;
    function genId() {
      count = (count + 1) % Number.MAX_VALUE;
      return count.toString();
    }
    const toastTimeouts = /* @__PURE__ */ new Map();
    const addToRemoveQueue = (toastId) => {
      if (toastTimeouts.has(toastId)) {
        return;
      }
      const timeout = setTimeout(() => {
        toastTimeouts.delete(toastId);
        dispatch({
          type: "REMOVE_TOAST",
          toastId
        });
      }, TOAST_REMOVE_DELAY);
      toastTimeouts.set(toastId, timeout);
    };
    const reducer = (state, action) => {
      switch (action.type) {
        case "ADD_TOAST":
          return {
            ...state,
            toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
          };
        case "UPDATE_TOAST":
          return {
            ...state,
            toasts: state.toasts.map(
              (t) => t.id === action.toast.id ? { ...t, ...action.toast } : t
            )
          };
        case "DISMISS_TOAST": {
          const { toastId } = action;
          if (toastId) {
            addToRemoveQueue(toastId);
          } else {
            state.toasts.forEach((toast2) => {
              addToRemoveQueue(toast2.id);
            });
          }
          return {
            ...state,
            toasts: state.toasts.map(
              (t) => t.id === toastId || toastId === void 0 ? {
                ...t,
                open: false
              } : t
            )
          };
        }
        case "REMOVE_TOAST":
          if (action.toastId === void 0) {
            return {
              ...state,
              toasts: []
            };
          }
          return {
            ...state,
            toasts: state.toasts.filter((t) => t.id !== action.toastId)
          };
      }
    };
    const listeners = [];
    let memoryState = { toasts: [] };
    function dispatch(action) {
      memoryState = reducer(memoryState, action);
      listeners.forEach((listener) => {
        listener(memoryState);
      });
    }
    function toast({ ...props }) {
      const id2 = genId();
      const update = (props2) => dispatch({
        type: "UPDATE_TOAST",
        toast: { ...props2, id: id2 }
      });
      const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id2 });
      dispatch({
        type: "ADD_TOAST",
        toast: {
          ...props,
          id: id2,
          open: true,
          onOpenChange: (open) => {
            if (!open) dismiss();
          }
        }
      });
      return {
        id: id2,
        dismiss,
        update
      };
    }
    function useToast() {
      const [state, setState] = reactExports.useState(memoryState);
      reactExports.useEffect(() => {
        listeners.push(setState);
        return () => {
          const index2 = listeners.indexOf(setState);
          if (index2 > -1) {
            listeners.splice(index2, 1);
          }
        };
      }, [state]);
      return {
        ...state,
        toast,
        dismiss: (toastId) => dispatch({ type: "DISMISS_TOAST", toastId })
      };
    }
    function Toaster() {
      const { toasts } = useToast();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastProvider, { children: [
        toasts.map(function({ id: id2, title, description, action, ...props }) {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Toast, { ...props, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-1", children: [
              title && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: title }),
              description && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: description })
            ] }),
            action,
            /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, {})
          ] }, id2);
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, {})
      ] });
    }
    function SubmittableInput({
      onSubmit,
      label,
      placeholder,
      disabled
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "form",
        {
          className: "flex flex-row items-center gap-3",
          onSubmit: (e) => {
            e.preventDefault();
            const textEl = e.currentTarget.elements.namedItem(
              "text"
            );
            onSubmit(textEl.value);
            textEl.value = "";
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                className: "-ml-3 -my-2 grow flex-3 text-base",
                name: "text",
                placeholder,
                autoComplete: "off",
                disabled
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { asChild: true, type: "submit", className: "shrink flex-1 cursor-pointer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { type: "submit", value: label, disabled }) })
          ]
        }
      );
    }
    function TitleAndLogo({ name }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 justify-center mt-5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "reskif-logo.png", className: "h-5" }),
          " ",
          name
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {})
      ] });
    }
    const initialState = {
      theme: "system",
      setTheme: () => null
    };
    const ThemeProviderContext = reactExports.createContext(initialState);
    function ThemeProvider({
      children,
      defaultTheme = "system",
      storageKey = "vite-ui-theme",
      ...props
    }) {
      const [theme, setTheme] = reactExports.useState(
        () => localStorage.getItem(storageKey) || defaultTheme
      );
      reactExports.useEffect(() => {
        const root = window.document.documentElement;
        root.classList.remove("light", "dark");
        if (theme === "system") {
          const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
          root.classList.add(systemTheme);
          return;
        }
        root.classList.add(theme);
      }, [theme]);
      const value = {
        theme,
        setTheme: (theme2) => {
          localStorage.setItem(storageKey, theme2);
          setTheme(theme2);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProviderContext.Provider, { ...props, value, children });
    }
    const Table = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "table",
      {
        ref: ref2,
        className: cn("w-full caption-bottom text-sm", className),
        ...props
      }
    ) }));
    Table.displayName = "Table";
    const TableHeader = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { ref: ref2, className: cn("[&_tr]:border-b", className), ...props }));
    TableHeader.displayName = "TableHeader";
    const TableBody = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tbody",
      {
        ref: ref2,
        className: cn("[&_tr:last-child]:border-0", className),
        ...props
      }
    ));
    TableBody.displayName = "TableBody";
    const TableFooter = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tfoot",
      {
        ref: ref2,
        className: cn("bg-primary font-medium text-primary-foreground", className),
        ...props
      }
    ));
    TableFooter.displayName = "TableFooter";
    const TableRow = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tr",
      {
        ref: ref2,
        className: cn(
          "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
          className
        ),
        ...props
      }
    ));
    TableRow.displayName = "TableRow";
    const TableHead = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "th",
      {
        ref: ref2,
        className: cn(
          "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
          className
        ),
        ...props
      }
    ));
    TableHead.displayName = "TableHead";
    const TableCell = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "td",
      {
        ref: ref2,
        className: cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className),
        ...props
      }
    ));
    TableCell.displayName = "TableCell";
    const TableCaption = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "caption",
      {
        ref: ref2,
        className: cn("mt-4 text-sm text-muted-foreground", className),
        ...props
      }
    ));
    TableCaption.displayName = "TableCaption";
    function NewProjectForm() {
      const { me } = useAccount(TodoAccount, {
        resolve: { root: { projects: { $each: { $onError: null } } } }
      });
      const navigate = useNavigate();
      const createProject = reactExports.useCallback(
        (title) => {
          var _a, _b;
          if (!me || !title) return;
          const projectGroup = Group.create();
          const project = TodoProject.create(
            {
              title,
              tasks: coExport_exports.list(Task).create([], { owner: projectGroup })
            },
            { owner: projectGroup }
          );
          (_b = (_a = me.root) == null ? void 0 : _a.projects) == null ? void 0 : _b.push(project);
          navigate("/project/" + project.id);
        },
        [me, navigate]
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SubmittableInput,
        {
          onSubmit: createProject,
          label: "Create a new list",
          placeholder: "Name of the list"
        }
      );
    }
    var uniqolor$2 = { exports: {} };
    /**
    * Generate unique and beautiful colors from any texts or numbers
     * @version v1.1.1
     * @link https://github.com/dastoori/uniqolor#README
     * @author Rasool Dastoori
     * @license MIT License, http://www.opensource.org/licenses/MIT
     */
    var uniqolor$1 = uniqolor$2.exports;
    var hasRequiredUniqolor;
    function requireUniqolor() {
      if (hasRequiredUniqolor) return uniqolor$2.exports;
      hasRequiredUniqolor = 1;
      (function(module2, exports2) {
        (function(global2, factory) {
          module2.exports = factory();
        })(uniqolor$1, function() {
          function _iterableToArrayLimit(r2, l) {
            var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
            if (null != t) {
              var e, n, i, u, a = [], f = true, o = false;
              try {
                if (i = (t = t.call(r2)).next, 0 === l) ;
                else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
              } catch (r3) {
                o = true, n = r3;
              } finally {
                try {
                  if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
                } finally {
                  if (o) throw n;
                }
              }
              return a;
            }
          }
          function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
          }
          function _toConsumableArray(arr) {
            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
          }
          function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) return _arrayLikeToArray(arr);
          }
          function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
          }
          function _iterableToArray(iter) {
            if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
          }
          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }
          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
            return arr2;
          }
          function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var SATURATION_BOUND = [0, 100];
          var LIGHTNESS_BOUND = [0, 100];
          var pad2 = function pad22(str) {
            return "".concat(str.length === 1 ? "0" : "").concat(str);
          };
          var clamp = function clamp2(num, min, max) {
            return Math.max(Math.min(num, max), min);
          };
          var random = function random2(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
          };
          var randomExclude = function randomExclude2(min, max, exclude) {
            var r2 = random(min, max);
            for (var i = 0; i < (exclude === null || exclude === void 0 ? void 0 : exclude.length); i++) {
              var value = exclude[i];
              if ((value === null || value === void 0 ? void 0 : value.length) === 2 && r2 >= value[0] && r2 <= value[1]) {
                return randomExclude2(min, max, exclude);
              }
            }
            return r2;
          };
          var hashCode = function hashCode2(str) {
            var len = str.length;
            var hash = 0;
            for (var i = 0; i < len; i++) {
              hash = (hash << 5) - hash + str.charCodeAt(i);
              hash &= hash;
            }
            return hash;
          };
          var boundHashCode = function boundHashCode2(num, range) {
            if (typeof range === "number") {
              return range;
            }
            return num % Math.abs(range[1] - range[0]) + range[0];
          };
          var sanitizeRange = function sanitizeRange2(range, bound) {
            if (typeof range === "number") {
              return clamp.apply(void 0, [Math.abs(range)].concat(_toConsumableArray(bound)));
            }
            if (range.length === 1 || range[0] === range[1]) {
              return clamp.apply(void 0, [Math.abs(range[0])].concat(_toConsumableArray(bound)));
            }
            return [Math.abs(clamp.apply(void 0, [range[0]].concat(_toConsumableArray(bound)))), clamp.apply(void 0, [Math.abs(range[1])].concat(_toConsumableArray(bound)))];
          };
          var hueToRgb = function hueToRgb2(p, q, t) {
            if (t < 0) {
              t += 1;
            } else if (t > 1) {
              t -= 1;
            }
            if (t < 1 / 6) {
              return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
              return q;
            }
            if (t < 2 / 3) {
              return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
          };
          var hslToRgb = function hslToRgb2(h, s, l) {
            var r2;
            var g;
            var b;
            h /= 360;
            s /= 100;
            l /= 100;
            if (s === 0) {
              r2 = g = b = l;
            } else {
              var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              var p = 2 * l - q;
              r2 = hueToRgb(p, q, h + 1 / 3);
              g = hueToRgb(p, q, h);
              b = hueToRgb(p, q, h - 1 / 3);
            }
            return [Math.round(r2 * 255), Math.round(g * 255), Math.round(b * 255)];
          };
          var rgbIsLight = function rgbIsLight2(r2, g, b, differencePoint) {
            return (r2 * 299 + g * 587 + b * 114) / 1e3 >= differencePoint;
          };
          var hslToString = function hslToString2(h, s, l) {
            return "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)");
          };
          var rgbFormat = function rgbFormat2(r2, g, b, format) {
            switch (format) {
              case "rgb":
                return "rgb(".concat(r2, ", ").concat(g, ", ").concat(b, ")");
              case "hex":
              default:
                return "#".concat(pad2(r2.toString(16))).concat(pad2(g.toString(16))).concat(pad2(b.toString(16)));
            }
          };
          var uniqolor2 = function uniqolor3(value) {
            var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$format = _ref.format, format = _ref$format === void 0 ? "hex" : _ref$format, _ref$saturation = _ref.saturation, saturation = _ref$saturation === void 0 ? [50, 55] : _ref$saturation, _ref$lightness = _ref.lightness, lightness = _ref$lightness === void 0 ? [50, 60] : _ref$lightness, _ref$differencePoint = _ref.differencePoint, differencePoint = _ref$differencePoint === void 0 ? 130 : _ref$differencePoint;
            var hash = Math.abs(hashCode(String(value)));
            var h = boundHashCode(hash, [0, 360]);
            var s = boundHashCode(hash, sanitizeRange(saturation, SATURATION_BOUND));
            var l = boundHashCode(hash, sanitizeRange(lightness, LIGHTNESS_BOUND));
            var _hslToRgb = hslToRgb(h, s, l), _hslToRgb2 = _slicedToArray(_hslToRgb, 3), r2 = _hslToRgb2[0], g = _hslToRgb2[1], b = _hslToRgb2[2];
            return {
              color: format === "hsl" ? hslToString(h, s, l) : rgbFormat(r2, g, b, format),
              isLight: rgbIsLight(r2, g, b, differencePoint)
            };
          };
          uniqolor2.random = function() {
            var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$format = _ref2.format, format = _ref2$format === void 0 ? "hex" : _ref2$format, _ref2$saturation = _ref2.saturation, saturation = _ref2$saturation === void 0 ? [50, 55] : _ref2$saturation, _ref2$lightness = _ref2.lightness, lightness = _ref2$lightness === void 0 ? [50, 60] : _ref2$lightness, _ref2$differencePoint = _ref2.differencePoint, differencePoint = _ref2$differencePoint === void 0 ? 130 : _ref2$differencePoint, excludeHue = _ref2.excludeHue;
            saturation = sanitizeRange(saturation, SATURATION_BOUND);
            lightness = sanitizeRange(lightness, LIGHTNESS_BOUND);
            var h = excludeHue ? randomExclude(0, 359, excludeHue) : random(0, 359);
            var s = typeof saturation === "number" ? saturation : random.apply(void 0, _toConsumableArray(saturation));
            var l = typeof lightness === "number" ? lightness : random.apply(void 0, _toConsumableArray(lightness));
            var _hslToRgb3 = hslToRgb(h, s, l), _hslToRgb4 = _slicedToArray(_hslToRgb3, 3), r2 = _hslToRgb4[0], g = _hslToRgb4[1], b = _hslToRgb4[2];
            return {
              color: format === "hsl" ? hslToString(h, s, l) : rgbFormat(r2, g, b, format),
              isLight: rgbIsLight(r2, g, b, differencePoint)
            };
          };
          return uniqolor2;
        });
      })(uniqolor$2);
      return uniqolor$2.exports;
    }
    var uniqolorExports = requireUniqolor();
    const uniqolor = /* @__PURE__ */ getDefaultExportFromCjs(uniqolorExports);
    var browser = {};
    var canPromise;
    var hasRequiredCanPromise;
    function requireCanPromise() {
      if (hasRequiredCanPromise) return canPromise;
      hasRequiredCanPromise = 1;
      canPromise = function() {
        return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
      };
      return canPromise;
    }
    var qrcode = {};
    var utils$1 = {};
    var hasRequiredUtils$1;
    function requireUtils$1() {
      if (hasRequiredUtils$1) return utils$1;
      hasRequiredUtils$1 = 1;
      let toSJISFunction;
      const CODEWORDS_COUNT = [
        0,
        // Not used
        26,
        44,
        70,
        100,
        134,
        172,
        196,
        242,
        292,
        346,
        404,
        466,
        532,
        581,
        655,
        733,
        815,
        901,
        991,
        1085,
        1156,
        1258,
        1364,
        1474,
        1588,
        1706,
        1828,
        1921,
        2051,
        2185,
        2323,
        2465,
        2611,
        2761,
        2876,
        3034,
        3196,
        3362,
        3532,
        3706
      ];
      utils$1.getSymbolSize = function getSymbolSize(version2) {
        if (!version2) throw new Error('"version" cannot be null or undefined');
        if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
        return version2 * 4 + 17;
      };
      utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
        return CODEWORDS_COUNT[version2];
      };
      utils$1.getBCHDigit = function(data2) {
        let digit = 0;
        while (data2 !== 0) {
          digit++;
          data2 >>>= 1;
        }
        return digit;
      };
      utils$1.setToSJISFunction = function setToSJISFunction(f) {
        if (typeof f !== "function") {
          throw new Error('"toSJISFunc" is not a valid function.');
        }
        toSJISFunction = f;
      };
      utils$1.isKanjiModeEnabled = function() {
        return typeof toSJISFunction !== "undefined";
      };
      utils$1.toSJIS = function toSJIS(kanji) {
        return toSJISFunction(kanji);
      };
      return utils$1;
    }
    var errorCorrectionLevel = {};
    var hasRequiredErrorCorrectionLevel;
    function requireErrorCorrectionLevel() {
      if (hasRequiredErrorCorrectionLevel) return errorCorrectionLevel;
      hasRequiredErrorCorrectionLevel = 1;
      (function(exports2) {
        exports2.L = { bit: 1 };
        exports2.M = { bit: 0 };
        exports2.Q = { bit: 3 };
        exports2.H = { bit: 2 };
        function fromString(string2) {
          if (typeof string2 !== "string") {
            throw new Error("Param is not a string");
          }
          const lcStr = string2.toLowerCase();
          switch (lcStr) {
            case "l":
            case "low":
              return exports2.L;
            case "m":
            case "medium":
              return exports2.M;
            case "q":
            case "quartile":
              return exports2.Q;
            case "h":
            case "high":
              return exports2.H;
            default:
              throw new Error("Unknown EC Level: " + string2);
          }
        }
        exports2.isValid = function isValid(level) {
          return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
        };
        exports2.from = function from(value, defaultValue) {
          if (exports2.isValid(value)) {
            return value;
          }
          try {
            return fromString(value);
          } catch (e) {
            return defaultValue;
          }
        };
      })(errorCorrectionLevel);
      return errorCorrectionLevel;
    }
    var bitBuffer;
    var hasRequiredBitBuffer;
    function requireBitBuffer() {
      if (hasRequiredBitBuffer) return bitBuffer;
      hasRequiredBitBuffer = 1;
      function BitBuffer() {
        this.buffer = [];
        this.length = 0;
      }
      BitBuffer.prototype = {
        get: function(index2) {
          const bufIndex = Math.floor(index2 / 8);
          return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
        },
        put: function(num, length) {
          for (let i = 0; i < length; i++) {
            this.putBit((num >>> length - i - 1 & 1) === 1);
          }
        },
        getLengthInBits: function() {
          return this.length;
        },
        putBit: function(bit) {
          const bufIndex = Math.floor(this.length / 8);
          if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
          }
          if (bit) {
            this.buffer[bufIndex] |= 128 >>> this.length % 8;
          }
          this.length++;
        }
      };
      bitBuffer = BitBuffer;
      return bitBuffer;
    }
    var bitMatrix;
    var hasRequiredBitMatrix;
    function requireBitMatrix() {
      if (hasRequiredBitMatrix) return bitMatrix;
      hasRequiredBitMatrix = 1;
      function BitMatrix(size) {
        if (!size || size < 1) {
          throw new Error("BitMatrix size must be defined and greater than 0");
        }
        this.size = size;
        this.data = new Uint8Array(size * size);
        this.reservedBit = new Uint8Array(size * size);
      }
      BitMatrix.prototype.set = function(row, col, value, reserved) {
        const index2 = row * this.size + col;
        this.data[index2] = value;
        if (reserved) this.reservedBit[index2] = true;
      };
      BitMatrix.prototype.get = function(row, col) {
        return this.data[row * this.size + col];
      };
      BitMatrix.prototype.xor = function(row, col, value) {
        this.data[row * this.size + col] ^= value;
      };
      BitMatrix.prototype.isReserved = function(row, col) {
        return this.reservedBit[row * this.size + col];
      };
      bitMatrix = BitMatrix;
      return bitMatrix;
    }
    var alignmentPattern = {};
    var hasRequiredAlignmentPattern;
    function requireAlignmentPattern() {
      if (hasRequiredAlignmentPattern) return alignmentPattern;
      hasRequiredAlignmentPattern = 1;
      (function(exports2) {
        const getSymbolSize = requireUtils$1().getSymbolSize;
        exports2.getRowColCoords = function getRowColCoords(version2) {
          if (version2 === 1) return [];
          const posCount = Math.floor(version2 / 7) + 2;
          const size = getSymbolSize(version2);
          const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
          const positions = [size - 7];
          for (let i = 1; i < posCount - 1; i++) {
            positions[i] = positions[i - 1] - intervals;
          }
          positions.push(6);
          return positions.reverse();
        };
        exports2.getPositions = function getPositions(version2) {
          const coords = [];
          const pos = exports2.getRowColCoords(version2);
          const posLength = pos.length;
          for (let i = 0; i < posLength; i++) {
            for (let j = 0; j < posLength; j++) {
              if (i === 0 && j === 0 || // top-left
              i === 0 && j === posLength - 1 || // bottom-left
              i === posLength - 1 && j === 0) {
                continue;
              }
              coords.push([pos[i], pos[j]]);
            }
          }
          return coords;
        };
      })(alignmentPattern);
      return alignmentPattern;
    }
    var finderPattern = {};
    var hasRequiredFinderPattern;
    function requireFinderPattern() {
      if (hasRequiredFinderPattern) return finderPattern;
      hasRequiredFinderPattern = 1;
      const getSymbolSize = requireUtils$1().getSymbolSize;
      const FINDER_PATTERN_SIZE = 7;
      finderPattern.getPositions = function getPositions(version2) {
        const size = getSymbolSize(version2);
        return [
          // top-left
          [0, 0],
          // top-right
          [size - FINDER_PATTERN_SIZE, 0],
          // bottom-left
          [0, size - FINDER_PATTERN_SIZE]
        ];
      };
      return finderPattern;
    }
    var maskPattern = {};
    var hasRequiredMaskPattern;
    function requireMaskPattern() {
      if (hasRequiredMaskPattern) return maskPattern;
      hasRequiredMaskPattern = 1;
      (function(exports2) {
        exports2.Patterns = {
          PATTERN000: 0,
          PATTERN001: 1,
          PATTERN010: 2,
          PATTERN011: 3,
          PATTERN100: 4,
          PATTERN101: 5,
          PATTERN110: 6,
          PATTERN111: 7
        };
        const PenaltyScores = {
          N1: 3,
          N2: 3,
          N3: 40,
          N4: 10
        };
        exports2.isValid = function isValid(mask) {
          return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
        };
        exports2.from = function from(value) {
          return exports2.isValid(value) ? parseInt(value, 10) : void 0;
        };
        exports2.getPenaltyN1 = function getPenaltyN1(data2) {
          const size = data2.size;
          let points = 0;
          let sameCountCol = 0;
          let sameCountRow = 0;
          let lastCol = null;
          let lastRow = null;
          for (let row = 0; row < size; row++) {
            sameCountCol = sameCountRow = 0;
            lastCol = lastRow = null;
            for (let col = 0; col < size; col++) {
              let module2 = data2.get(row, col);
              if (module2 === lastCol) {
                sameCountCol++;
              } else {
                if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
                lastCol = module2;
                sameCountCol = 1;
              }
              module2 = data2.get(col, row);
              if (module2 === lastRow) {
                sameCountRow++;
              } else {
                if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
                lastRow = module2;
                sameCountRow = 1;
              }
            }
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
          }
          return points;
        };
        exports2.getPenaltyN2 = function getPenaltyN2(data2) {
          const size = data2.size;
          let points = 0;
          for (let row = 0; row < size - 1; row++) {
            for (let col = 0; col < size - 1; col++) {
              const last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
              if (last === 4 || last === 0) points++;
            }
          }
          return points * PenaltyScores.N2;
        };
        exports2.getPenaltyN3 = function getPenaltyN3(data2) {
          const size = data2.size;
          let points = 0;
          let bitsCol = 0;
          let bitsRow = 0;
          for (let row = 0; row < size; row++) {
            bitsCol = bitsRow = 0;
            for (let col = 0; col < size; col++) {
              bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
              if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
              bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
              if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
            }
          }
          return points * PenaltyScores.N3;
        };
        exports2.getPenaltyN4 = function getPenaltyN4(data2) {
          let darkCount = 0;
          const modulesCount = data2.data.length;
          for (let i = 0; i < modulesCount; i++) darkCount += data2.data[i];
          const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
          return k * PenaltyScores.N4;
        };
        function getMaskAt(maskPattern2, i, j) {
          switch (maskPattern2) {
            case exports2.Patterns.PATTERN000:
              return (i + j) % 2 === 0;
            case exports2.Patterns.PATTERN001:
              return i % 2 === 0;
            case exports2.Patterns.PATTERN010:
              return j % 3 === 0;
            case exports2.Patterns.PATTERN011:
              return (i + j) % 3 === 0;
            case exports2.Patterns.PATTERN100:
              return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
            case exports2.Patterns.PATTERN101:
              return i * j % 2 + i * j % 3 === 0;
            case exports2.Patterns.PATTERN110:
              return (i * j % 2 + i * j % 3) % 2 === 0;
            case exports2.Patterns.PATTERN111:
              return (i * j % 3 + (i + j) % 2) % 2 === 0;
            default:
              throw new Error("bad maskPattern:" + maskPattern2);
          }
        }
        exports2.applyMask = function applyMask(pattern, data2) {
          const size = data2.size;
          for (let col = 0; col < size; col++) {
            for (let row = 0; row < size; row++) {
              if (data2.isReserved(row, col)) continue;
              data2.xor(row, col, getMaskAt(pattern, row, col));
            }
          }
        };
        exports2.getBestMask = function getBestMask(data2, setupFormatFunc) {
          const numPatterns = Object.keys(exports2.Patterns).length;
          let bestPattern = 0;
          let lowerPenalty = Infinity;
          for (let p = 0; p < numPatterns; p++) {
            setupFormatFunc(p);
            exports2.applyMask(p, data2);
            const penalty = exports2.getPenaltyN1(data2) + exports2.getPenaltyN2(data2) + exports2.getPenaltyN3(data2) + exports2.getPenaltyN4(data2);
            exports2.applyMask(p, data2);
            if (penalty < lowerPenalty) {
              lowerPenalty = penalty;
              bestPattern = p;
            }
          }
          return bestPattern;
        };
      })(maskPattern);
      return maskPattern;
    }
    var errorCorrectionCode = {};
    var hasRequiredErrorCorrectionCode;
    function requireErrorCorrectionCode() {
      if (hasRequiredErrorCorrectionCode) return errorCorrectionCode;
      hasRequiredErrorCorrectionCode = 1;
      const ECLevel = requireErrorCorrectionLevel();
      const EC_BLOCKS_TABLE = [
        // L  M  Q  H
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        1,
        2,
        2,
        4,
        1,
        2,
        4,
        4,
        2,
        4,
        4,
        4,
        2,
        4,
        6,
        5,
        2,
        4,
        6,
        6,
        2,
        5,
        8,
        8,
        4,
        5,
        8,
        8,
        4,
        5,
        8,
        11,
        4,
        8,
        10,
        11,
        4,
        9,
        12,
        16,
        4,
        9,
        16,
        16,
        6,
        10,
        12,
        18,
        6,
        10,
        17,
        16,
        6,
        11,
        16,
        19,
        6,
        13,
        18,
        21,
        7,
        14,
        21,
        25,
        8,
        16,
        20,
        25,
        8,
        17,
        23,
        25,
        9,
        17,
        23,
        34,
        9,
        18,
        25,
        30,
        10,
        20,
        27,
        32,
        12,
        21,
        29,
        35,
        12,
        23,
        34,
        37,
        12,
        25,
        34,
        40,
        13,
        26,
        35,
        42,
        14,
        28,
        38,
        45,
        15,
        29,
        40,
        48,
        16,
        31,
        43,
        51,
        17,
        33,
        45,
        54,
        18,
        35,
        48,
        57,
        19,
        37,
        51,
        60,
        19,
        38,
        53,
        63,
        20,
        40,
        56,
        66,
        21,
        43,
        59,
        70,
        22,
        45,
        62,
        74,
        24,
        47,
        65,
        77,
        25,
        49,
        68,
        81
      ];
      const EC_CODEWORDS_TABLE = [
        // L  M  Q  H
        7,
        10,
        13,
        17,
        10,
        16,
        22,
        28,
        15,
        26,
        36,
        44,
        20,
        36,
        52,
        64,
        26,
        48,
        72,
        88,
        36,
        64,
        96,
        112,
        40,
        72,
        108,
        130,
        48,
        88,
        132,
        156,
        60,
        110,
        160,
        192,
        72,
        130,
        192,
        224,
        80,
        150,
        224,
        264,
        96,
        176,
        260,
        308,
        104,
        198,
        288,
        352,
        120,
        216,
        320,
        384,
        132,
        240,
        360,
        432,
        144,
        280,
        408,
        480,
        168,
        308,
        448,
        532,
        180,
        338,
        504,
        588,
        196,
        364,
        546,
        650,
        224,
        416,
        600,
        700,
        224,
        442,
        644,
        750,
        252,
        476,
        690,
        816,
        270,
        504,
        750,
        900,
        300,
        560,
        810,
        960,
        312,
        588,
        870,
        1050,
        336,
        644,
        952,
        1110,
        360,
        700,
        1020,
        1200,
        390,
        728,
        1050,
        1260,
        420,
        784,
        1140,
        1350,
        450,
        812,
        1200,
        1440,
        480,
        868,
        1290,
        1530,
        510,
        924,
        1350,
        1620,
        540,
        980,
        1440,
        1710,
        570,
        1036,
        1530,
        1800,
        570,
        1064,
        1590,
        1890,
        600,
        1120,
        1680,
        1980,
        630,
        1204,
        1770,
        2100,
        660,
        1260,
        1860,
        2220,
        720,
        1316,
        1950,
        2310,
        750,
        1372,
        2040,
        2430
      ];
      errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
        switch (errorCorrectionLevel2) {
          case ECLevel.L:
            return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
      errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
        switch (errorCorrectionLevel2) {
          case ECLevel.L:
            return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
      return errorCorrectionCode;
    }
    var polynomial = {};
    var galoisField = {};
    var hasRequiredGaloisField;
    function requireGaloisField() {
      if (hasRequiredGaloisField) return galoisField;
      hasRequiredGaloisField = 1;
      const EXP_TABLE = new Uint8Array(512);
      const LOG_TABLE = new Uint8Array(256);
      (function initTables() {
        let x = 1;
        for (let i = 0; i < 255; i++) {
          EXP_TABLE[i] = x;
          LOG_TABLE[x] = i;
          x <<= 1;
          if (x & 256) {
            x ^= 285;
          }
        }
        for (let i = 255; i < 512; i++) {
          EXP_TABLE[i] = EXP_TABLE[i - 255];
        }
      })();
      galoisField.log = function log(n) {
        if (n < 1) throw new Error("log(" + n + ")");
        return LOG_TABLE[n];
      };
      galoisField.exp = function exp(n) {
        return EXP_TABLE[n];
      };
      galoisField.mul = function mul(x, y) {
        if (x === 0 || y === 0) return 0;
        return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
      };
      return galoisField;
    }
    var hasRequiredPolynomial;
    function requirePolynomial() {
      if (hasRequiredPolynomial) return polynomial;
      hasRequiredPolynomial = 1;
      (function(exports2) {
        const GF = requireGaloisField();
        exports2.mul = function mul(p1, p2) {
          const coeff = new Uint8Array(p1.length + p2.length - 1);
          for (let i = 0; i < p1.length; i++) {
            for (let j = 0; j < p2.length; j++) {
              coeff[i + j] ^= GF.mul(p1[i], p2[j]);
            }
          }
          return coeff;
        };
        exports2.mod = function mod2(divident, divisor) {
          let result = new Uint8Array(divident);
          while (result.length - divisor.length >= 0) {
            const coeff = result[0];
            for (let i = 0; i < divisor.length; i++) {
              result[i] ^= GF.mul(divisor[i], coeff);
            }
            let offset = 0;
            while (offset < result.length && result[offset] === 0) offset++;
            result = result.slice(offset);
          }
          return result;
        };
        exports2.generateECPolynomial = function generateECPolynomial(degree) {
          let poly = new Uint8Array([1]);
          for (let i = 0; i < degree; i++) {
            poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i)]));
          }
          return poly;
        };
      })(polynomial);
      return polynomial;
    }
    var reedSolomonEncoder;
    var hasRequiredReedSolomonEncoder;
    function requireReedSolomonEncoder() {
      if (hasRequiredReedSolomonEncoder) return reedSolomonEncoder;
      hasRequiredReedSolomonEncoder = 1;
      const Polynomial = requirePolynomial();
      function ReedSolomonEncoder(degree) {
        this.genPoly = void 0;
        this.degree = degree;
        if (this.degree) this.initialize(this.degree);
      }
      ReedSolomonEncoder.prototype.initialize = function initialize2(degree) {
        this.degree = degree;
        this.genPoly = Polynomial.generateECPolynomial(this.degree);
      };
      ReedSolomonEncoder.prototype.encode = function encode(data2) {
        if (!this.genPoly) {
          throw new Error("Encoder not initialized");
        }
        const paddedData = new Uint8Array(data2.length + this.degree);
        paddedData.set(data2);
        const remainder = Polynomial.mod(paddedData, this.genPoly);
        const start = this.degree - remainder.length;
        if (start > 0) {
          const buff = new Uint8Array(this.degree);
          buff.set(remainder, start);
          return buff;
        }
        return remainder;
      };
      reedSolomonEncoder = ReedSolomonEncoder;
      return reedSolomonEncoder;
    }
    var version = {};
    var mode = {};
    var versionCheck = {};
    var hasRequiredVersionCheck;
    function requireVersionCheck() {
      if (hasRequiredVersionCheck) return versionCheck;
      hasRequiredVersionCheck = 1;
      versionCheck.isValid = function isValid(version2) {
        return !isNaN(version2) && version2 >= 1 && version2 <= 40;
      };
      return versionCheck;
    }
    var regex = {};
    var hasRequiredRegex;
    function requireRegex() {
      if (hasRequiredRegex) return regex;
      hasRequiredRegex = 1;
      const numeric = "[0-9]+";
      const alphanumeric = "[A-Z $%*+\\-./:]+";
      let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
      kanji = kanji.replace(/u/g, "\\u");
      const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
      regex.KANJI = new RegExp(kanji, "g");
      regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
      regex.BYTE = new RegExp(byte, "g");
      regex.NUMERIC = new RegExp(numeric, "g");
      regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
      const TEST_KANJI = new RegExp("^" + kanji + "$");
      const TEST_NUMERIC = new RegExp("^" + numeric + "$");
      const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
      regex.testKanji = function testKanji(str) {
        return TEST_KANJI.test(str);
      };
      regex.testNumeric = function testNumeric(str) {
        return TEST_NUMERIC.test(str);
      };
      regex.testAlphanumeric = function testAlphanumeric(str) {
        return TEST_ALPHANUMERIC.test(str);
      };
      return regex;
    }
    var hasRequiredMode;
    function requireMode() {
      if (hasRequiredMode) return mode;
      hasRequiredMode = 1;
      (function(exports2) {
        const VersionCheck = requireVersionCheck();
        const Regex = requireRegex();
        exports2.NUMERIC = {
          id: "Numeric",
          bit: 1 << 0,
          ccBits: [10, 12, 14]
        };
        exports2.ALPHANUMERIC = {
          id: "Alphanumeric",
          bit: 1 << 1,
          ccBits: [9, 11, 13]
        };
        exports2.BYTE = {
          id: "Byte",
          bit: 1 << 2,
          ccBits: [8, 16, 16]
        };
        exports2.KANJI = {
          id: "Kanji",
          bit: 1 << 3,
          ccBits: [8, 10, 12]
        };
        exports2.MIXED = {
          bit: -1
        };
        exports2.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
          if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
          if (!VersionCheck.isValid(version2)) {
            throw new Error("Invalid version: " + version2);
          }
          if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
          else if (version2 < 27) return mode2.ccBits[1];
          return mode2.ccBits[2];
        };
        exports2.getBestModeForData = function getBestModeForData(dataStr) {
          if (Regex.testNumeric(dataStr)) return exports2.NUMERIC;
          else if (Regex.testAlphanumeric(dataStr)) return exports2.ALPHANUMERIC;
          else if (Regex.testKanji(dataStr)) return exports2.KANJI;
          else return exports2.BYTE;
        };
        exports2.toString = function toString(mode2) {
          if (mode2 && mode2.id) return mode2.id;
          throw new Error("Invalid mode");
        };
        exports2.isValid = function isValid(mode2) {
          return mode2 && mode2.bit && mode2.ccBits;
        };
        function fromString(string2) {
          if (typeof string2 !== "string") {
            throw new Error("Param is not a string");
          }
          const lcStr = string2.toLowerCase();
          switch (lcStr) {
            case "numeric":
              return exports2.NUMERIC;
            case "alphanumeric":
              return exports2.ALPHANUMERIC;
            case "kanji":
              return exports2.KANJI;
            case "byte":
              return exports2.BYTE;
            default:
              throw new Error("Unknown mode: " + string2);
          }
        }
        exports2.from = function from(value, defaultValue) {
          if (exports2.isValid(value)) {
            return value;
          }
          try {
            return fromString(value);
          } catch (e) {
            return defaultValue;
          }
        };
      })(mode);
      return mode;
    }
    var hasRequiredVersion;
    function requireVersion() {
      if (hasRequiredVersion) return version;
      hasRequiredVersion = 1;
      (function(exports2) {
        const Utils = requireUtils$1();
        const ECCode = requireErrorCorrectionCode();
        const ECLevel = requireErrorCorrectionLevel();
        const Mode = requireMode();
        const VersionCheck = requireVersionCheck();
        const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
        const G18_BCH = Utils.getBCHDigit(G18);
        function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
          for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
            if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
              return currentVersion;
            }
          }
          return void 0;
        }
        function getReservedBitsCount(mode2, version2) {
          return Mode.getCharCountIndicator(mode2, version2) + 4;
        }
        function getTotalBitsFromDataArray(segments2, version2) {
          let totalBits = 0;
          segments2.forEach(function(data2) {
            const reservedBits = getReservedBitsCount(data2.mode, version2);
            totalBits += reservedBits + data2.getBitsLength();
          });
          return totalBits;
        }
        function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
          for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
            const length = getTotalBitsFromDataArray(segments2, currentVersion);
            if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, Mode.MIXED)) {
              return currentVersion;
            }
          }
          return void 0;
        }
        exports2.from = function from(value, defaultValue) {
          if (VersionCheck.isValid(value)) {
            return parseInt(value, 10);
          }
          return defaultValue;
        };
        exports2.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
          if (!VersionCheck.isValid(version2)) {
            throw new Error("Invalid QR Code version");
          }
          if (typeof mode2 === "undefined") mode2 = Mode.BYTE;
          const totalCodewords = Utils.getSymbolTotalCodewords(version2);
          const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
          const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
          if (mode2 === Mode.MIXED) return dataTotalCodewordsBits;
          const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
          switch (mode2) {
            case Mode.NUMERIC:
              return Math.floor(usableBits / 10 * 3);
            case Mode.ALPHANUMERIC:
              return Math.floor(usableBits / 11 * 2);
            case Mode.KANJI:
              return Math.floor(usableBits / 13);
            case Mode.BYTE:
            default:
              return Math.floor(usableBits / 8);
          }
        };
        exports2.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
          let seg;
          const ecl = ECLevel.from(errorCorrectionLevel2, ECLevel.M);
          if (Array.isArray(data2)) {
            if (data2.length > 1) {
              return getBestVersionForMixedData(data2, ecl);
            }
            if (data2.length === 0) {
              return 1;
            }
            seg = data2[0];
          } else {
            seg = data2;
          }
          return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
        };
        exports2.getEncodedBits = function getEncodedBits(version2) {
          if (!VersionCheck.isValid(version2) || version2 < 7) {
            throw new Error("Invalid QR Code version");
          }
          let d = version2 << 12;
          while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
            d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
          }
          return version2 << 12 | d;
        };
      })(version);
      return version;
    }
    var formatInfo = {};
    var hasRequiredFormatInfo;
    function requireFormatInfo() {
      if (hasRequiredFormatInfo) return formatInfo;
      hasRequiredFormatInfo = 1;
      const Utils = requireUtils$1();
      const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
      const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
      const G15_BCH = Utils.getBCHDigit(G15);
      formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
        const data2 = errorCorrectionLevel2.bit << 3 | mask;
        let d = data2 << 10;
        while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
          d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
        }
        return (data2 << 10 | d) ^ G15_MASK;
      };
      return formatInfo;
    }
    var segments = {};
    var numericData;
    var hasRequiredNumericData;
    function requireNumericData() {
      if (hasRequiredNumericData) return numericData;
      hasRequiredNumericData = 1;
      const Mode = requireMode();
      function NumericData(data2) {
        this.mode = Mode.NUMERIC;
        this.data = data2.toString();
      }
      NumericData.getBitsLength = function getBitsLength(length) {
        return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
      };
      NumericData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      NumericData.prototype.getBitsLength = function getBitsLength() {
        return NumericData.getBitsLength(this.data.length);
      };
      NumericData.prototype.write = function write(bitBuffer2) {
        let i, group, value;
        for (i = 0; i + 3 <= this.data.length; i += 3) {
          group = this.data.substr(i, 3);
          value = parseInt(group, 10);
          bitBuffer2.put(value, 10);
        }
        const remainingNum = this.data.length - i;
        if (remainingNum > 0) {
          group = this.data.substr(i);
          value = parseInt(group, 10);
          bitBuffer2.put(value, remainingNum * 3 + 1);
        }
      };
      numericData = NumericData;
      return numericData;
    }
    var alphanumericData;
    var hasRequiredAlphanumericData;
    function requireAlphanumericData() {
      if (hasRequiredAlphanumericData) return alphanumericData;
      hasRequiredAlphanumericData = 1;
      const Mode = requireMode();
      const ALPHA_NUM_CHARS = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        " ",
        "$",
        "%",
        "*",
        "+",
        "-",
        ".",
        "/",
        ":"
      ];
      function AlphanumericData(data2) {
        this.mode = Mode.ALPHANUMERIC;
        this.data = data2;
      }
      AlphanumericData.getBitsLength = function getBitsLength(length) {
        return 11 * Math.floor(length / 2) + 6 * (length % 2);
      };
      AlphanumericData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      AlphanumericData.prototype.getBitsLength = function getBitsLength() {
        return AlphanumericData.getBitsLength(this.data.length);
      };
      AlphanumericData.prototype.write = function write(bitBuffer2) {
        let i;
        for (i = 0; i + 2 <= this.data.length; i += 2) {
          let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
          value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
          bitBuffer2.put(value, 11);
        }
        if (this.data.length % 2) {
          bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
        }
      };
      alphanumericData = AlphanumericData;
      return alphanumericData;
    }
    var byteData;
    var hasRequiredByteData;
    function requireByteData() {
      if (hasRequiredByteData) return byteData;
      hasRequiredByteData = 1;
      const Mode = requireMode();
      function ByteData(data2) {
        this.mode = Mode.BYTE;
        if (typeof data2 === "string") {
          this.data = new TextEncoder().encode(data2);
        } else {
          this.data = new Uint8Array(data2);
        }
      }
      ByteData.getBitsLength = function getBitsLength(length) {
        return length * 8;
      };
      ByteData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      ByteData.prototype.getBitsLength = function getBitsLength() {
        return ByteData.getBitsLength(this.data.length);
      };
      ByteData.prototype.write = function(bitBuffer2) {
        for (let i = 0, l = this.data.length; i < l; i++) {
          bitBuffer2.put(this.data[i], 8);
        }
      };
      byteData = ByteData;
      return byteData;
    }
    var kanjiData;
    var hasRequiredKanjiData;
    function requireKanjiData() {
      if (hasRequiredKanjiData) return kanjiData;
      hasRequiredKanjiData = 1;
      const Mode = requireMode();
      const Utils = requireUtils$1();
      function KanjiData(data2) {
        this.mode = Mode.KANJI;
        this.data = data2;
      }
      KanjiData.getBitsLength = function getBitsLength(length) {
        return length * 13;
      };
      KanjiData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      KanjiData.prototype.getBitsLength = function getBitsLength() {
        return KanjiData.getBitsLength(this.data.length);
      };
      KanjiData.prototype.write = function(bitBuffer2) {
        let i;
        for (i = 0; i < this.data.length; i++) {
          let value = Utils.toSJIS(this.data[i]);
          if (value >= 33088 && value <= 40956) {
            value -= 33088;
          } else if (value >= 57408 && value <= 60351) {
            value -= 49472;
          } else {
            throw new Error(
              "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
            );
          }
          value = (value >>> 8 & 255) * 192 + (value & 255);
          bitBuffer2.put(value, 13);
        }
      };
      kanjiData = KanjiData;
      return kanjiData;
    }
    var dijkstra = { exports: {} };
    var hasRequiredDijkstra;
    function requireDijkstra() {
      if (hasRequiredDijkstra) return dijkstra.exports;
      hasRequiredDijkstra = 1;
      (function(module2) {
        var dijkstra2 = {
          single_source_shortest_paths: function(graph, s, d) {
            var predecessors = {};
            var costs = {};
            costs[s] = 0;
            var open = dijkstra2.PriorityQueue.make();
            open.push(s, 0);
            var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
            while (!open.empty()) {
              closest = open.pop();
              u = closest.value;
              cost_of_s_to_u = closest.cost;
              adjacent_nodes = graph[u] || {};
              for (v in adjacent_nodes) {
                if (adjacent_nodes.hasOwnProperty(v)) {
                  cost_of_e = adjacent_nodes[v];
                  cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
                  cost_of_s_to_v = costs[v];
                  first_visit = typeof costs[v] === "undefined";
                  if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                    costs[v] = cost_of_s_to_u_plus_cost_of_e;
                    open.push(v, cost_of_s_to_u_plus_cost_of_e);
                    predecessors[v] = u;
                  }
                }
              }
            }
            if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
              var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
              throw new Error(msg);
            }
            return predecessors;
          },
          extract_shortest_path_from_predecessor_list: function(predecessors, d) {
            var nodes = [];
            var u = d;
            while (u) {
              nodes.push(u);
              predecessors[u];
              u = predecessors[u];
            }
            nodes.reverse();
            return nodes;
          },
          find_path: function(graph, s, d) {
            var predecessors = dijkstra2.single_source_shortest_paths(graph, s, d);
            return dijkstra2.extract_shortest_path_from_predecessor_list(
              predecessors,
              d
            );
          },
          /**
           * A very naive priority queue implementation.
           */
          PriorityQueue: {
            make: function(opts) {
              var T = dijkstra2.PriorityQueue, t = {}, key;
              opts = opts || {};
              for (key in T) {
                if (T.hasOwnProperty(key)) {
                  t[key] = T[key];
                }
              }
              t.queue = [];
              t.sorter = opts.sorter || T.default_sorter;
              return t;
            },
            default_sorter: function(a, b) {
              return a.cost - b.cost;
            },
            /**
             * Add a new item to the queue and ensure the highest priority element
             * is at the front of the queue.
             */
            push: function(value, cost) {
              var item = { value, cost };
              this.queue.push(item);
              this.queue.sort(this.sorter);
            },
            /**
             * Return the highest priority element in the queue.
             */
            pop: function() {
              return this.queue.shift();
            },
            empty: function() {
              return this.queue.length === 0;
            }
          }
        };
        {
          module2.exports = dijkstra2;
        }
      })(dijkstra);
      return dijkstra.exports;
    }
    var hasRequiredSegments;
    function requireSegments() {
      if (hasRequiredSegments) return segments;
      hasRequiredSegments = 1;
      (function(exports2) {
        const Mode = requireMode();
        const NumericData = requireNumericData();
        const AlphanumericData = requireAlphanumericData();
        const ByteData = requireByteData();
        const KanjiData = requireKanjiData();
        const Regex = requireRegex();
        const Utils = requireUtils$1();
        const dijkstra2 = requireDijkstra();
        function getStringByteLength(str) {
          return unescape(encodeURIComponent(str)).length;
        }
        function getSegments(regex2, mode2, str) {
          const segments2 = [];
          let result;
          while ((result = regex2.exec(str)) !== null) {
            segments2.push({
              data: result[0],
              index: result.index,
              mode: mode2,
              length: result[0].length
            });
          }
          return segments2;
        }
        function getSegmentsFromString(dataStr) {
          const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
          const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
          let byteSegs;
          let kanjiSegs;
          if (Utils.isKanjiModeEnabled()) {
            byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
            kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
          } else {
            byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
            kanjiSegs = [];
          }
          const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
          return segs.sort(function(s1, s2) {
            return s1.index - s2.index;
          }).map(function(obj) {
            return {
              data: obj.data,
              mode: obj.mode,
              length: obj.length
            };
          });
        }
        function getSegmentBitsLength(length, mode2) {
          switch (mode2) {
            case Mode.NUMERIC:
              return NumericData.getBitsLength(length);
            case Mode.ALPHANUMERIC:
              return AlphanumericData.getBitsLength(length);
            case Mode.KANJI:
              return KanjiData.getBitsLength(length);
            case Mode.BYTE:
              return ByteData.getBitsLength(length);
          }
        }
        function mergeSegments(segs) {
          return segs.reduce(function(acc, curr) {
            const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
            if (prevSeg && prevSeg.mode === curr.mode) {
              acc[acc.length - 1].data += curr.data;
              return acc;
            }
            acc.push(curr);
            return acc;
          }, []);
        }
        function buildNodes(segs) {
          const nodes = [];
          for (let i = 0; i < segs.length; i++) {
            const seg = segs[i];
            switch (seg.mode) {
              case Mode.NUMERIC:
                nodes.push([
                  seg,
                  { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
                  { data: seg.data, mode: Mode.BYTE, length: seg.length }
                ]);
                break;
              case Mode.ALPHANUMERIC:
                nodes.push([
                  seg,
                  { data: seg.data, mode: Mode.BYTE, length: seg.length }
                ]);
                break;
              case Mode.KANJI:
                nodes.push([
                  seg,
                  { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
                ]);
                break;
              case Mode.BYTE:
                nodes.push([
                  { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
                ]);
            }
          }
          return nodes;
        }
        function buildGraph(nodes, version2) {
          const table = {};
          const graph = { start: {} };
          let prevNodeIds = ["start"];
          for (let i = 0; i < nodes.length; i++) {
            const nodeGroup = nodes[i];
            const currentNodeIds = [];
            for (let j = 0; j < nodeGroup.length; j++) {
              const node = nodeGroup[j];
              const key = "" + i + j;
              currentNodeIds.push(key);
              table[key] = { node, lastCount: 0 };
              graph[key] = {};
              for (let n = 0; n < prevNodeIds.length; n++) {
                const prevNodeId = prevNodeIds[n];
                if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
                  graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
                  table[prevNodeId].lastCount += node.length;
                } else {
                  if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
                  graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version2);
                }
              }
            }
            prevNodeIds = currentNodeIds;
          }
          for (let n = 0; n < prevNodeIds.length; n++) {
            graph[prevNodeIds[n]].end = 0;
          }
          return { map: graph, table };
        }
        function buildSingleSegment(data2, modesHint) {
          let mode2;
          const bestMode = Mode.getBestModeForData(data2);
          mode2 = Mode.from(modesHint, bestMode);
          if (mode2 !== Mode.BYTE && mode2.bit < bestMode.bit) {
            throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode.toString(mode2) + ".\n Suggested mode is: " + Mode.toString(bestMode));
          }
          if (mode2 === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
            mode2 = Mode.BYTE;
          }
          switch (mode2) {
            case Mode.NUMERIC:
              return new NumericData(data2);
            case Mode.ALPHANUMERIC:
              return new AlphanumericData(data2);
            case Mode.KANJI:
              return new KanjiData(data2);
            case Mode.BYTE:
              return new ByteData(data2);
          }
        }
        exports2.fromArray = function fromArray(array2) {
          return array2.reduce(function(acc, seg) {
            if (typeof seg === "string") {
              acc.push(buildSingleSegment(seg, null));
            } else if (seg.data) {
              acc.push(buildSingleSegment(seg.data, seg.mode));
            }
            return acc;
          }, []);
        };
        exports2.fromString = function fromString(data2, version2) {
          const segs = getSegmentsFromString(data2, Utils.isKanjiModeEnabled());
          const nodes = buildNodes(segs);
          const graph = buildGraph(nodes, version2);
          const path = dijkstra2.find_path(graph.map, "start", "end");
          const optimizedSegs = [];
          for (let i = 1; i < path.length - 1; i++) {
            optimizedSegs.push(graph.table[path[i]].node);
          }
          return exports2.fromArray(mergeSegments(optimizedSegs));
        };
        exports2.rawSplit = function rawSplit(data2) {
          return exports2.fromArray(
            getSegmentsFromString(data2, Utils.isKanjiModeEnabled())
          );
        };
      })(segments);
      return segments;
    }
    var hasRequiredQrcode;
    function requireQrcode() {
      if (hasRequiredQrcode) return qrcode;
      hasRequiredQrcode = 1;
      const Utils = requireUtils$1();
      const ECLevel = requireErrorCorrectionLevel();
      const BitBuffer = requireBitBuffer();
      const BitMatrix = requireBitMatrix();
      const AlignmentPattern = requireAlignmentPattern();
      const FinderPattern = requireFinderPattern();
      const MaskPattern = requireMaskPattern();
      const ECCode = requireErrorCorrectionCode();
      const ReedSolomonEncoder = requireReedSolomonEncoder();
      const Version = requireVersion();
      const FormatInfo = requireFormatInfo();
      const Mode = requireMode();
      const Segments = requireSegments();
      function setupFinderPattern(matrix, version2) {
        const size = matrix.size;
        const pos = FinderPattern.getPositions(version2);
        for (let i = 0; i < pos.length; i++) {
          const row = pos[i][0];
          const col = pos[i][1];
          for (let r2 = -1; r2 <= 7; r2++) {
            if (row + r2 <= -1 || size <= row + r2) continue;
            for (let c = -1; c <= 7; c++) {
              if (col + c <= -1 || size <= col + c) continue;
              if (r2 >= 0 && r2 <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c >= 2 && c <= 4) {
                matrix.set(row + r2, col + c, true, true);
              } else {
                matrix.set(row + r2, col + c, false, true);
              }
            }
          }
        }
      }
      function setupTimingPattern(matrix) {
        const size = matrix.size;
        for (let r2 = 8; r2 < size - 8; r2++) {
          const value = r2 % 2 === 0;
          matrix.set(r2, 6, value, true);
          matrix.set(6, r2, value, true);
        }
      }
      function setupAlignmentPattern(matrix, version2) {
        const pos = AlignmentPattern.getPositions(version2);
        for (let i = 0; i < pos.length; i++) {
          const row = pos[i][0];
          const col = pos[i][1];
          for (let r2 = -2; r2 <= 2; r2++) {
            for (let c = -2; c <= 2; c++) {
              if (r2 === -2 || r2 === 2 || c === -2 || c === 2 || r2 === 0 && c === 0) {
                matrix.set(row + r2, col + c, true, true);
              } else {
                matrix.set(row + r2, col + c, false, true);
              }
            }
          }
        }
      }
      function setupVersionInfo(matrix, version2) {
        const size = matrix.size;
        const bits = Version.getEncodedBits(version2);
        let row, col, mod2;
        for (let i = 0; i < 18; i++) {
          row = Math.floor(i / 3);
          col = i % 3 + size - 8 - 3;
          mod2 = (bits >> i & 1) === 1;
          matrix.set(row, col, mod2, true);
          matrix.set(col, row, mod2, true);
        }
      }
      function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
        const size = matrix.size;
        const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
        let i, mod2;
        for (i = 0; i < 15; i++) {
          mod2 = (bits >> i & 1) === 1;
          if (i < 6) {
            matrix.set(i, 8, mod2, true);
          } else if (i < 8) {
            matrix.set(i + 1, 8, mod2, true);
          } else {
            matrix.set(size - 15 + i, 8, mod2, true);
          }
          if (i < 8) {
            matrix.set(8, size - i - 1, mod2, true);
          } else if (i < 9) {
            matrix.set(8, 15 - i - 1 + 1, mod2, true);
          } else {
            matrix.set(8, 15 - i - 1, mod2, true);
          }
        }
        matrix.set(size - 8, 8, 1, true);
      }
      function setupData(matrix, data2) {
        const size = matrix.size;
        let inc = -1;
        let row = size - 1;
        let bitIndex = 7;
        let byteIndex = 0;
        for (let col = size - 1; col > 0; col -= 2) {
          if (col === 6) col--;
          while (true) {
            for (let c = 0; c < 2; c++) {
              if (!matrix.isReserved(row, col - c)) {
                let dark = false;
                if (byteIndex < data2.length) {
                  dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
                }
                matrix.set(row, col - c, dark);
                bitIndex--;
                if (bitIndex === -1) {
                  byteIndex++;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if (row < 0 || size <= row) {
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      }
      function createData(version2, errorCorrectionLevel2, segments2) {
        const buffer = new BitBuffer();
        segments2.forEach(function(data2) {
          buffer.put(data2.mode.bit, 4);
          buffer.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
          data2.write(buffer);
        });
        const totalCodewords = Utils.getSymbolTotalCodewords(version2);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
        const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
          buffer.put(0, 4);
        }
        while (buffer.getLengthInBits() % 8 !== 0) {
          buffer.putBit(0);
        }
        const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
        for (let i = 0; i < remainingByte; i++) {
          buffer.put(i % 2 ? 17 : 236, 8);
        }
        return createCodewords(buffer, version2, errorCorrectionLevel2);
      }
      function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
        const totalCodewords = Utils.getSymbolTotalCodewords(version2);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
        const dataTotalCodewords = totalCodewords - ecTotalCodewords;
        const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
        const blocksInGroup2 = totalCodewords % ecTotalBlocks;
        const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
        const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
        const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
        const rs = new ReedSolomonEncoder(ecCount);
        let offset = 0;
        const dcData = new Array(ecTotalBlocks);
        const ecData = new Array(ecTotalBlocks);
        let maxDataSize = 0;
        const buffer = new Uint8Array(bitBuffer2.buffer);
        for (let b = 0; b < ecTotalBlocks; b++) {
          const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
          dcData[b] = buffer.slice(offset, offset + dataSize);
          ecData[b] = rs.encode(dcData[b]);
          offset += dataSize;
          maxDataSize = Math.max(maxDataSize, dataSize);
        }
        const data2 = new Uint8Array(totalCodewords);
        let index2 = 0;
        let i, r2;
        for (i = 0; i < maxDataSize; i++) {
          for (r2 = 0; r2 < ecTotalBlocks; r2++) {
            if (i < dcData[r2].length) {
              data2[index2++] = dcData[r2][i];
            }
          }
        }
        for (i = 0; i < ecCount; i++) {
          for (r2 = 0; r2 < ecTotalBlocks; r2++) {
            data2[index2++] = ecData[r2][i];
          }
        }
        return data2;
      }
      function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
        let segments2;
        if (Array.isArray(data2)) {
          segments2 = Segments.fromArray(data2);
        } else if (typeof data2 === "string") {
          let estimatedVersion = version2;
          if (!estimatedVersion) {
            const rawSegments = Segments.rawSplit(data2);
            estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
          }
          segments2 = Segments.fromString(data2, estimatedVersion || 40);
        } else {
          throw new Error("Invalid data");
        }
        const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
        if (!bestVersion) {
          throw new Error("The amount of data is too big to be stored in a QR Code");
        }
        if (!version2) {
          version2 = bestVersion;
        } else if (version2 < bestVersion) {
          throw new Error(
            "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
          );
        }
        const dataBits = createData(version2, errorCorrectionLevel2, segments2);
        const moduleCount = Utils.getSymbolSize(version2);
        const modules = new BitMatrix(moduleCount);
        setupFinderPattern(modules, version2);
        setupTimingPattern(modules);
        setupAlignmentPattern(modules, version2);
        setupFormatInfo(modules, errorCorrectionLevel2, 0);
        if (version2 >= 7) {
          setupVersionInfo(modules, version2);
        }
        setupData(modules, dataBits);
        if (isNaN(maskPattern2)) {
          maskPattern2 = MaskPattern.getBestMask(
            modules,
            setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
          );
        }
        MaskPattern.applyMask(maskPattern2, modules);
        setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
        return {
          modules,
          version: version2,
          errorCorrectionLevel: errorCorrectionLevel2,
          maskPattern: maskPattern2,
          segments: segments2
        };
      }
      qrcode.create = function create(data2, options) {
        if (typeof data2 === "undefined" || data2 === "") {
          throw new Error("No input text");
        }
        let errorCorrectionLevel2 = ECLevel.M;
        let version2;
        let mask;
        if (typeof options !== "undefined") {
          errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
          version2 = Version.from(options.version);
          mask = MaskPattern.from(options.maskPattern);
          if (options.toSJISFunc) {
            Utils.setToSJISFunction(options.toSJISFunc);
          }
        }
        return createSymbol(data2, version2, errorCorrectionLevel2, mask);
      };
      return qrcode;
    }
    var canvas = {};
    var utils = {};
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils) return utils;
      hasRequiredUtils = 1;
      (function(exports2) {
        function hex2rgba(hex) {
          if (typeof hex === "number") {
            hex = hex.toString();
          }
          if (typeof hex !== "string") {
            throw new Error("Color should be defined as hex string");
          }
          let hexCode = hex.slice().replace("#", "").split("");
          if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
            throw new Error("Invalid hex color: " + hex);
          }
          if (hexCode.length === 3 || hexCode.length === 4) {
            hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
              return [c, c];
            }));
          }
          if (hexCode.length === 6) hexCode.push("F", "F");
          const hexValue = parseInt(hexCode.join(""), 16);
          return {
            r: hexValue >> 24 & 255,
            g: hexValue >> 16 & 255,
            b: hexValue >> 8 & 255,
            a: hexValue & 255,
            hex: "#" + hexCode.slice(0, 6).join("")
          };
        }
        exports2.getOptions = function getOptions(options) {
          if (!options) options = {};
          if (!options.color) options.color = {};
          const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
          const width = options.width && options.width >= 21 ? options.width : void 0;
          const scale = options.scale || 4;
          return {
            width,
            scale: width ? 4 : scale,
            margin,
            color: {
              dark: hex2rgba(options.color.dark || "#000000ff"),
              light: hex2rgba(options.color.light || "#ffffffff")
            },
            type: options.type,
            rendererOpts: options.rendererOpts || {}
          };
        };
        exports2.getScale = function getScale(qrSize, opts) {
          return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
        };
        exports2.getImageWidth = function getImageWidth(qrSize, opts) {
          const scale = exports2.getScale(qrSize, opts);
          return Math.floor((qrSize + opts.margin * 2) * scale);
        };
        exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
          const size = qr.modules.size;
          const data2 = qr.modules.data;
          const scale = exports2.getScale(size, opts);
          const symbolSize = Math.floor((size + opts.margin * 2) * scale);
          const scaledMargin = opts.margin * scale;
          const palette = [opts.color.light, opts.color.dark];
          for (let i = 0; i < symbolSize; i++) {
            for (let j = 0; j < symbolSize; j++) {
              let posDst = (i * symbolSize + j) * 4;
              let pxColor = opts.color.light;
              if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
                const iSrc = Math.floor((i - scaledMargin) / scale);
                const jSrc = Math.floor((j - scaledMargin) / scale);
                pxColor = palette[data2[iSrc * size + jSrc] ? 1 : 0];
              }
              imgData[posDst++] = pxColor.r;
              imgData[posDst++] = pxColor.g;
              imgData[posDst++] = pxColor.b;
              imgData[posDst] = pxColor.a;
            }
          }
        };
      })(utils);
      return utils;
    }
    var hasRequiredCanvas;
    function requireCanvas() {
      if (hasRequiredCanvas) return canvas;
      hasRequiredCanvas = 1;
      (function(exports2) {
        const Utils = requireUtils();
        function clearCanvas(ctx, canvas2, size) {
          ctx.clearRect(0, 0, canvas2.width, canvas2.height);
          if (!canvas2.style) canvas2.style = {};
          canvas2.height = size;
          canvas2.width = size;
          canvas2.style.height = size + "px";
          canvas2.style.width = size + "px";
        }
        function getCanvasElement() {
          try {
            return document.createElement("canvas");
          } catch (e) {
            throw new Error("You need to specify a canvas element");
          }
        }
        exports2.render = function render(qrData, canvas2, options) {
          let opts = options;
          let canvasEl = canvas2;
          if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
            opts = canvas2;
            canvas2 = void 0;
          }
          if (!canvas2) {
            canvasEl = getCanvasElement();
          }
          opts = Utils.getOptions(opts);
          const size = Utils.getImageWidth(qrData.modules.size, opts);
          const ctx = canvasEl.getContext("2d");
          const image = ctx.createImageData(size, size);
          Utils.qrToImageData(image.data, qrData, opts);
          clearCanvas(ctx, canvasEl, size);
          ctx.putImageData(image, 0, 0);
          return canvasEl;
        };
        exports2.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
          let opts = options;
          if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
            opts = canvas2;
            canvas2 = void 0;
          }
          if (!opts) opts = {};
          const canvasEl = exports2.render(qrData, canvas2, opts);
          const type = opts.type || "image/png";
          const rendererOpts = opts.rendererOpts || {};
          return canvasEl.toDataURL(type, rendererOpts.quality);
        };
      })(canvas);
      return canvas;
    }
    var svgTag = {};
    var hasRequiredSvgTag;
    function requireSvgTag() {
      if (hasRequiredSvgTag) return svgTag;
      hasRequiredSvgTag = 1;
      const Utils = requireUtils();
      function getColorAttrib(color, attrib) {
        const alpha = color.a / 255;
        const str = attrib + '="' + color.hex + '"';
        return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
      }
      function svgCmd(cmd, x, y) {
        let str = cmd + x;
        if (typeof y !== "undefined") str += " " + y;
        return str;
      }
      function qrToPath(data2, size, margin) {
        let path = "";
        let moveBy = 0;
        let newRow = false;
        let lineLength = 0;
        for (let i = 0; i < data2.length; i++) {
          const col = Math.floor(i % size);
          const row = Math.floor(i / size);
          if (!col && !newRow) newRow = true;
          if (data2[i]) {
            lineLength++;
            if (!(i > 0 && col > 0 && data2[i - 1])) {
              path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
              moveBy = 0;
              newRow = false;
            }
            if (!(col + 1 < size && data2[i + 1])) {
              path += svgCmd("h", lineLength);
              lineLength = 0;
            }
          } else {
            moveBy++;
          }
        }
        return path;
      }
      svgTag.render = function render(qrData, options, cb) {
        const opts = Utils.getOptions(options);
        const size = qrData.modules.size;
        const data2 = qrData.modules.data;
        const qrcodesize = size + opts.margin * 2;
        const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
        const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size, opts.margin) + '"/>';
        const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
        const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
        const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
        if (typeof cb === "function") {
          cb(null, svgTag2);
        }
        return svgTag2;
      };
      return svgTag;
    }
    var hasRequiredBrowser;
    function requireBrowser() {
      if (hasRequiredBrowser) return browser;
      hasRequiredBrowser = 1;
      const canPromise2 = requireCanPromise();
      const QRCode2 = requireQrcode();
      const CanvasRenderer = requireCanvas();
      const SvgRenderer = requireSvgTag();
      function renderCanvas(renderFunc, canvas2, text, opts, cb) {
        const args = [].slice.call(arguments, 1);
        const argsNum = args.length;
        const isLastArgCb = typeof args[argsNum - 1] === "function";
        if (!isLastArgCb && !canPromise2()) {
          throw new Error("Callback required as last argument");
        }
        if (isLastArgCb) {
          if (argsNum < 2) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 2) {
            cb = text;
            text = canvas2;
            canvas2 = opts = void 0;
          } else if (argsNum === 3) {
            if (canvas2.getContext && typeof cb === "undefined") {
              cb = opts;
              opts = void 0;
            } else {
              cb = opts;
              opts = text;
              text = canvas2;
              canvas2 = void 0;
            }
          }
        } else {
          if (argsNum < 1) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 1) {
            text = canvas2;
            canvas2 = opts = void 0;
          } else if (argsNum === 2 && !canvas2.getContext) {
            opts = text;
            text = canvas2;
            canvas2 = void 0;
          }
          return new Promise(function(resolve, reject) {
            try {
              const data2 = QRCode2.create(text, opts);
              resolve(renderFunc(data2, canvas2, opts));
            } catch (e) {
              reject(e);
            }
          });
        }
        try {
          const data2 = QRCode2.create(text, opts);
          cb(null, renderFunc(data2, canvas2, opts));
        } catch (e) {
          cb(e);
        }
      }
      browser.create = QRCode2.create;
      browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
      browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
      browser.toString = renderCanvas.bind(null, function(data2, _, opts) {
        return SvgRenderer.render(data2, opts);
      });
      return browser;
    }
    var browserExports = requireBrowser();
    const QRCode = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
    function InviteButton({
      value,
      valueHint
    }) {
      const [existingInviteLink, setExistingInviteLink] = reactExports.useState();
      const { toast: toast2 } = useToast();
      const { me } = useAccount();
      return value && (me == null ? void 0 : me.canAdmin(value)) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          size: "sm",
          className: "py-0",
          disabled: !value._owner || !value.id,
          variant: "outline",
          onClick: async () => {
            let inviteLink = existingInviteLink;
            if (value._owner && value.id && !inviteLink) {
              inviteLink = createInviteLink(value, "writer", {
                valueHint
              });
              setExistingInviteLink(inviteLink);
            }
            if (inviteLink) {
              const qr = await QRCode.toDataURL(inviteLink, {
                errorCorrectionLevel: "L"
              });
              navigator.clipboard.writeText(inviteLink).then(
                () => toast2({
                  title: "Copied invite link to clipboard!",
                  description: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qr, className: "w-20 h-20" })
                })
              );
            }
          },
          children: "Invite"
        }
      );
    }
    function ProjectTodoTable() {
      const projectId = useParams().projectId;
      const project = useCoState(TodoProject, projectId, {
        resolve: {
          tasks: {
            $each: {
              text: true
            }
          }
        }
      });
      const createTask = reactExports.useCallback(
        (text) => {
          if (!(project == null ? void 0 : project.tasks) || !text) return;
          const task = Task.create(
            {
              done: false,
              text: CoPlainText.create(text, project._owner),
              version: 1
            },
            project._owner
          );
          project.tasks.push(task);
        },
        [project == null ? void 0 : project.tasks, project == null ? void 0 : project._owner]
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-full w-xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center gap-4 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
            // This is how we can access properties from the project query,
            // accounting for the fact that note everything might be loaded yet
            children: (project == null ? void 0 : project.title) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              project.title,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm", children: [
                "(",
                project.id,
                ")"
              ] })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "mt-1 w-[200px] h-[1em] rounded-full" })
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(InviteButton, { value: project, valueHint: "project" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "w-[40px]", children: "Done" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: "Task" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(TableBody, { children: [
            project == null ? void 0 : project.tasks.map(
              (task) => task && /* @__PURE__ */ jsxRuntimeExports.jsx(TaskRow, { task }, task.id)
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NewTaskInputRow, { createTask, disabled: !project })
          ] })
        ] })
      ] });
    }
    function TaskRow({ task }) {
      var _a, _b, _c, _d, _e, _f;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            className: "mt-1",
            checked: task == null ? void 0 : task.done,
            onCheckedChange: (checked) => {
              if (task) task.done = !!checked;
            }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row justify-between items-center gap-2", children: [
          (task == null ? void 0 : task.text) ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: (task == null ? void 0 : task.done) ? "line-through" : "", children: task.text }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "mt-1 w-[200px] h-[1em] rounded-full" }),
          // Here we see for the first time how we can access edit history
          // for a CoValue, and use it to display who created the task.
          ((_c = (_b = (_a = task == null ? void 0 : task._edits.text) == null ? void 0 : _a.by) == null ? void 0 : _b.profile) == null ? void 0 : _c.name) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "rounded-full py-0.5 px-2 text-xs",
              style: uniqueColoring(((_d = task._edits.text.by) == null ? void 0 : _d.id) ?? ""),
              children: (_f = (_e = task._edits.text.by) == null ? void 0 : _e.profile) == null ? void 0 : _f.name
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "mt-1 w-[50px] h-[1em] rounded-full" })
        ] }) })
      ] });
    }
    function NewTaskInputRow({
      createTask,
      disabled
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { className: "mt-1", disabled: true }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SubmittableInput,
          {
            onSubmit: (taskText) => createTask(taskText),
            label: "Add",
            placeholder: "New task",
            disabled
          }
        ) })
      ] });
    }
    function uniqueColoring(seed) {
      const darkMode = window.matchMedia("(prefers-color-scheme: dark)").matches;
      return {
        color: uniqolor(seed, { lightness: darkMode ? 80 : 20 }).color,
        background: uniqolor(seed, { lightness: darkMode ? 20 : 80 }).color
      };
    }
    const apiKey = "todo-example-jazz@garden.co";
    const wordlist = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    const appName = "Reskif - Todo List";
    function JazzAndAuth({ children }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        JazzReactProvider,
        {
          sync: {
            peer: `wss://cloud.jazz.tools/?key=${apiKey}`
          },
          AccountSchema: TodoAccount,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PassphraseAuthBasicUI, { appName, wordlist, children })
        }
      );
    }
    ReactDOM$2.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(JazzAndAuth, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleAndLogo, { name: appName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col h-full items-center justify-start gap-10 pt-10 pb-10 px-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
      ] }) }) })
    );
    function App() {
      const { logOut } = useAccount();
      const router = createHashRouter([
        {
          path: "/",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(HomeScreen, {})
        },
        {
          path: "/project/:projectId",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProjectTodoTable, {})
        },
        {
          path: "/invite/*",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Accepting invite..." })
        }
      ]);
      useAcceptInvite({
        invitedObjectSchema: TodoProject,
        forValueHint: "project",
        onAccept: (projectID) => router.navigate("/project/" + projectID)
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: () => router.navigate("/").then(logOut),
            variant: "outline",
            children: "Log out"
          }
        )
      ] });
    }
    function HomeScreen() {
      const { me } = useAccount(TodoAccount, {
        resolve: { root: { projects: { $each: { $onError: null } } } }
      });
      const navigate = useNavigate();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        (me == null ? void 0 : me.root.projects.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "My Projects" }) : null,
        me == null ? void 0 : me.root.projects.map((project) => {
          if (!project) return null;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => navigate("/project/" + (project == null ? void 0 : project.id)),
              variant: "ghost",
              children: project.title
            },
            project.id
          );
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NewProjectForm, {})
      ] });
    }
  }
});
export default require_index_001();
